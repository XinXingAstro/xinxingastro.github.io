<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Arrays类总结</title>
    <url>/2018/04/15/Java-Arrays%E7%B1%BB%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>Arrays累里面有很多操作数组很有用的方法。本文是对Arrays类里常用方法的总结。</p>
<a id="more"></a>

<h2 id="Arrays-sort-方法"><a href="#Arrays-sort-方法" class="headerlink" title="Arrays.sort()方法"></a>Arrays.sort()方法</h2><p>Arrays.sort()方法不仅可以对 byte[], char[], double[], float[], int[], long[], short[], Object[] 数组进行排序，而且还可以对自定义类型的数组进行排序。默认的排序顺序是从小到大，可以自定义比较器来自定义排序顺序。</p>
<ul>
<li><code>static void sort(byte[] a)</code></li>
<li><code>static void sort(byte[] a, int fromIndex, int toIndex)</code></li>
</ul>
<h3 id="例1-对二维数组进行排序"><a href="#例1-对二维数组进行排序" class="headerlink" title="例1: 对二维数组进行排序"></a>例1: 对二维数组进行排序</h3><p>这里传入一个二维数组matrix，以每行第1个元素为标准，从小到大对int[]类型的元素排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] testArraysSort(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    Arrays.sort(matirx, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面compare函数中国返回值是<code>o1[0] - o2[0]</code>，这样就会从小到大排序，如果换成<code>o2[0] - o1[0]</code>就会从大到小排序。</p>
<h3 id="例2-对自定义类型数组进行排序"><a href="#例2-对自定义类型数组进行排序" class="headerlink" title="例2: 对自定义类型数组进行排序"></a>例2: 对自定义类型数组进行排序</h3><p>我们自定义一个People类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    People(<span class="keyword">int</span> age, String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用Arrays.sort()方法以每个People对象的age从小到大排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">testArraysSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    People[] people = <span class="keyword">new</span> People[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        people[i] = <span class="keyword">new</span> People(i, <span class="string">"xx"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(people, <span class="keyword">new</span> Comparator&lt;Bear&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(People o1, People o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.age - o2.age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Arrays.sort()第一个传入参数是需要排序的对象，第二个传入参数是我们自定义的比较器，使用匿名内部类的形式编写，在匿名内部类内部，我们重写Comparator中的compare方法，传入两个参数，代表是people对象中需要进行对比的两个元素。</p>
<p>在compare方法内部，我们就可自定义排序规则了，compare方法返回一个int类型的数据，如果compare返回值是正数，则o1排在o2前面，如果返回负数o1排在o2后面。也可以这样记：<code>o1.age - o2.age</code>是从小到大排，<code>o2.age - o1.age</code>是从大到小排。</p>
<hr>
<h2 id="Arrays-fill-方法"><a href="#Arrays-fill-方法" class="headerlink" title="Arrays.fill()方法"></a>Arrays.fill()方法</h2><p>Arrays.fill()方法可以往数组里面填充内容，支持的数组类型有：boolean[], byte[], char[], double[], float[], int[], long[], short[], Object[]等。</p>
<ul>
<li><code>static void fill(boolean[] a, boolean val)</code></li>
<li><code>static void fill(boolean[] a, int fromIndex, int toIndex, boolean val)</code></li>
</ul>
<hr>
<h2 id="Arrays-binarySearch-方法"><a href="#Arrays-binarySearch-方法" class="headerlink" title="Arrays.binarySearch()方法"></a>Arrays.binarySearch()方法</h2><p>Arrays.binarySearch()方法可以在数组里进行二分查找，如果找到则返回对应元素的下标，如果没有找到，则返回一个负数，这个负数的含义是：<code>(-(insertion point) - 1)</code>。</p>
<p>支持的数组类型有：byte[], char[], double[], float[], int[], long[], short[], Object[], 还有自定义类型数组。</p>
<ul>
<li><code>static int binarySearch(byte[] a, byte key)</code></li>
<li><code>static int binarySearch(byte[] a, int fromIndex, int toIndex, byte key)</code></li>
</ul>
<h3 id="例1：在自定义类型数组中搜索元素"><a href="#例1：在自定义类型数组中搜索元素" class="headerlink" title="例1：在自定义类型数组中搜索元素"></a>例1：在自定义类型数组中搜索元素</h3><p>新建一个Bear类型，Bear有两个属性id和name，然后在main方法中新建一个长度为10的Bear数组，我们在Arrays.binarySearch方法中定义比较器，只比较Bear的id，如果id相同就认为找到了元素，然后返回找到元素在数组中的下标，如果没找到元素，会根据id从小到大的顺序返回一个包含插入点信息的负数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Bear</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    Bear(<span class="keyword">int</span> id, String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Bear[] bears = <span class="keyword">new</span> Bear[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        bears[i] = <span class="keyword">new</span> Bear(i, <span class="string">"xx"</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    Bear targetBear = <span class="keyword">new</span> Bear(<span class="number">12</span>, <span class="string">"XX"</span>);</span><br><span class="line">    <span class="keyword">int</span> res = Arrays.binarySearch(bears, targetBear, <span class="keyword">new</span> Comparator&lt;Bear&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Bear o1, Bear o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.id - o2.id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>JVM知识点总结</title>
    <url>/2018/08/07/Java-JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>JVM知识点总结。</p>
<p>参考：深入理解Java虚拟机：JVM高级特性与最佳实践。</p>
<a id="more"></a>

<h2 id="Java自动内存管理机制"><a href="#Java自动内存管理机制" class="headerlink" title="Java自动内存管理机制"></a>Java自动内存管理机制</h2><h3 id="JVM运行时数据区域"><a href="#JVM运行时数据区域" class="headerlink" title="JVM运行时数据区域"></a>JVM运行时数据区域</h3><p>Java虚拟机运行时数据区如下图所示：</p>
<p><img src="JVMRuntimeArea.png" alt="JVMRuntimeArea"></p>
<table>
<thead>
<tr>
<th>数据区域</th>
<th>是否线程私有</th>
<th>存储内容</th>
<th>抛出异常</th>
</tr>
</thead>
<tbody><tr>
<td>程序计数器</td>
<td>私有</td>
<td>存放当前线程执行字节码指定地址(若执行Native方法，则为空Undefined)。</td>
<td>无</td>
</tr>
<tr>
<td>Java虚拟机栈</td>
<td>私有</td>
<td>存放栈帧。</td>
<td>StackOverflowError, OutOfMemoryError</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>私有</td>
<td>为Native方法服务和Java虚拟机栈类似。</td>
<td>StackOverflowError, OutOfMemoryError</td>
</tr>
<tr>
<td>Java堆</td>
<td>共享</td>
<td>存放对象实例，数组。</td>
<td>OutOfMemoryError</td>
</tr>
<tr>
<td>方法区</td>
<td>共享</td>
<td>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</td>
<td>OutOfMemoryError</td>
</tr>
<tr>
<td>运行时常量池</td>
<td>共享</td>
<td>方法区的一部分，用于存放编译期生成的各种字面量和符号引用。</td>
<td>OutOfMemoryError</td>
</tr>
</tbody></table>
<p><strong>直接内存(Direct Memory)</strong>，不是虚拟机运行时数据区的一部分。JDK 1.4中加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，<strong>它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的应用进行操作</strong>。由于避免了在Java堆和Native堆中来回复制数据，所以能在一些场景中显著提高性能。也会有OutOfMemoryError异常。</p>
<blockquote>
<p>什么是线程私有内存</p>
<p>由于Java虚拟机的多线程是通过线程轮流切换分配处理器执行时间的方式来实现的，在任何一个确定的时刻， 一个处理器（对于多核处理来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有“的内存。</p>
<p>方法执行的本质：</p>
<p>每个方法执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至自行完成的过程，就对应着一个栈帧在虚拟机栈中入栈道出栈的过程。</p>
</blockquote>
<blockquote>
<p>内存溢出和内存泄露的区别</p>
<p>内存溢出(Out Of Memory)，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。</p>
<p>内存泄露(Memory Leak)，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</p>
<p>memory leak会最终会导致out of memory！</p>
</blockquote>
<blockquote>
<p>String.inter() 是一个Native方法，作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象，否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用</p>
</blockquote>
<h3 id="Hotspot虚拟机中的对象"><a href="#Hotspot虚拟机中的对象" class="headerlink" title="Hotspot虚拟机中的对象"></a>Hotspot虚拟机中的对象</h3><h4 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h4><p>对象创建过程，new指令底层发生了什么：首先检查这个指令的参数在常量池中能否定位到一个类的引用，并检查这个类是否被加载、解析和初始化过，如果没有则加载类，然后给对象分配内存，然后初始化对象如对象头信息</p>
<p>检查类是否加载 -&gt; 给对象分配内存 -&gt; 对对象进行初始化设置</p>
<p>对象分配内存方法：</p>
<ul>
<li>指针碰撞：空闲内存连续分布，分配内存只需移动指针，通常使用Serial、ParNew等带Compact过程的收集器。</li>
<li>空闲列表：空闲内存不连续分布，系统维护一个空闲内存列表，通常使用CMS这种基于Mark-Sweep算法的收集器。</li>
</ul>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>对象的内存分为3部分：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)</p>
<p>对象头分两部分：对象运行时数据和类型指针</p>
<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><ol>
<li>通过具柄访问对象</li>
</ol>
<p><img src="%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt="句柄访问对象"></p>
<ol start="2">
<li>通过直接指针访问</li>
</ol>
<p><img src="%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt="通过直接指针访问对象"></p>
<h3 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h3><p>垃圾收集器所关注的是Java堆和方法区这部分共享内存。</p>
<h4 id="判断对象是否已死的方法"><a href="#判断对象是否已死的方法" class="headerlink" title="判断对象是否已死的方法"></a>判断对象是否已死的方法</h4><h5 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1.引用计数法"></a>1.引用计数法</h5><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，当引用失效时，计数器值就减1，任何时刻计数器为0的对象就是不可能在被使用的。</p>
<p>优点：实现简单，判定效果高。</p>
<p>缺点：无法解决对象之间相互循环引用的问题。</p>
<h5 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2.可达性分析算法"></a>2.可达性分析算法</h5><p>Java、C#中都使用可达性分析算法判断对象是否存活。</p>
<p><img src="%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.png" alt="可达性分析算法"></p>
<p>通过一系列成为“GC Root”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径成为引用链(Reference Chain)，当一个对象到GC Roots没有任何引引用链时，证明此对象时不可用的。</p>
<p>可以作为GC Root的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中Native方法引用的对象。</li>
</ul>
<p>对象在进行可达性分析后还至少要进行两次标记才会被最终判定为死亡。</p>
<h4 id="4种引用类型"><a href="#4种引用类型" class="headerlink" title="4种引用类型"></a>4种引用类型</h4><table>
<thead>
<tr>
<th>引用类型</th>
<th>含义</th>
<th>被引用对象何时被回收</th>
</tr>
</thead>
<tbody><tr>
<td>强引用</td>
<td>代码中普遍使用的引用，如Object obj = new Object()</td>
<td>永远不会被回收</td>
</tr>
<tr>
<td>软引用</td>
<td>描述一些有用但并非必须的对象</td>
<td>在系统将要发生内存溢出异常之前回收</td>
</tr>
<tr>
<td>弱引用</td>
<td>描述非必须对象，强度比软引用更弱</td>
<td>对象只能生存在下次GC之前</td>
</tr>
<tr>
<td>虚引用</td>
<td>不会对对象生存时间构成影响，唯一目的是在对象被回收时收到一个系统通知</td>
<td>不一定</td>
</tr>
</tbody></table>
<h4 id="回收方法区-永久代"><a href="#回收方法区-永久代" class="headerlink" title="回收方法区(永久代)"></a>回收方法区(永久代)</h4><p>方法区也就是永久代的回收，主要回收两部分内容：废弃常量和无用的类。</p>
<p>常量池中的常量如果没有对象引用它，就会被回收。</p>
<p>无用类的判定：</p>
<ul>
<li>该类所有实例都已被回收。</li>
<li>该类的ClassLoader已被回收。</li>
<li>该类的Class对象没有在任何地方被引用。</li>
</ul>
<h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><h5 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法(Mark-Sweep)"></a>标记-清除算法(Mark-Sweep)</h5><p>先标记所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p>
<p>每个对象判定死亡之少要进行两次标记，可达性分析后没有引用链的对象会被第一次标记，第一次标记后系统会判断对象是否需要执行finalize()方法，如果需要执行finalize()方法，对象会被放入一个F-Queue队列，系统调用一个低优先级的线程执行F-Queue队列中的finalize()方法，如果对象在finalize()方法中重新获得引用链就可复活，稍后系统会执行第二次标记，被第二次标记的对象就会被回收。</p>
<p>两点不足：</p>
<ol>
<li>标记和清除的效率不高。</li>
<li>标记清楚后会产生大量不连续的内存碎片，分配大对象时找不到连续内存空间可能提前触发下一次垃圾回收。</li>
</ol>
<p><img src="%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt="标记清除算法"></p>
<h5 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a>复制算法(Copying)</h5><p>将内存划分为大小相等的两块，每次使用其中一块，当一块内存用完了要进行垃圾回收时，将存活的对象复制到另一块内存上，然后把已经使用过的内存一次清理掉。</p>
<p>优点：每次对半块内存进行回收，不用考虑内存碎片的问题，实现简单高效。</p>
<p>缺点：将内存缩小为了原来的一半。</p>
<p><img src="%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="复制算法"></p>
<p>现代虚拟机都采用这种算法来回收新生代（Java堆）。IBM公司研究表明98%的对象都是“朝生夕死”，所以将Java堆按照8 : 1 : 1的比例分为Eden空间和两块小的Servivor空间，每次使用Eden和其中一块Servivor。</p>
<p>当回收时，将Eden和Servivor中还存活的对象复制到另一块Servivor空间上，最后清理掉Eden和刚才用过的Survivor空间。</p>
<p>由于我们不能保证每次存活的对象都不多鱼内存的10%，所以当Survivor空间不够用时，需要依赖老年代进行分配担保(Handle Promotion)，既如果另外一块Survivor空间没有足够空间存放上一次新生代手机下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</p>
<h5 id="标记-整理算法-Mark-Compart"><a href="#标记-整理算法-Mark-Compart" class="headerlink" title="标记-整理算法(Mark-Compart)"></a>标记-整理算法(Mark-Compart)</h5><p>应用在老年代，标记所有需要回收的对象，然后让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><img src="%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.jpg" alt="标记整理算法"></p>
<h5 id="分代收集算法-Generational-Collection"><a href="#分代收集算法-Generational-Collection" class="headerlink" title="分代收集算法(Generational Collection)"></a>分代收集算法(Generational Collection)</h5><p>当前商业虚拟机都采用分代手机算法。将Java堆内存分为新生代和老年代，方法区为永久代。新生代中对象存活率低，所以选用复制算法对新生代进行垃圾收集，只需要付出少量存货对象的复制成本就可以完成收集。老年代中对象存活率高，没有额外空间对它进行分配担保，就必须使用标记清理或者标记整理算法来回收。</p>
<p>Eden : Survivor : Survivor = 8 : 1 : 1</p>
<p>Eden + 2*Servivor : Old = 1 : 3 或 3 : 8</p>
<p><img src="%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E4%BB%A3.png" alt="堆内存分代"></p>
<p>当我们第一次new出一个对象的时候，特别大的对象，直接放在老年代(Old)，其他的普通对象，放在新生代(Eden)。</p>
<p>在经过一次GC（垃圾回收）之后，Eden中还存活（有引⽤用指向）的对象，就会跑到Survivor1中去。又经过一次GC，Eden中存活的+Survivor1中的对象，都复制到Survivor2中，再经过一次GC，Eden中存活的+Survivor2中的对象，都复制到Survivor1中。</p>
<p>如果经过多次垃圾回收之后，Survivor中一直存在某个对象，就把这个对象放进老年代中去。</p>
<blockquote>
<p>补充说明：</p>
<p>新生代GC（Minor GC）：指发生在新生代的垃圾收集，由于Java对象大多朝生夕死，所以Minor GC非常频繁，一般回收速度也快。</p>
<p>老年代GC（Major GC / Full GC）：指发生在老年代的GC，出现Full GC经常会伴随至少一次Minor GC，Full GC速度一般会比Minor GC慢10倍以上。</p>
</blockquote>
<h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><h5 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h5><p>一个单线程<strong>新生代</strong>收集器，使用<strong>复制算法</strong>，在垃圾收集时必须暂停其他所有工作线程“Stop The World”，直到它收集结束。<strong>是虚拟机运行在Client模式下的默认新生代收集器。</strong></p>
<p>优点：单线程简单高效。</p>
<p>缺点：收集时会有停顿。</p>
<p><img src="Serial%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="Serial收集器"></p>
<h5 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h5><p>Serial收集器的<strong>多线程</strong>版本，除了使用多线程，其余和Serial完全一样。<strong>是运行在Server模式下的虚拟机中首选的新生代收集器</strong>。</p>
<p>除了Serial收集器外，目前<strong>只有它能与CMS收集器(老年代收集器)配合工作。</strong></p>
<p><img src="ParNew.jpg" alt="ParNew"></p>
<blockquote>
<p>补充说明：</p>
<p>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p>
<p>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行与另一个CUP上。</p>
</blockquote>
<h5 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h5><p>一个<strong>新生代并行多线程</strong>收集器，使用复制算法，也叫<strong>吞吐量优先</strong>收集器。Parallel Scavenge收集器的目标是让垃圾收集的时间占用总的CPU时间最少，既达到最大的吞吐量。</p>
<p>CMS收集器的目标是尽可能缩短垃圾收集时用户线程停顿的时间。CMS更适合用在与用户交互的程序中，Parallel Scavenge更适合用在后台运算的程序中。</p>
<p>Parallel Scavenge收集器提供了两个参数控制吞吐量：</p>
<ul>
<li>-XX:MaxGCPauseMillis : 最大垃圾收集时间。</li>
<li>-XX:GCTimeRatio : 吞吐量大小。</li>
</ul>
<p>使用Parallel Scavenge收集器的可以通过<strong>-XX:UseAdaptiveSizePolicy</strong>开启GC自适应调节策略，将内存调优任务交给虚拟机去完成。</p>
<p><img src="Parallel.png" alt="Parallel"></p>
<h5 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h5><p>Serial的<strong>老年代</strong>版本，单线程收集器，使用<strong>标记-整理</strong>算法，主要意义是给Client模式下的虚拟机使用，如果在Server模式下它还有两大用途：</p>
<ol>
<li>在JDK 1.5之前的版本中与Parallel Scavenge收集器搭配使用。</li>
<li>作为CMS收集器的后备方案。</li>
</ol>
<h5 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h5><p>Parallel Scavenge收集器的老年代版本，使用<strong>多线程</strong>和<strong>标记-整理</strong>算法。</p>
<h5 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h5><p>CMS(Concurrent Mark Sweep)是一种以获取<strong>最短回收停顿</strong>时间为目标的<strong>老年代</strong>收集器。CMS非常适合用于互联网站或者B/S系统服务器上，这类应用重视服务响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</p>
<p>CMS收集器基于标记-清除算法，它的运作过程更复杂一点，分为4个步骤：</p>
<ol>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark)</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ol>
<p>初始标记、重新标记两个步骤需要”Stop The World“，初始标记仅仅标记GC Root直接关联对象，速度很快。</p>
<p>并发标记阶段要进行可达性分析，耗时最长。</p>
<p>重新标记是为了修正并发标记期间用户对标记对象做的更改，耗时比初始标记长但远比并发标记短。</p>
<p>由于整个过程中耗时最长的<strong>并发标记</strong>和<strong>并发清除</strong>过程收集器线程都与用户线程并发工作，所以从总体上来看，CMS收集器的回收过程是与用户线程并发执行的。</p>
<p><img src="CMS.png" alt="CMS"></p>
<p>CMS收集器的缺点：</p>
<ol>
<li>对CPU资源敏感</li>
<li>无法收集浮动垃圾（在标记过程中出现的垃圾）</li>
<li>由于基于标记-清除算法，收集结束后会有大量空间碎片。</li>
</ol>
<h5 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h5><p>G1（Garbage-First）一款面向服务端应用的垃圾收集器，整体基于<strong>标记-整理</strong>算法，局部基于<strong>复制算法</strong>。不许要和其他收集器配合就能独立管理整个GC堆。有如下特点：</p>
<ol>
<li>并行并发</li>
<li>分代收集</li>
<li>空间整理</li>
<li>可预测的停顿</li>
</ol>
<p>G1将整个Java堆灰粉为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，他们都是一部分Region（不需要连续）的集合。</p>
<p>G1收集器之所以能建立可预测的停顿时间模型，是因为它有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获的空间大小，回收所需的时间经验），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（所谓Garbage-First）.</p>
<p>G1收集器运作大致可划分为以下几个步骤：</p>
<ol>
<li>初始标记（Initial Marking）</li>
<li>并发标记（Cxoncurrent Marking）</li>
<li>最终标记（Final Marking）</li>
<li>筛选回收（Live Data Counting and Evacuation）</li>
</ol>
<p><img src="G1%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="G1收集器"></p>
<h4 id="垃圾收集器总结"><a href="#垃圾收集器总结" class="headerlink" title="垃圾收集器总结"></a>垃圾收集器总结</h4><table>
<thead>
<tr>
<th>垃圾收集器</th>
<th>收集区域</th>
<th>收集算法</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>新生代</td>
<td>复制</td>
<td>单线程，简单高效，收集时停顿大，Client模式下的默认收集器。</td>
</tr>
<tr>
<td>ParNew</td>
<td>新生代</td>
<td>复制</td>
<td>Serial的多线程版本，可以和CMS配合使用。</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>新生代</td>
<td>复制</td>
<td>多线程，吞吐量优先收集器。Server模式下默认收集器。</td>
</tr>
<tr>
<td>Serial Old</td>
<td>老年代</td>
<td>标记-整理</td>
<td>单线程，Client模式下默认收集器。</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>老年代</td>
<td>标记-整理</td>
<td>多线程，和Parallel Scavenge搭配使用。Server模式默认收集器。</td>
</tr>
<tr>
<td>CMS</td>
<td>老年代</td>
<td>复杂版标记-清除</td>
<td>多线程，最短回收停顿收集器，对CPU资源敏感，无法收集标记过程中产生的垃圾，会产生空间碎片。</td>
</tr>
<tr>
<td>G1</td>
<td>所有</td>
<td>标记-整理+复制</td>
<td>多线程，分代收集，空间整理，可预测停顿。</td>
</tr>
</tbody></table>
<h4 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h4><p><img src="%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0.png" alt="垃圾收集器相关参数"></p>
<h4 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h4><p>Java中的自动内存管理最终可以归结为自动化地解决两个问题：</p>
<p><strong>1. 给对象分配内存。</strong></p>
<p><strong>2. 回收分配给对象的内存。</strong></p>
<p>大体来讲对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配，少数情况下也有可能直接分配在老年代中。</p>
<p>普遍内存分配规则：</p>
<h5 id="1-对象优先在Eden分配"><a href="#1-对象优先在Eden分配" class="headerlink" title="1. 对象优先在Eden分配"></a>1. 对象优先在Eden分配</h5><p>大多数情况下，对象在新生代Eden区中分配，当Eden区没有狗狗空间进行分配时，虚拟机将发起一次 Minor GC。</p>
<h5 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h5><p>大对象指需要大量连续内存空间的Java对象，比如很长的字符串或者数组，大对象对虚拟机来说是个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来安置他们。</p>
<p><code>-XX:PretenureSizeThreshold</code>指定对象大于这个值的时候直接在老年代分配。</p>
<h5 id="3-长期存活的对象将进入老年代"><a href="#3-长期存活的对象将进入老年代" class="headerlink" title="3. 长期存活的对象将进入老年代"></a>3. 长期存活的对象将进入老年代</h5><p>JVM会给每个对象定义一个对象年龄（Age）计数器，如果对象在Eden出生并经过第一次Minor GC后存活，并被移动到Survivor空间，那么对象年龄设为1，对象在Survivor中每熬过一次Minor GC，年龄就加1，当年龄增长到一定程度（默认为15岁），就将会被晋升到老年代中，对象晋升年龄的阀值通过<code>-XX:MaxTenuringThreshold</code>设置。</p>
<h5 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h5><p>如果在Survivor空间中相同年龄的对象占用空间的的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无序等到MaxTenuringThreshold中要求的年龄。</p>
<h5 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h5><p>在发生Minoc GC 之前。虚拟机会先检查老年代最大可用的连结空间是否大于新生代所有对象总大小或者历次晋升的平均大小，只要大于就会进行MinorGC，否则将进行Full GC。</p>
<h3 id="虚拟机性能监控与故障处理工具"><a href="#虚拟机性能监控与故障处理工具" class="headerlink" title="虚拟机性能监控与故障处理工具"></a>虚拟机性能监控与故障处理工具</h3><h4 id="JDK的命令行工具"><a href="#JDK的命令行工具" class="headerlink" title="JDK的命令行工具"></a>JDK的命令行工具</h4><h5 id="jps：虚拟机进程状况工具"><a href="#jps：虚拟机进程状况工具" class="headerlink" title="jps：虚拟机进程状况工具"></a>jps：虚拟机进程状况工具</h5><p><img src="jps%E9%80%89%E9%A1%B9.png" alt="jps选项"></p>
<p>VMID(Virtual Machine Identifier)和LVMID(Local Virtual Machine Identifier)如果是本地虚拟机进程，两者是一样的，如果是远程虚拟机进程，VMID的格式应当是：</p>
<p><code>[protocol:][//]lvim[@hostname[:port]/servername]</code></p>
<h5 id="jstat：虚拟机统计信息监视工具"><a href="#jstat：虚拟机统计信息监视工具" class="headerlink" title="jstat：虚拟机统计信息监视工具"></a>jstat：虚拟机统计信息监视工具</h5><p><code>jstat [option vmid [interval[s|ms] [count]]]</code></p>
<p>例：需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次，命令应当是：</p>
<p><code>jstat -gc 2764 250 20</code></p>
<p>option选项如下所示：</p>
<p><img src="jstatOption.png" alt="jstatOption"></p>
<h5 id="jinfo：Java配置信息工具"><a href="#jinfo：Java配置信息工具" class="headerlink" title="jinfo：Java配置信息工具"></a>jinfo：Java配置信息工具</h5><p>作用是<strong>实时查看和调整虚拟机各项参数</strong>。</p>
<p><code>jinfo [optioin] pid</code></p>
<p><code>jinfo -v</code> : 查看虚拟机启动时显式指定的参数列表。 </p>
<p><code>jinfo -flag</code> : 查看参数的系统默认值</p>
<h5 id="jmap：Java内存映像工具"><a href="#jmap：Java内存映像工具" class="headerlink" title="jmap：Java内存映像工具"></a>jmap：Java内存映像工具</h5><p>用于生成<strong>堆转存快照</strong>（一般叫heapdump或dump文件）。</p>
<p><img src="jmap.png" alt="jmap"></p>
<h5 id="jhat：虚拟机堆转储快照分析工具"><a href="#jhat：虚拟机堆转储快照分析工具" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h5><h5 id="jstack：Java堆栈跟踪工具"><a href="#jstack：Java堆栈跟踪工具" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h5><p>用于生成虚拟机当前时刻的<strong>线程快照</strong>（一般称为threaddump或者javacore文件）。</p>
<p><img src="jstack.png" alt="jstack"></p>
<h5 id="HSDIS：JIT生成代码反汇编"><a href="#HSDIS：JIT生成代码反汇编" class="headerlink" title="HSDIS：JIT生成代码反汇编"></a>HSDIS：JIT生成代码反汇编</h5><h4 id="JDK的可视化工具"><a href="#JDK的可视化工具" class="headerlink" title="JDK的可视化工具"></a>JDK的可视化工具</h4><h5 id="JConsole：Java监视与管理控制台"><a href="#JConsole：Java监视与管理控制台" class="headerlink" title="JConsole：Java监视与管理控制台"></a>JConsole：Java监视与管理控制台</h5><h5 id="VisualVM：多合一故障处理工具"><a href="#VisualVM：多合一故障处理工具" class="headerlink" title="VisualVM：多合一故障处理工具"></a>VisualVM：多合一故障处理工具</h5><h3 id="调优案例分析与实战"><a href="#调优案例分析与实战" class="headerlink" title="调优案例分析与实战"></a>调优案例分析与实战</h3><h4 id="案例：高性能硬件上的程序部署策略"><a href="#案例：高性能硬件上的程序部署策略" class="headerlink" title="案例：高性能硬件上的程序部署策略"></a>案例：高性能硬件上的程序部署策略</h4><p>在高性能硬件上部署程序目前主要有两种方式：</p>
<ol>
<li>通过64位JDK使用大内存。</li>
<li>使用若干个32位虚拟机建立逻辑集群来利用硬件资源。</li>
</ol>
<h5 id="通过64位JDK使用大内存"><a href="#通过64位JDK使用大内存" class="headerlink" title="通过64位JDK使用大内存"></a>通过64位JDK使用大内存</h5><p>使用大内存就是造成一个问题：Full GC的时间特别长。</p>
<p>如果部署的是面向用户的应用，要使用这种方法部署应用就必须保证程序中Full GC的频率控制的足够低，要想降低程序Full GC的频率，就要确保老年代的空间比较稳定，要确保老年代的空间总是够用，就要确保程序中不会出现很多大对象，不会有很多年龄大的对象，尤其不能用成批的、长生存时间的大对象产生，这就要求我们在代码上进行优化。</p>
<h5 id="使用若干个32位虚拟机建立逻辑集群来利用硬件资源"><a href="#使用若干个32位虚拟机建立逻辑集群来利用硬件资源" class="headerlink" title="使用若干个32位虚拟机建立逻辑集群来利用硬件资源"></a>使用若干个32位虚拟机建立逻辑集群来利用硬件资源</h5><p>可以在一台物理机器上启动多个服务器进程，每个服务器进程分配不同端口，在前端搭建一个反向代理服务器，实现负载均衡。</p>
<p>这种方法可能会遇到下面一些问题：</p>
<ul>
<li>资源竞争，如磁盘竞争。</li>
<li>很难高效利用某些资源，由于进群环境中很多东西都是重复的。</li>
<li>32位系统内存限制最高4GB。</li>
<li>大量使用本地缓存的应用，会造成大量内存浪费。</li>
</ul>
<h4 id="案例：集群间同步导致的内存溢出"><a href="#案例：集群间同步导致的内存溢出" class="headerlink" title="案例：集群间同步导致的内存溢出"></a>案例：集群间同步导致的内存溢出</h4><p>在当前网络情况无法满足集群间同步消息的传输要求时，重发数据在内存中不断积累，就会产生内存溢出。</p>
<h4 id="案例：堆外内存导致的溢出错误"><a href="#案例：堆外内存导致的溢出错误" class="headerlink" title="案例：堆外内存导致的溢出错误"></a>案例：堆外内存导致的溢出错误</h4><p>如果系统中用到了NIO的话，NIO操作会使用到Direct Memory内存。垃圾收集时，虚拟机虽然也会对Direct Memory进行回收，但是Direct Memory不能像新生代、老年代那用发现空间不足了就通知收集器进行垃圾回收，它只能等待Full GC时，随便帮它清理垃圾，否则就只能抛出内存溢出异常。</p>
<p>从时间经验的角度出发，处理Java堆和永久代（方法区）之外，下面这些区域也会占用较多的内存，所有的内存总和收到操作系统进程最大内存的限制。</p>
<ol>
<li>Direct Memory：可通过<code>-XX:MaxDirectMemorySize</code>调整大小，内存不足时抛出OutOfMemoryError或者OutOfMemoryError:Direct buffer memory。</li>
<li>线程堆栈：可通过-Xss调整大小，内存不足时抛出StackOverFlowError（纵向无法分配，既无法分配新的栈帧）或者OutOfMemoryError: Unable to create new native thread（横向无法分配，既无法建立新的线程）。</li>
<li>Socket缓存区：每个Socket连接都 Receive 和 Send 两个缓存区，分别占大约37KB和25KB内存，连接太多无法分配时会抛出：IOException: Too many open files异常。</li>
<li>JNI代码：如果代码中使用JNI调用本地库，那本地库使用的内存也不在堆中。</li>
<li>虚拟机和GC：虚拟机、GC的代码执行也要消耗一定的内存。</li>
</ol>
<h4 id="案例：外部命令导致系统缓慢"><a href="#案例：外部命令导致系统缓慢" class="headerlink" title="案例：外部命令导致系统缓慢"></a>案例：外部命令导致系统缓慢</h4><blockquote>
<p>fork系统调用是Linux用来产生新进程的。</p>
</blockquote>
<p>如果每个用户请求的处理都需要执行一个外部shell脚本来获得一些系统信息，这个shell脚本通过java的Runtime.getRuntime().exec()方法来调用，这种调用是非常消耗资源的操作，JVM执行这个命令的过程是：先克隆一个和当前虚拟机拥有一样环境变量的进程，再用这个新的进程区执行外部命令，最后再推出这个进程，如果频繁执行这个操作，CPU和内存的消耗就会很大。</p>
<p>建议使用Java自带API获取这些系统信息。</p>
<h4 id="案例：服务器JVM进程崩溃"><a href="#案例：服务器JVM进程崩溃" class="headerlink" title="案例：服务器JVM进程崩溃"></a>案例：服务器JVM进程崩溃</h4><p>JVM进程崩溃适应位调用外部OA系统的不可用接口，又使用异步调用方式，由于积累了越来越多的Web服务没有调用完成，导致在等待的线程和Socke连接越来越多，最终超过虚拟机的承受能力后虚拟机进程崩溃。</p>
<p>解决方法：通知OA门户修复无法使用的继承接口，并将异步调用改为生产者/消费者模式的消息队列实现。</p>
<h4 id="案例：不恰当数据结构导致内存占用过大"><a href="#案例：不恰当数据结构导致内存占用过大" class="headerlink" title="案例：不恰当数据结构导致内存占用过大"></a>案例：不恰当数据结构导致内存占用过大</h4><p>使用HashMap&lt;Long, Long&gt;结构来存储数据文件空间效率太低。</p>
<h4 id="案例：由Windows虚拟内存导致的长时间停顿"><a href="#案例：由Windows虚拟内存导致的长时间停顿" class="headerlink" title="案例：由Windows虚拟内存导致的长时间停顿"></a>案例：由Windows虚拟内存导致的长时间停顿</h4><p>GUI程序最小化的时候工作内存会被系统交换到虚拟内存中，会导致不正常的GC停顿。可以加入参数<code>-Dsun.awt.keepWorkingSetOnMinimize=true</code>来解决。</p>
<hr>
<h2 id="虚拟机执行子系统"><a href="#虚拟机执行子系统" class="headerlink" title="虚拟机执行子系统"></a>虚拟机执行子系统</h2><p>各种不同平台的虚拟机于所有平台都统一使用的程序存储格式——字节码（ByteCode）是构成平台无关性的基石。</p>
<p>Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。</p>
<h3 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h3><p>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据结构：无符号数和表。</p>
<ul>
<li>无符号数：数据基本数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li>
<li>表：由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾，表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。</li>
</ul>
<p><img src="Class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.png" alt="Class文件格式"></p>
<p>无论是符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个<strong>前置的容量计数器</strong>加<strong>若干个连续的数据项</strong>的形式，这时称这一系列连续的某一类型的数据为某一类型的集合。</p>
<h4 id="magic-魔数"><a href="#magic-魔数" class="headerlink" title="magic 魔数"></a>magic 魔数</h4><p>每个Class文件的头4个字节称为魔数（Magic Number），确定这个文件是否位一个能被虚拟机接收的Class文件。</p>
<p>Class文件魔数：<strong>0xCAFEBABE</strong></p>
<h4 id="minor-version-次版本号"><a href="#minor-version-次版本号" class="headerlink" title="minor_version 次版本号"></a>minor_version 次版本号</h4><h4 id="major-version-主版本号"><a href="#major-version-主版本号" class="headerlink" title="major_version 主版本号"></a>major_version 主版本号</h4><h4 id="constant-pool-count-constant-pool-常量池"><a href="#constant-pool-count-constant-pool-常量池" class="headerlink" title="constant_pool_count, constant_pool 常量池"></a>constant_pool_count, constant_pool 常量池</h4><p>常量池是Class文件中的资源仓库，是与其他项目关联最多、占用空间最大的数据项之一，是Class文件中第一个出现的表类型数据项目。</p>
<p>常量池中存放两大类常量：字面量（Literal）、符号引用（Symbolic References）</p>
<p>字面量是Java程序中的字符串，final常量等。</p>
<p>符号引用包含下面三类常量：</p>
<ul>
<li>类和接口的全限定名（Fully Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法的名称和描述符</li>
</ul>
<p>Java代码在编译时，不会有”连接“这一步，而是在虚拟机加载Class文件的时候进行动态连接。</p>
<blockquote>
<p>类全名：com.xinxing.MyClass。</p>
<p>类的全限定名：将类全名中的”.”替换成”/“，如com/xinxing/MyClass。多个全限定名之间需要加”;”分隔。</p>
<p>简单名称：没有类型和参数修饰的方法或者字段名称。</p>
</blockquote>
<h4 id="access-flags-类访问标志"><a href="#access-flags-类访问标志" class="headerlink" title="access_flags 类访问标志"></a>access_flags 类访问标志</h4><p>用于识别一些类或者接口层次的访问信息，包括：</p>
<ul>
<li>这个Class是类还是接口。</li>
<li>是否定义为public类型。</li>
<li>是否定义为abstract类型。</li>
<li>如果是类，是否声明为final。</li>
</ul>
<p>具体标志如下：</p>
<p><img src="%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" alt="访问标志"></p>
<h4 id="this-class-类索引"><a href="#this-class-类索引" class="headerlink" title="this_class 类索引"></a>this_class 类索引</h4><p>指定类的全限定名。</p>
<h4 id="super-class-父类索引"><a href="#super-class-父类索引" class="headerlink" title="super_class 父类索引"></a>super_class 父类索引</h4><p>指定父类全限定名。</p>
<h4 id="interfaces-count-interfaces-接口索引集合"><a href="#interfaces-count-interfaces-接口索引集合" class="headerlink" title="interfaces_count, interfaces 接口索引集合"></a>interfaces_count, interfaces 接口索引集合</h4><p>描述这个类实现了哪些接口。</p>
<h4 id="fields-count-fields-字段表集合"><a href="#fields-count-fields-字段表集合" class="headerlink" title="fields_count, fields 字段表集合"></a>fields_count, fields 字段表集合</h4><p>描述接口或类中声明的变量。</p>
<p><img src="%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="字段表结构"></p>
<h4 id="methods-count-methods-方法表集合"><a href="#methods-count-methods-方法表集合" class="headerlink" title="methods_count, methods 方法表集合"></a>methods_count, methods 方法表集合</h4><p><img src="%E6%96%B9%E6%B3%95%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="方法表结构"></p>
<p>方法里的Java代码，经过编译器编译生成字节码指令，存放在方法属性表集合的一个名为“Code”的属性里。</p>
<h4 id="attributes-count-attributes-属性表集合"><a href="#attributes-count-attributes-属性表集合" class="headerlink" title="attributes_count, attributes 属性表集合"></a>attributes_count, attributes 属性表集合</h4><p>Class文件、字段表、方法表都可以携带自己的属性表结合，用于描述某些场景专有信息。</p>
<h3 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h3><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，类型的加载、连接和初始化过程都是在程序运行期间完成的。</p>
<h4 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h4><p>类的生命周期如下图所示：</p>
<p><img src="%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="类的生命周期"></p>
<p>加载、验证、准备、初始化和卸载这5个阶段的开始顺序是确定的。解析阶段有可能在初始化之后才开始，这是为了支持Java的运行时绑定（动态绑定）。</p>
<p>初始化开始时机有且仅有下面这5种情况：</p>
<ol>
<li>遇到new, getstatic, putstatic, invokestatic这4个字节码指令时。</li>
<li>使用java.lang.reflect包的方法对类进行反射调用时。</li>
<li>初始化子类时，如果发现父类还没有被初始化，则要先初始化父类。</li>
<li>虚拟机启动时，用户需要指定一个要执行的主类（包含mian()方法的那个类），虚拟机会先初始化主类。</li>
<li>使用JDK1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_GetStatic, REF_putStatic, REF_invokeStatic的方法句柄，这个方法对应的类没有被初始化时要进行初始化。</li>
</ol>
<p>这5种情况称为对一个类进行主动引用。除此之外所有引用类的方式都不会触发初始化，称为被动引用。</p>
<p>下面时3个备用引用的例子：</p>
<p>例1: 通过子类引用父类的静态字段，不会导致子类初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只会输出：“SuperClass init!”</p>
<p>例2：通过数组定义类应用类，不会触发此类的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后没有输出“SuperClass init!“</p>
<p>例3：常量在编译阶段会存入调用类的常量池中，本质上并没有引用到定义常量的类，因此不会触发定义常量的类的初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"ConstClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stirng[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有输出“ConstClass init”，因为在编译阶段通过常量的传播优化，已经将常量的值”hello world”存储到了NotInitialization类的常量池中。以后对该常量的引用就转换成NotInitialization类对自身常量池的引用了。</p>
<p>一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</p>
<h4 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h4><p>加载 =&gt; 验证 =&gt; 准备 =&gt; 解析 =&gt; 初始化</p>
<h5 id="加载-Loading"><a href="#加载-Loading" class="headerlink" title="加载 Loading"></a>加载 Loading</h5><p>加载阶段虚拟机需要完成3件事：</p>
<ol>
<li>通过一个类的全限定名来<strong>获取定义此类的二进制字节流</strong>。</li>
<li>将这个字节流所代表的静态存储结构转化为<strong>方法区的运行时数据结构</strong>。</li>
<li>在内存中<strong>生成</strong>一个代表这个类的<strong>java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>对于非数组类的加载可以使用系统提供的引导类加载器来完成，也可以通过重写类加载器的loadClass()方法用自定义类加载器去完成。</p>
<p>数组类本身不通过类加载器创建，它是有Java虚拟机直接创建的。但数组中的元素类型最终是要靠类加载器去创建，一个数组类的创建过程遵循以下规则：</p>
<ul>
<li>如果数组的元素类型是引用类型，如String[]，就递归的使用该类型的类加载器去加载，并且在该加载器的命名空间上表示该数组。</li>
<li>如果数组元素类型是普通类型，如int[]，Java虚拟机将会把数组标记为与引导类加载器关联。</li>
<li>数组类的可见性与元素类型的可见性一致，如果数组是普通类型，那么可见性默认为public。</li>
</ul>
<h5 id="验证-Verification"><a href="#验证-Verification" class="headerlink" title="验证 Verification"></a>验证 Verification</h5><p>是连接阶段的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>验证阶段会完成4个检验动作：</p>
<ol>
<li>文件格式验证。</li>
<li>元数据验证。</li>
<li>字节码验证。</li>
<li>符号引用验证。</li>
</ol>
<h5 id="准备-Preparation"><a href="#准备-Preparation" class="headerlink" title="准备 Preparation"></a>准备 Preparation</h5><p>准备阶段是正式为<strong>类变量</strong>（被sattic修饰的变量）分配内存并设置类变量初始值的阶段，这些变量都将在方法区分配内存。</p>
<ul>
<li>这时候分配内存的只有static变量，实例变量将在对象实例化时睡着对象一起分配在Java堆中。</li>
<li>初始值时类型零值。</li>
</ul>
<p><img src="%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%9B%B6%E5%80%BC.png" alt="基本数据类型零值"></p>
<p>注意：static final变量会在准备阶段就被设置为指定值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>; <span class="comment">//value准备阶段就是123。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>; <span class="comment">//value在准备阶段是0，在初始化阶段才会设为123.</span></span><br></pre></td></tr></table></figure>

<h5 id="解析-Resolution"><a href="#解析-Resolution" class="headerlink" title="解析 Resolution"></a>解析 Resolution</h5><p>虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<blockquote>
<p>符号引用（Symbolic References）：用一组符号来描述所引用的目标，可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</p>
<p>直接引用（Direct References）：可以是直接指向目标的指针，相对偏移量，或一个能间接定位到目标的句柄。</p>
</blockquote>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p>
<h5 id="初始化-Initialization"><a href="#初始化-Initialization" class="headerlink" title="初始化 Initialization"></a>初始化 Initialization</h5><p>初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p>
<p><code>&lt;clinit&gt;()</code>方法特点：</p>
<ul>
<li><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的， 静态语句块中只能访问到定义在静在语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</p>
</li>
<li><p><code>&lt;clinit&gt;()</code>方法与类的构造函数（或者说实例构造器<code>&lt;init&gt;()</code>方法）不同，它不需要显式地调用父类构造器， 虚拟机会保证在子类的的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕．因此在虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类肯定是java.lang.Object。</p>
</li>
<li><p>由于父类的<code>&lt;clinit&gt;()</code>方法先执行，也就意味着父类中定义的静态语句块要先于子类的变量赋值操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stringp[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(Sub.B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B的值将会是2不是1.</p>
</li>
<li><p><code>&lt;clinit&gt;()</code>方法对于类和接口不是必须的，如果一个类中没有静态语句块，也没有对变量的复制操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法。</p>
</li>
<li><p>接口中不能使用静态语句块，但仍有变量初始化的赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法。但接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法，只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</p>
</li>
<li><p>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁，同步，如果多个线程通化市区初始化一个类，那么只有一个线程区执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。如果一个类的<code>&lt;clinit&gt;()</code>方法中有好事很长的操作，就可能造成多个线程阻塞。</p>
</li>
</ul>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><h5 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h5><p>类加载器用来获取描述此类的二进制字节流。类加载器完成加载过程中的第一步。</p>
<p>每一个类加载器都有一个独立的类名称空间，比较两个类是否相等，只有在这两个类是有同一个类加载器加载的前题下吃啊有意义，否则，即使这两个类来由于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</p>
<h5 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h5><p>从Java程序员的角度来看有3种不同的类加载器：</p>
<ol>
<li>启动类加载器（Bootstrap ClassLoader）：使用C++语言实现，是虚拟机自身的一部分。这个类加载器负责将存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录中的，或者被-Xbootchlasspath参数所指定的路径中的，并且可以被虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要吧加载器请求委派给引导类加载器，那直接使用null代替即可。</li>
<li>扩展类加载器（Extension ClassLoader）：由sum.misc.Launcher$ExtClassLoader实现，负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用该加载器。</li>
<li>应用程序类加载器（Application ClassLoader）：又叫系统类加载器，是ClassLoader中的getSystemClassLoader()方法的返回值。由sum.misc.Launcher$AppClassLoader实现。负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用该加载器，如果没有自定义加载器，它既是程序中的默认加载器。</li>
</ol>
<p>这些加载器的关系如下图所示：</p>
<p><img src="%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" alt="类加载器双亲委派模型"></p>
<p>双亲委派模型的工作过程是：如果一个加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是吧这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当副加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找打所需的类）时，子加载器才会尝试自己去加载。</p>
<p>双亲委派模型的好处：Java类随着它的类加载器一同具备了一种带有优先级的层次关系。如java.lang.Object类，存放在rt.jar中，所有加载器加载Object类的时候都会委派给启动类加载器加载，因此Object类在程序的各种类加载器环境中都是同一个类。如果没有双亲委派模型，各个类执行加载的话，系统中将出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序将会变得一团乱。</p>
<h3 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h3><h4 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h4><p>栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。栈帧存储了方法的：</p>
<ul>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态连接</li>
<li>方法返回地址</li>
</ul>
<p>每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。</p>
<p>对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，成为当前栈帧（Current Stack Frame），与这个栈帧关联的方法称为当前方法（Current Method），执行引擎运行的所有字节码指令都只针对当前栈帧进行操作，栈帧结构如下图所示：</p>
<p><img src="%E6%A0%88%E5%B8%A7.png" alt="栈帧"></p>
<h5 id="局部变量表-Local-Variable-Table"><a href="#局部变量表-Local-Variable-Table" class="headerlink" title="局部变量表 Local Variable Table"></a>局部变量表 Local Variable Table</h5><p>存放方法参数和方法内部定义的局部变量。局部变量表的容量以变量槽（Variable Slot）为最小单位，一个Solt占用32为内存空间。</p>
<h5 id="操作数栈-Operand-Stack"><a href="#操作数栈-Operand-Stack" class="headerlink" title="操作数栈 Operand Stack"></a>操作数栈 Operand Stack</h5><p>是一个后五险处（Last In First Out，LIFO）栈。操作数栈的每一个元素可以是任意Java数据类型，包括long和double，32位数据占用1个容量，64位数据占用2个容量。</p>
<p>在方法刚开始执行的时候操作数栈是空的，在方法执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，既出栈/入栈操作。</p>
<h5 id="动态连接-Dynamic-Linking"><a href="#动态连接-Dynamic-Linking" class="headerlink" title="动态连接 Dynamic Linking"></a>动态连接 Dynamic Linking</h5><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的应用，持有这个引用是为了支持方法调用过程中的动态链接。</p>
<ul>
<li>静态解析：常量池中一部分方法的符号引用在<strong>类加载阶段</strong>或者<strong>第一次使用</strong>的时候就转化为直接引用，这种转化成为静态解析。</li>
<li>动态连接：另一部分将在<strong>每一次运行期间</strong>转化为直接引用，这部分称为动态连接。</li>
</ul>
<h5 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h5><p>两种方法退出方式：</p>
<ul>
<li>正常完成出口（Normal Method Invocation Completion）：执行引擎遇到方法返回的字节码指令退出方法。</li>
<li>异常完成出口（Abrupt Method Invocation Completion）：方法在执行过程中遇到异常，并且在方法体内没有解决异常，导致的方法退出。</li>
</ul>
<p>方法退出的过程实际上就等同于把当前栈帧出栈。因此退出是可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值雅茹调用者栈帧的操作数栈中，调整PC计数器的值指向方法调用指令后面一条指令等。</p>
<h5 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h5><p>一些规范之外的信息。如调试信息。</p>
<blockquote>
<p>栈帧信息 = 动态连接 + 方法返回地址 + 其他附加信息</p>
</blockquote>
<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>方法调用阶段的唯一任务是确定被调用方法的版本。</p>
<h5 id="解析-Resolution-1"><a href="#解析-Resolution-1" class="headerlink" title="解析 Resolution"></a>解析 Resolution</h5><p>方法在程序运行前就已经确定，并在在运行期间不可改变。调用这类方法称为<strong>解析</strong>。</p>
<p>满足编译器可知，运行期不可变的方法主要包括<strong>静态方法</strong>和<strong>私有方法</strong>两大类。</p>
<p><strong>非虚方法</strong>：编译器可知，运行期不可变的方法包括<strong>静态方法</strong>，<strong>私有方法</strong>，<strong>实例构造器</strong>，<strong>父类方法</strong>4类。</p>
<p>与非虚方法对应的是虚方法。</p>
<h5 id="分派-Dispatch"><a href="#分派-Dispatch" class="headerlink" title="分派 Dispatch"></a>分派 Dispatch</h5><p><strong>1.静态分派</strong></p>
<p>所有依赖<strong>静态类型</strong>来定位方法执行版本的分派动作称为<strong>静态分派</strong>。静态分派的典型应用是方法重载。静态分派发生在<strong>编译阶段</strong>，因此确定静态分派的动作实际上不是有虚拟机来执行的（是由Javac编译器来执行的）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello, guy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello, man"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello, lady"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        StaticDispatch sr = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">        sr.sayHello(man);</span><br><span class="line">        sr.sayHello(women);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line">hello,guy</span><br><span class="line">hello,guy</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure>

<p>Human称为变量的静态类型（Static Type）或叫外观类型（Apparent Type）。</p>
<p>Man称为变量的实际类型（Actual Type）。</p>
</blockquote>
<p>静态类型是在编译期可知的，而实际类型的在运行期才能被确定，编译期在编译程序的时候并不知道一个对象的实际类型是什么。</p>
<p>编译器在重载时是通过参数的静态类型而不是实际类型作为判定依据的，并且静态类型是编译器可知的，所以在编译阶段，Javac编译器就会根据参数的静态类型决定了使用哪个版本的重载。</p>
<p>所以上面代码选择了sayHello(Human)作为调用目标，并把这个方法的符号引用写到main()方法里的两条invokevirtual指令的参数中。</p>
<p><strong>2.动态分派</strong></p>
<p>在<strong>运行期间</strong>根据<strong>实际类型</strong>确定方法执行版本的分派过程称为<strong>动态分派</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"man say hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"women say hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stirng[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line">        man = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">man say hello</span><br><span class="line">woman say hello</span><br><span class="line">woman say hello</span><br></pre></td></tr></table></figure>

<p>上面main方法中sayHello()方法调用代码翻译成字节码指令后如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16:aload_1</span><br><span class="line">17:invokevirtual #22</span><br><span class="line">20:aload_2</span><br><span class="line">21:invokevirtual #22</span><br></pre></td></tr></table></figure>

<p>对应代码中的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man();</span><br><span class="line">Human woman = <span class="keyword">new</span> Woman();</span><br></pre></td></tr></table></figure>

<p>16, 20两句分别把刚刚创建的两个对象的引用压到栈顶，<strong>这两个对象</strong>是将要执行的sayHello()的所有者，称为<strong>接收者（Receiver）</strong>。</p>
<blockquote>
<p><strong>invokevirtual</strong>指令的<strong>多态查找过程</strong>：</p>
<ol>
<li>找到操作数栈顶的第一个元素所指向的对象的<strong>实际类型</strong>，记作C。</li>
<li>如果在类型C中找到与常量中的<strong>描述符</strong>和<strong>简单名称</strong>都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常。</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.lang.AbstrctMethodError异常。</li>
</ol>
</blockquote>
<p>由于invokevirtual指令执行的第一步就是在运行期确定接受者的实际类型，所以两次调用中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言中方法重写的本质。</p>
<p><strong>3.单分派与多分派</strong></p>
<blockquote>
<p>方法的宗量 = 方法的接受者 + 方法的参数</p>
<p>单分派：根据一个宗量对目标方法进行选择。</p>
<p>多分派：根据多于一个宗量对目标方法进行选择。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QQ</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">_360</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father chooose qq"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">harChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose 360"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son chooose qq"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">harChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose 360"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stirng[] args)</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        Father son = <span class="keyword">new</span> Son();</span><br><span class="line">        father.harChoice(<span class="keyword">new</span> _360());</span><br><span class="line">        son.hardChoice(<span class="keyword">new</span> QQ());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">father choose <span class="number">360</span></span><br><span class="line">son choose qq</span><br></pre></td></tr></table></figure>

<p>在编译阶段，静态分派时，选择目标方法的依据由两点：</p>
<ol>
<li>静态类型时Father还是Son。</li>
<li>方法参数时QQ还是360。</li>
</ol>
<p>因为根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型。</p>
<p>静态分派的产物是两个invokevirtual指令，两条指定的参数分别为常量池中指向Father.harChoice(360)和Father.harChoice(QQ)方法的符号引用。</p>
<p>运行阶段，动态分派时，在执行<code>son.hardChoic(new QQ())</code>语句编译出的invokevirtual指令时，由于编译期间已经决定目标方法的签名必须为hardChoice(QQ)，这时唯一影响虚拟机选择的宗量只有方法的接受者的实际类型时Father还是Son，因为只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型。</p>
<p>Java是一门静态多分派、动态单分派的语言。</p>
<p><strong>4.虚拟机动态分派的实现</strong></p>
<p>由于动态分派是非常频繁的动作，而且动态分派需要在类的方法的元数据中搜索合适的目标方法，因此虚拟机中最常用的稳定优化手段就是为类在方法区中建立一个<strong>虚方法表</strong>，使用虚方法表索引来代替元数据查找以提高性能。</p>
<p><img src="%E8%99%9A%E6%96%B9%E6%B3%95%E8%A1%A8.png" alt="虚方法表"></p>
<p>虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口就是父类方法实现的地址入口。如果子类重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。</p>
<p>上图中Son重写了来自Father的全部方法，因此Son方法表没有志向Father类型数据的箭头。但是Son和Father都没有重写Object的方法，所以他们的方法表中所有从Object继承来的方法都指向了Object的数据类型。</p>
<p>方法表在类加载的<strong>连接阶段</strong>进行初始化。</p>
<h2 id="程序编译与代码优化"><a href="#程序编译与代码优化" class="headerlink" title="程序编译与代码优化"></a>程序编译与代码优化</h2><h3 id="早期（编译期）优化"><a href="#早期（编译期）优化" class="headerlink" title="早期（编译期）优化"></a>早期（编译期）优化</h3><p>Java语言的编译器可能有三种：</p>
<ul>
<li>前端编译器：把<code>*.java</code>文件转换为<code>*.class</code>文件。前端编译器有：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）。</li>
<li>后端运行期编译器（JIT编译器，Just In Time Compiler）：把字节码转变成机器码。JIT编译器有：HotSpot VM的C1、C2编译器。</li>
<li>静态提前编译器（AOT编译器，Ahead Of Time Compiler）：直接把<code>*.java</code>文件编译成本地机器代码。AOT编译器有：GNU Compiler for the Java (GCJ)、Excelsior JET。</li>
</ul>
<p>Javac这类前端编译器对代码的运行效率几乎没有任何优化措施，虚拟机设计团队把对性能的优化集中到了后端的JIT编译器中，这样可以让那些不是由Javac产生的Class文件也同样能享受到编译器优化所带来的好处。但是很多新生的Java语法特性是依靠编译器的“语法糖”来实现，而不是依靠虚拟机的底层改进来支持，</p>
<p>可以说，Java中JIT编译器在运行期的优化过程对于程序运行来说更重要，而前端Javac编译器在编译期的优化过程对于程序编码来说关系更加密切。</p>
<h4 id="Javac编译器"><a href="#Javac编译器" class="headerlink" title="Javac编译器"></a>Javac编译器</h4><p>Javac编译过程大致可以分为3个过程：</p>
<ol>
<li>解析与填充符号表过程。</li>
<li>插入式注解处理器的注解处理过程。</li>
<li>分析与字节码生成过程。</li>
</ol>
<p>这3个步骤之间的关系与交互顺序如下所示：</p>
<p><img src="javac-compiler.jpg" alt="javac-compiler"></p>
<p>Javac编译过程的主体代码如下图所示：</p>
<p><img src="javac%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E4%B8%BB%E4%BD%93%E4%BB%A3%E7%A0%81.png" alt="javac编译过程主体代码"></p>
<p>整个编译最关键的处理就由图中标注的8个方法来完成。</p>
<h3 id="晚期（运行期）优化"><a href="#晚期（运行期）优化" class="headerlink" title="晚期（运行期）优化"></a>晚期（运行期）优化</h3><p>在本分商用虚拟机（Sun HotSpot、IBM J9）中，Java程序最初是用过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就回吧这些代码认定为“热点代码”（Hot Spot Code）。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（JIT编译器，Just In Time Compiler）。</p>
<p>虽然Java虚拟机规范中没有规定Java虚拟机内必须要有急事编译器存在，但是，JIT编译器编译性能的好坏、代码优化程度的高低却是衡量一款商用虚拟机优秀与否的最关键指标之一。</p>
<h3 id="常用JVM指令总结"><a href="#常用JVM指令总结" class="headerlink" title="常用JVM指令总结"></a>常用JVM指令总结</h3><table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:MaxPermSize</td>
<td>指定方法区最大内存</td>
</tr>
<tr>
<td>-XX:PermSize</td>
<td>指定方法区默认大小</td>
</tr>
<tr>
<td>-Xms</td>
<td>指定堆内存初始空间，如-Xms20m</td>
</tr>
<tr>
<td>-Xmx</td>
<td>指定堆内存最大空间，如-Xmx20m</td>
</tr>
<tr>
<td>-Xmn</td>
<td>指定新生代大小</td>
</tr>
<tr>
<td>-Xss</td>
<td>指定栈容量大小。如-Xss123k</td>
</tr>
<tr>
<td>-XX:MaxDirectMemorySize=10</td>
<td>指定直接内存空间为10MB</td>
</tr>
<tr>
<td>-XX:+/-UseTLAB</td>
<td>指定是否使用本地线程分配缓存</td>
</tr>
<tr>
<td>-XX:+HeapDumpOnOutOfMemoryError</td>
<td>让虚拟机在出现内存溢出异常时 Dump 出当前内存堆转储快照</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>Survivor占用空间比例=Eden/Survivor</td>
</tr>
<tr>
<td>-XX:PretenureSizeThreshold</td>
<td>占用连续内存空间大于这个值的对象直接在老年代中分配。</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold</td>
<td>对象晋升老年代年龄阀值</td>
</tr>
<tr>
<td>-XX:+PrintTenuringDistribution</td>
<td>打印对象年龄分布</td>
</tr>
<tr>
<td>-XX:HandlePromotionFailure</td>
<td>是否允许担保失败</td>
</tr>
<tr>
<td>-XX:UseConcMarkSweepGC</td>
<td>使用CMS收集器</td>
</tr>
<tr>
<td>-XX:+UseParNewGC</td>
<td>使用ParNew收集器</td>
</tr>
<tr>
<td>-XX:ParallelGCThreads</td>
<td>限制垃圾收集的线程数</td>
</tr>
<tr>
<td>-XX:MaxGCPauseMillis</td>
<td>最大垃圾收集停顿时间。</td>
</tr>
<tr>
<td>-XX:GCTimeRatio</td>
<td>吞吐量</td>
</tr>
<tr>
<td>-XX:UseAdaptiveSizePolicy</td>
<td>使用GC自适应调节策略，Parallel Scavenge收集器参数</td>
</tr>
<tr>
<td>-XX:+PrintGCDetails</td>
<td>发生GC时打印内存收集日志</td>
</tr>
<tr>
<td>-XX:+PrintFlagsFinal</td>
<td>查看虚拟机参数默认值0</td>
</tr>
<tr>
<td>-Xint</td>
<td>禁止编译器运作</td>
</tr>
<tr>
<td>-XX:+DisableExplicitGC</td>
<td>屏蔽System.gc()</td>
</tr>
<tr>
<td>-XX:+TraceClassLoading</td>
<td>跟踪类加载</td>
</tr>
<tr>
<td>-Xbootclasspath</td>
<td>设置启动类路径</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>HashMap底层实现原理</title>
    <url>/2018/05/11/Java-HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>HashMap底层原理总结，几个Hash集合之间的对比。</p>
<blockquote>
<p>参考：<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665514069&idx=1&sn=2996d864bbe596d0af763fba3d244fa7&chksm=80d67c16b7a1f500ec6a191eb4a0beac0e95dbd5a7bf8ee01f5ed2cb17960b9ab32c0b965949&mpshare=1&scene=23&srcid=0511zKy6mTSHoIFPfB3xP31n#rd">什么是HashMap？</a></p>
<p>参考：<a href="https://tech.meituan.com/java-hashmap.html">Java 8系列之重新认识HashMap</a></p>
</blockquote>
<a id="more"></a>

<hr>
<h3 id="HashMap底层存储结构"><a href="#HashMap底层存储结构" class="headerlink" title="HashMap底层存储结构"></a>HashMap底层存储结构</h3><p>HashMap是一个用于存储Key-Value键值对的集合，每一个键值对也叫做一个Entry。这些Entry分散存储在一个数组当中，这个数组就是HashMap的主干。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment"> * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为table数组的长度是有限的，再好的hash函数也会出现index冲突的情况，所以我们用<strong>链表</strong>来解决这个问题，table数组的每一个元素不只是一个Entry对象，也是一个链表的头节点，每一个Entry对象通过Next指针指向下一个Entry节点。当新来的Entry映射到冲突数组位置时，只需要插入对应的链表即可。</p>
<p>需要注意的是：新来的Entry节点插入链表时，会插在链表的头部，因为HashMap的发明者认为，后插入的Entry被查找的可能性更大。</p>
<p>HashMap中的table数组如下所示：</p>
<p><img src="hashmap-table.png" alt="hashmap-table"></p>
<p>所以，HashMap是数组+链表+红黑树（在Java 8中为了优化Entry的查找性能，新加了红黑树部分）实现的。</p>
<h3 id="Put方法原理"><a href="#Put方法原理" class="headerlink" title="Put方法原理"></a>Put方法原理</h3><p>调用<code>hashMap.put(&quot;str&quot;, 1)</code>，将会在HashMap的table数组中插入一个Key为“str”的元素，这时候需要我们用一个<code>hash()</code>函数来确定Entry的插入位置，而每种数据类型有自己的<code>hashCode()</code>函数，比如String类型的<code>hashCode()</code>函数如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">byte</span> v : value) &#123;</span><br><span class="line">        h = <span class="number">31</span> * h + (v &amp; <span class="number">0xff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，<code>put()</code>函数的执行路径是这样的：</p>
<ol>
<li>首先<code>put(&quot;str&quot;, 1)</code>会调用HashMap的<code>hash(&quot;str&quot;)</code>方法。</li>
<li>在<code>hash()</code>内部，会调用String(Latin1)内部的<code>hashcode()</code>获取字符串”str”的hashcode。</li>
<li>“str”的hashcode被返回给<code>put()</code>，<code>put()</code>通过一定计算得到最终的插入位置index。</li>
<li>最后将这个Entry插入到table的index位置。</li>
</ol>
<p>这里就出现了两个问题，问题1: 在<code>put()</code>里怎样得到插入位置index？问题2: 为什么会调用HashMap的<code>hash()</code>函数，直接调用String的<code>hashcode()</code>不好吗？</p>
<h4 id="问题1-在put-里怎样得到插入位置index？"><a href="#问题1-在put-里怎样得到插入位置index？" class="headerlink" title="问题1: 在put()里怎样得到插入位置index？"></a>问题1: 在<code>put()</code>里怎样得到插入位置index？</h4><p>对于不同的hash码我们希望它被插入到不同的位置，所以我们首先会想到对数组长度的取模运算，但是由于取模运算的效率很低，所以HashMap的发明者用位运算替代了取模运算。</p>
<p>在<code>put()</code>里是通过如下的语句得到插入位置的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index &#x3D; hash(key) &amp; (Length - 1)</span><br></pre></td></tr></table></figure>

<p>其中Length是table数组的长度。为了实现和取模运算相同的功能，这里要求(Length - 1)这部分的二进制表示全为1，我们用HashMap的默认初始长度16举例说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设&quot;str&quot;的hash吗为: 1001 0110 1011 1110 1101 0010 1001 0101</span><br><span class="line"></span><br><span class="line">Length - 1 &#x3D; 15 : 1111</span><br><span class="line"></span><br><span class="line">hash(&quot;str&quot;) &amp; (Length - 1) &#x3D; 0101</span><br></pre></td></tr></table></figure>

<p>如果(Length - 1)这部分不全为1，假如Length是10，那么<code>Length - 1 = 9 ：1001</code> 那么无论再和任何hash码做与操作，中间两位数都会是0，这样就会出现大量不同的hash码被映射到相同位置的情况。</p>
<p>所以，<strong>在HashMap中table数组的默认长度是16，并且要求每次自动扩容或者手动扩容时，长度都必须是2的幂。</strong></p>
<h4 id="问题2-为什么会调用HashMap的hash-函数，直接调用String的hashcode-不好吗？"><a href="#问题2-为什么会调用HashMap的hash-函数，直接调用String的hashcode-不好吗？" class="headerlink" title="问题2: 为什么会调用HashMap的hash()函数，直接调用String的hashcode()不好吗？"></a>问题2: 为什么会调用HashMap的<code>hash()</code>函数，直接调用String的<code>hashcode()</code>不好吗？</h4><p>HashMap中的<code>hash()</code>函数如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap中的<code>hash()</code>函数是将得到hashcode做进一步处理，它将hashcode的高16位和低16位进行异或操作，这样做的目的是：在table的长度比较小的情况下，也能保证hashcode的高位参与到地址映射的计算当中，同时不会有太大的开销。</p>
<p>综上所述：从hashcode计算得到table索引的计算过程如下所示：</p>
<p><img src="hash%E8%BF%87%E7%A8%8B.png" alt="hash过程"></p>
<p><code>put()</code>方法的执行过程如下所示：</p>
<p><img src="hash-put.png" alt="hash-put"></p>
<h3 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h3><p>在HashMap中有一下两个属性和扩容相关：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<p>其中<strong>threshold = Length * loadFactor</strong>，Length表示table数组的长度（默认值是16），loadFactor为负载因子（默认值是0.75），阀值threshold表示当table数组中存储的元素超过这个阀值的时候，就需要扩容了。以默认长度16，和默认负载因子0.75为例，threshold = 16 * 0.75 = 12，即当table数组中存储的元素个数超过12个的时候，table数组就该扩容了。</p>
<p>当然Java中的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，然后将旧数组中的元素经过重新计算放到新数组中，那么怎样对旧元素进行重新映射呢？</p>
<p>其实很简单，由于我们在扩容时，是使用2的幂扩展，即数组的长度扩大到原来的2倍, 4倍, 8倍…，因此在resize时(Length - 1)这部分相当于在高位新增一个或多个1bit，我们以扩大到原来的两倍为例说明：</p>
<p><img src="rehash1.png" alt="rehash1"></p>
<p>(a)中n为16，(b)中n扩大到两倍为32，相当于(n - 1)这部分的高位多了一个1, 然后和原hash码作与操作，这样元素在数组中映射的位置要么不变，要不向后移动16个位置：</p>
<p><img src="rehash2.png" alt="rehash2"></p>
<p>因此，我们在扩充HashMap的时候，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p>
<p><img src="rehash3.png" alt="rehash3"></p>
<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中resize的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。</p>
<h3 id="HashMap死锁形成原理"><a href="#HashMap死锁形成原理" class="headerlink" title="HashMap死锁形成原理"></a>HashMap死锁形成原理</h3><p>HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用线程安全的ConcurrentHashMap。</p>
<p>要理解HashMap死锁形成的原理，我们要对HashMap的resize里的transfer过程有所了解，transfer过程是将旧数组中的元素复制到新数组中，在Java 8之前，复制过程会导致链表倒置，这也是形成死锁的重要原因（Java 8中已经不会倒置），transfer的基本过程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 新建节点e指向当前节点，新建节点next指向e.next</span><br><span class="line">2. 将e.next指向新数组中指定位置newTable[i]</span><br><span class="line">3. newTable[i] &#x3D; e</span><br><span class="line">4. e &#x3D; next</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">现在有链表1-&gt;2-&gt;3，要将它复制到新数组的newTable[i]位置</span><br><span class="line">1. Node e &#x3D; 1, next &#x3D; e.next;</span><br><span class="line">2. e.next &#x3D; newTable[i];</span><br><span class="line">3. newTable[i] &#x3D; e;</span><br><span class="line">4. e &#x3D; next, next &#x3D; e.next;</span><br><span class="line">执行完后会得到这样的结果：</span><br><span class="line">newTable[i]&#x3D;3-&gt;2-&gt;1</span><br></pre></td></tr></table></figure>

<p>死锁会在这种情况产生：两个线程同时往HashMap里放Entry，同时HashMap正好需要扩容，如果一个线程已经完成了transfer过程，而另一个线程不知道，并且又要进行transfer的时候，死锁就会形成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">现在Thread1已将完成了transfer，newTable[i]&#x3D;3-&gt;2-&gt;1</span><br><span class="line">在Thread2中:</span><br><span class="line">Node e &#x3D; 1, next &#x3D; e.next;</span><br><span class="line">e.next &#x3D; newTable[i]    : 1 -&gt; newTable[i]&#x3D;3</span><br><span class="line">newTable[i] &#x3D; e         : newTable[i] &#x3D; 1-&gt;3-&gt;2-&gt;1  &#x2F;&#x2F;这时候链表换已经形成了</span><br></pre></td></tr></table></figure>

<p>在形成链表换以后再对HashMap进行Get操作时，就会形成死循环。</p>
<p>在Java 8中对这里进行了优化，链表复制到新数组时并不会倒置，不会因为多个线程put导致死循环，但是还有很多弊端，比如数据丢失等，因此多线程情况下还是建议使用ConcurrentHashMap。</p>
<h3 id="HashMap和Hashtable有什么区别"><a href="#HashMap和Hashtable有什么区别" class="headerlink" title="HashMap和Hashtable有什么区别"></a>HashMap和Hashtable有什么区别</h3><p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：</p>
<p><img src="hashmap%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="hashmap继承关系"></p>
<p>Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</li>
<li>负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</li>
<li>HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</li>
<li>JDK1.8引入红黑树大程度优化了HashMap的性能。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap底层实现原理</title>
    <url>/2018/04/15/Java-ConcurrentHashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>在并发编程中使用HashMap可能导致程序死循环。而使用线程安全的HashTable效率又非常低下，基于以上两个原因，便有了ConcurrentHashMap的登场机会。</p>
<a id="more"></a>

<hr>
<h2 id="使用ConcurrentHashMap的原因"><a href="#使用ConcurrentHashMap的原因" class="headerlink" title="使用ConcurrentHashMap的原因"></a>使用ConcurrentHashMap的原因</h2><h3 id="1）线程不安全的HashMap"><a href="#1）线程不安全的HashMap" class="headerlink" title="1）线程不安全的HashMap"></a>1）线程不安全的HashMap</h3><p>多线程往HashMap中put数据会在HashMap中形成环，一旦形成环，在从HashMap中get数据时，由于Entry的next节点永远不为空，就会产生死循环获取Entry。JDK 8已经不会形成环，但是还是存在数据丢失的风险，所以在多线程环境下不建议使用HashMap</p>
<h3 id="2）效率低下的HashTable"><a href="#2）效率低下的HashTable" class="headerlink" title="2）效率低下的HashTable"></a>2）效率低下的HashTable</h3><p>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或轮询状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p>
<h3 id="3）ConcurrentHashMap使用锁分段技术有效提高并发访问率"><a href="#3）ConcurrentHashMap使用锁分段技术有效提高并发访问率" class="headerlink" title="3）ConcurrentHashMap使用锁分段技术有效提高并发访问率"></a>3）ConcurrentHashMap使用锁分段技术有效提高并发访问率</h3><p>HashTable效率低下的原因是所有线程都竞争同一把锁。JDK 1.7中ConcurrentHashMap使用<strong>锁分段技术</strong>，将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一段数据时候，其他段数据也能被其他线程访问。JDK 1.8摒弃了Segment的概念，直接使用volatile Node数组+链表+红黑树的结构来实现，并发控制使用Synchronized和CAS来操作，看起来就像优化过且线程安全的HashMap。</p>
<p>下面的内容基于JDK1.8中对ConcurrentHashMap的实现。</p>
<h2 id="ConcurrentHashMap使用的数据结构"><a href="#ConcurrentHashMap使用的数据结构" class="headerlink" title="ConcurrentHashMap使用的数据结构"></a>ConcurrentHashMap使用的数据结构</h2><p>ConcurrentHashMap中使用一个volatile Node类型的数组来存储所有数据，数组定义源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The array of bins. Lazily initialized upon first insertion.</span></span><br><span class="line"><span class="comment">     * Size is always a power of two. Accessed directly by iterators.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>

<p>table数组在第一次插入数据时才会被初始化，数组的容量总是2的幂，这是因为在计算node的插入位置时，要用以key值计算出的hash码和数组长度-1进行与操作，如果数组长度不是2的幂，长度-1就会出现0位i，详细内容可以参考：<a href="https://xinxingastro.github.io/2018/05/11/Java/HashMap底层实现原理/">HashMap底层实现原理</a>。</p>
<p>Node类型源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Key-value entry.  This class is never exported out as a</span></span><br><span class="line"><span class="comment">     * user-mutable Map.Entry (i.e., one supporting setValue; see</span></span><br><span class="line"><span class="comment">     * MapEntry below), but can be used for read-only traversals used</span></span><br><span class="line"><span class="comment">     * in bulk tasks.  Subclasses of Node with a negative hash field</span></span><br><span class="line"><span class="comment">     * are special, and contain null keys and values (but are never</span></span><br><span class="line"><span class="comment">     * exported).  Otherwise, keys and vals are never null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> key.hashCode() ^ val.hashCode(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + val; &#125;</span><br><span class="line">    <span class="comment">// 这里setValue时会直接抛出异常，所以不允许更新值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Object k, v, u; Map.Entry&lt;?,?&gt; e;</span><br><span class="line">        <span class="keyword">return</span> ((o <span class="keyword">instanceof</span> Map.Entry) &amp;&amp;</span><br><span class="line">                (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (v = e.getValue()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (k == key || k.equals(key)) &amp;&amp;</span><br><span class="line">                (v == (u = val) || v.equals(u)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Virtualized support for map.get(); overridden in subclasses.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                K ek;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果出现hash冲突，系统就在冲突位置的形成一个链表，这个链表在JDK中叫做Bin，由以上源码可知，Node就是一个单链表的节点，这种节点只允许对数据进行查询，不允许修改。</p>
<p>如果一个Bin中的节点个数超过8，系统就会自动将这个bin转换成红黑树。TREEIFY-THRESHOLD定义了转换的阀值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment">     * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment">     * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment">     * than 2, and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment">     * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment">     * shrinkage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>TreeNode就是红黑树中的节点类型，TreeNode源码如下：</p>
<p>由于TreeNode是继承自Node类的所以Node中所有属性TreeNode中都有。在使用时可以把一个TreeNode就当作一个Node使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Nodes for use in TreeBins</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next,</span><br><span class="line">             TreeNode&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findTreeNode(h, k, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns the TreeNode (or null if not found) for the given key</span></span><br><span class="line"><span class="comment">         * starting at given root.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">findTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">do</span>  &#123;</span><br><span class="line">                <span class="keyword">int</span> ph, dir; K pk; TreeNode&lt;K,V&gt; q;</span><br><span class="line">                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (pk != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                          (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                    p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.findTreeNode(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = pl;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TreeBin是用来封装红黑树的容器，TreeBin的源码如下，在TreeBin中维护一个读写锁，一个线程如果想修改红黑树中的值必须拿到TreeBin的读写锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * TreeNodes used at the heads of bins. TreeBins do not hold user</span></span><br><span class="line"><span class="comment">     * keys or values, but instead point to list of TreeNodes and</span></span><br><span class="line"><span class="comment">     * their root. They also maintain a parasitic read-write lock</span></span><br><span class="line"><span class="comment">     * forcing writers (who hold bin lock) to wait for readers (who do</span></span><br><span class="line"><span class="comment">     * not) to complete before tree restructuring operations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root;</span><br><span class="line">    <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">    <span class="comment">// values for lockState</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Tie-breaking utility for ordering insertions when equal</span></span><br><span class="line"><span class="comment">         * hashCodes and non-comparable. We don't require a total</span></span><br><span class="line"><span class="comment">         * order, just a consistent insertion rule to maintain</span></span><br><span class="line"><span class="comment">         * equivalence across rebalancings. Tie-breaking further than</span></span><br><span class="line"><span class="comment">         * necessary simplifies testing a bit.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> ||</span><br><span class="line">            (d = a.getClass().getName().</span><br><span class="line">             compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">            d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">                 -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates bin with initial set of nodes headed by b.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">        <span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.first = b;</span><br><span class="line">        TreeNode&lt;K,V&gt; r = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">            next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">            x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">                x.parent = <span class="keyword">null</span>;</span><br><span class="line">                x.red = <span class="keyword">false</span>;</span><br><span class="line">                r = x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                K k = x.key;</span><br><span class="line">                <span class="keyword">int</span> h = x.hash;</span><br><span class="line">                Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = r;;) &#123;</span><br><span class="line">                    <span class="keyword">int</span> dir, ph;</span><br><span class="line">                    K pk = p.key;</span><br><span class="line">                    <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                        dir = -<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                        dir = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                              (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                             (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                        dir = tieBreakOrder(k, pk);</span><br><span class="line">                    TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                    <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        x.parent = xp;</span><br><span class="line">                        <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                            xp.left = x;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            xp.right = x;</span><br><span class="line">                        r = balanceInsertion(r, x);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.root = r;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="PUT操作"><a href="#PUT操作" class="headerlink" title="PUT操作"></a>PUT操作</h2><p>ConcurrentHashMap的初始化并不在构造函数中实现，而是在第一插入数据时，在put方法中实现。</p>
<p>put方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh; <span class="comment">//f表示插入位置节点，fh表示插入位置节点的hash值</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>put方法大致分以下几步：</p>
<p>1）如果key和value不为null，则计算hash值。和HashMap相同的是，ConcurrentHashMap也会对key的hashcode高16位和低16位进行异或，不同的是，ConcurrentHashMap中还会将异或出的结果跟一个HASH_BITS变量相与。HASH_BITS定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br></pre></td></tr></table></figure>

<p>HASH_BITS指定来可以用来计算hash的位数，默认值为31位。</p>
<p>2）如果发现table还没初始化，则调用iniTable()方法对table进行初始化。</p>
<p>3）计算插入位置使用<code>i = (n - 1) &amp; hash)</code>，如果插入位置为空，则新建Node利用CAS操作插入节点，然后返回。</p>
<p>4）如果插入位置节点的hash值等于-1，则需要扩容，然后进行多线程并发扩容操作。</p>
<p>5）否则，说明存在hash冲突。首先锁定插入位置节点，如果插入位置节点的hash值&gt;=0，则说明插入点是链表结构，新建Node插入。如果插入位置节点是TreeNode，则新建TreeNode插入。</p>
<p>在插入Node节点时使用一个for循环进行判断，如果当前节点的key值和插入节点相同，直接将该节点的value修改为插入节点的value（onlyIfAbsent属性可以设置只有插入位置空时才插入）。如果key值不相同则遍历链表继续判断。</p>
<p>6）检查当前Bin的容量，如果超过了阀值，则要将链表转化成红黑树。</p>
<p>从put流程中可以发现，JDK1.8处理冲突时使用的是乐观锁，当有冲突时才进行并发处理。</p>
<h2 id="GET操作"><a href="#GET操作" class="headerlink" title="GET操作"></a>GET操作</h2><p>get方法的源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的源码可以看到get的操作流程为：</p>
<p>计算key的hash值，定位到table索引位置，如果首节点符合就返回，如果不符合就循环链表，匹配就返回，不匹配就返回null。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JDK1.8版本的ConcurrentHashMap的数据结构已经接近HashMap，相对而言，ConcurrentHashMap只是增加了同步的操作来控制并发，从JDK1.7版本的ReentrantLock+Segment+HashEntry，到JDK1.8版本中synchronized+CAS+HashEntry+红黑树，ConcurrentHashMap发生了如下变化：</p>
<ol>
<li>JDK1.8中将锁的粒度进一步降低，更好的支持高并发场景。JDK1.7中锁住的是Segment对象，一个Segment中包含很多HashEntry。而JDK1.8中加锁的对象是插入点位置的节点。</li>
<li>JDK1.8中使用红黑树代替链表，提高了查找速度。</li>
<li>由于锁粒度的降低，JDK1.8中使用Synchronized代替ReentrantLock，增加了灵活度，降低了系统开销。</li>
</ol>
<blockquote>
<p> 参考：<a href="https://juejin.im/post/5aba1030f265da23961269c6">ConcurrentHashMap底层原理</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java中field和property的区别</title>
    <url>/2018/07/21/Java-Java%E4%B8%ADfield%E5%92%8Cproperty%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>field和property中文的翻译差不多，实际上是两个不同的概念。</p>
<a id="more"></a>

<hr>
<blockquote>
<p>field: A data member of a class. Unless specified otherwise, a field is not static.</p>
<p>property: Characteristics of an object that users can set, such as the color of a window.</p>
<p>摘自：<a href="https://docs.oracle.com/javase/tutorial/information/glossary.html#P">Glossary of Terms</a></p>
</blockquote>
<p>我的理解是，field指那些在类的内部，不能被外界看到的私有成员变量。property指的是在对象内部可以被用户设置或者读取的属性，比如那些有getter/setter方法的属性。</p>
<p><img src="fieldvsproperty.png" alt="fieldvsproperty-2232158"></p>
<p>如上图所示我们新建一个Person类，在没有设置getter/setter方法时，name和age都是field，然后我给name添加getter/setter方法后，getName(), setName()和name就变成了一个property。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java中获取随机数的方法</title>
    <url>/2018/04/28/Java-Java%E4%B8%AD%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>最常用的有两种方法获取随机数。</p>
<a id="more"></a>

<h2 id="使用Math-random-方法"><a href="#使用Math-random-方法" class="headerlink" title="使用Math.random()方法"></a>使用Math.random()方法</h2><p><code>Math.random()</code>函数获取一个在<code>[0.0, 1.0)</code>之间的double类型的随机数。</p>
<p>例：获取在<code>[0.0, 10.0)</code>之间int类型的随机数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> r = Math.random();</span><br><span class="line"><span class="keyword">int</span> ans = (<span class="keyword">int</span>)(r*<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="使用Random类获取随机数"><a href="#使用Random类获取随机数" class="headerlink" title="使用Random类获取随机数"></a>使用Random类获取随机数</h2><p>Random类中有很多获得随机数的方法，如：</p>
<ul>
<li><code>int nextInt()</code>方法返回在int类型的$[-2^{31}\sim2^{31}-1]$的随机数。</li>
<li><code>int nextInt(int bound)</code>方法返回int类型的[0, bound)之间的随机数。</li>
</ul>
<p>例：获取在<code>[0.0, 10.0)</code>之间int类型的随机数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">int</span> ans = r.nextInt(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="使用UUID类获取UUID"><a href="#使用UUID类获取UUID" class="headerlink" title="使用UUID类获取UUID"></a>使用UUID类获取UUID</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UUID uuid = UUID.randomUUID();</span><br></pre></td></tr></table></figure>

<p>UUID得到的是一个随机字符串。</p>
<blockquote>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中遍历Map的方法</title>
    <url>/2018/05/03/Java-Java%E4%B8%AD%E9%81%8D%E5%8E%86Map%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>如HashMap, TreeMap, ConcurrentHashMap等。</p>
<a id="more"></a>

<hr>
<h3 id="方法1-使用Iterator遍历"><a href="#方法1-使用Iterator遍历" class="headerlink" title="方法1: 使用Iterator遍历"></a>方法1: 使用Iterator遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (entries.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;Integer, Integer&gt; entry = entries.next();</span><br><span class="line">    System.out.println(<span class="string">"Key = "</span> + entry.getKey() + <span class="string">", Value = "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Iterator迭代map的一个优势是：在迭代过程中可以使用iterator.remover()正常删除map中的entry, 如果在for-each循环中删除entry，系统会报<code>unpredictable resultes</code>异常。</p>
<h3 id="方法2-for-each遍历map-entrySet"><a href="#方法2-for-each遍历map-entrySet" class="headerlink" title="方法2: for-each遍历map.entrySet()"></a>方法2: for-each遍历map.entrySet()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Key = "</span> + entry.getKey() + <span class="string">", Value = "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法3-for-each遍历map-keySet-map-values"><a href="#方法3-for-each遍历map-keySet-map-values" class="headerlink" title="方法3: for-each遍历map.keySet(), map.values"></a>方法3: for-each遍历map.keySet(), map.values</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Key = "</span> + key);</span><br><span class="line">    Integer value = map.get(key); <span class="comment">//效率低</span></span><br><span class="line">    System.out.println(<span class="string">"Value = "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Value = "</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的反射机制</title>
    <url>/2018/07/21/Java-Java%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>Java反射机制的知识点总结。</p>
<a id="more"></a>

<hr>
<h3 id="反射的概念"><a href="#反射的概念" class="headerlink" title="反射的概念"></a>反射的概念</h3><p>在Java运行时环境中，对于任意一个类我们可以利用反射机制知道这个类有哪些属性和方法，对于任意一个对象我们可以利用反射调用它的任意一个方法，这种动态获取类的信息以及动态调用对象的方法的功能来自于Java的反射(Reflection)机制。</p>
<p>Java反射机制主要提供了一下功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类。</li>
<li>在运行时构造任意一个类的对象。</li>
<li>在运行时判断任意一个类所具有的成员变量和方法。</li>
<li>在运行时调用任意一个对象的方法。</li>
</ul>
<blockquote>
<p>什么是动态语言？</p>
<p>动态语言：就是程序运行时，允许改变程序结构或变量类型的语言。</p>
<p>最常见的动态语言有：JavaScript、Python、Ruby等。</p>
</blockquote>
<p>虽然Java不是动态语言，但是Java的反射机制，让Java也具有了一定的动态性。</p>
<h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p>在Java程序运行期间，Java运行时系统始终为所有对象维护一个叫作<strong>运行时</strong>的类型标识，这个信息跟踪着每个对象所属的类，JVM利用运行时里的类型信息选择相应的方法执行。我们可以通过专门的Java类访问这些运行时信息，保存这些信息的类就是<strong>Class</strong>类。<strong>java.lang.Class</strong>是一个特殊的类，它用于封装被装入到JVM中的类或接口的信息。</p>
<p>Class类没有构造方法，我们不能显示的构造一个Class对象，Class对象是在一个类或接口被加载时，JVM通过类加载器中的defineClass方法自动构造的，我们可以通过这个Class对象访问这个类的信息。JVM通过这个Class对象来构造对应类的普通对象。</p>
<h4 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h4><h5 id="通过Object类的getClass-方法获取Class对象"><a href="#通过Object类的getClass-方法获取Class对象" class="headerlink" title="通过Object类的getClass()方法获取Class对象"></a>通过Object类的getClass()方法获取Class对象</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">Date date2 = <span class="keyword">new</span> Date();</span><br><span class="line">Class c1 = date1.getClass();</span><br><span class="line">Class c2 = date2.getClass();</span><br><span class="line">System.out.println(c1.getName()); <span class="comment">// java.util.Date</span></span><br><span class="line">System.out.println(c1 == c2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>当一个对象被其父类的引用或其实现的接口的应用指向时，getClass()方法返回的是对象实际类型的Class对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">System.out.println(list.getClass().getName()); <span class="comment">// java.util.ArrayList</span></span><br></pre></td></tr></table></figure>

<p>有时候可以用这个方法了解一个对象的实际类型，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set set = <span class="keyword">new</span> HashSet();</span><br><span class="line">Iterator it = set.iterator();</span><br><span class="line">System.out.println(it.getClass().getName()); <span class="comment">// java.util.HashMap$KeyIterator</span></span><br></pre></td></tr></table></figure>

<p>从代码可以看出，HashSet的iterator方法返回的是实现了Iterator接口的HashMap内部类（KeyIterator）对象。 因为抽象类和接口不可能实例化对象，因此不能通过Object的getClass方法获得与抽象类和接口关联的Class对象。</p>
<h5 id="使用-class方法获取Class对象"><a href="#使用-class方法获取Class对象" class="headerlink" title="使用.class方法获取Class对象"></a>使用.class方法获取Class对象</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">System.out.println(<span class="class"><span class="keyword">class</span>.<span class="title">getName</span>())</span>; <span class="comment">// java.lang.String</span></span><br></pre></td></tr></table></figure>

<p>这个方法可以直接获得与指定类关联的Class对象，而并不需要有该类的对象存在。</p>
<h5 id="使用Class-forName-String-className-方法获取Class对象"><a href="#使用Class-forName-String-className-方法获取Class对象" class="headerlink" title="使用Class.forName(String className)方法获取Class对象"></a>使用Class.forName(String className)方法获取Class对象</h5><p>该方法可以根据字符串参数所指定的类名获取与该类关联的Class对象。如果该类还没有被装入，该方法会将该类装入JVM。当该方法无法获取需要装入的类时（例如，在当前类路径中不存在这个类），会抛出ClassNotFoundException异常。</p>
<p>注意：className需要是类的全限定名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"com.xinxing.Test"</span>);</span><br></pre></td></tr></table></figure>

<p>上面语句执行后，JVM首先会将Test类装入，然后返回对应的Class对象。该方法通常用于在程序运行时根据类名动态的载入类，并获取对应的Class对象。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java抽象类和接口的区别</title>
    <url>/2018/03/20/Java-Java%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>Java中抽象类和接口的区别总结</p>
<a id="more"></a>

<p><strong>一个类只能<code>extends</code>一个抽象类，但可以<code>implements</code>多个接口。</strong></p>
<h4 id="抽象类Abstract-Class："><a href="#抽象类Abstract-Class：" class="headerlink" title="抽象类Abstract Class："></a>抽象类Abstract Class：</h4><ol>
<li>只要用<code>abstract</code>关键字声明的类就叫抽象类，抽象类可以和普通类一模一样，可以不包含抽象方法，但是如果一个类包含了抽象方法，一定要声明成抽象类。</li>
<li>抽象类不可以被实例化，即抽象类不可以<code>new</code>对象，如果用一个抽象类<code>new</code>对象，编译器会报错：<code>Class is abstract; cannot be instantiated</code>。但是抽象类中可以有构造函数，如果抽象类中包含<code>main</code>方法的话是可以被调用的。</li>
<li>抽象方法中不能包含方法体。</li>
<li>抽象类可以包含非<code>final</code>类型的变量。</li>
<li>抽象类的成员函数可以是<code>private</code>、<code>protected</code>或者<code>public</code>。</li>
<li>抽象类子类，如果不是抽象类，就必须实现抽象父类的所有抽象方法。</li>
<li>抽象类和类一样只能单继承<code>extends</code>，但可以多实现<code>implements</code>。</li>
<li>抽象类中可以有静态代码块。</li>
</ol>
<h4 id="接口Interface："><a href="#接口Interface：" class="headerlink" title="接口Interface："></a>接口Interface：</h4><ol>
<li>接口不能被实例化，即不能<code>new</code>对象。</li>
<li>接口没有构造方法，而且接口中所有方法必须都是抽象方法。</li>
<li>接口中的变量默认都是<code>public static final</code>类型的，即默认都是常量，不能是其他类型。</li>
<li>接口中的方法默认的是<code>public abstract</code>类型的，即都是抽象方法，不能是其他类型。</li>
<li>接口支持多继承，即<code>extends</code>关键字后可以跟多个接口（只能是接口不能是类）。</li>
<li>接口中不能有静态代码块。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>抽象类</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL知识点总结</title>
    <url>/2018/07/12/Java-MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>MySQL数据库知识点总结。</p>
<p>查考：高性能MySQL（第三版）。</p>
<a id="more"></a>

<hr>
<h2 id="MySQL架构与历史"><a href="#MySQL架构与历史" class="headerlink" title="MySQL架构与历史"></a>MySQL架构与历史</h2><h3 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h3><p>MySQL的逻辑架构图如下所示：</p>
<p><img src="mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="mysql逻辑架构图"></p>
<p>每个客户端连接都会在服务器中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或者CPU中运行。服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销毁线程。</p>
<blockquote>
<p>QPS (Queries Per Second) : 单个进程美妙请求服务器的成功次数。</p>
<p>TPS (Transaction Per Second) ： 美妙处理的事务数。</p>
<p>PV (Page View) : 页面被浏览的次数。</p>
</blockquote>
<h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>在处理并发读或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题，这两种类型的锁通常被称为<strong>共享锁（shared lock）</strong>和<strong>排他锁（exclusive lock）</strong>也叫<strong>读锁（read lock）</strong>和<strong>写锁（write lock）</strong>。</p>
<p>读锁是共享的，或者说是相互不 阻塞的。多个客户在同一时刻可以同时读取同一个资源，而互不干扰。写锁则是排他的， 也就是说一个写锁会阻塞其他的写锁和读锁，这是出于安全策略的考虑，只有这样，才 能确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写人的同 一资掘。 </p>
<h4 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h4><p><strong>锁策略</strong>：就是在<strong>锁的开销</strong>和<strong>数据的安全性</strong>之间寻求平衡，这种平衡当然也会影响 到性能。大多数商业数据库系统没有提供更多的选择，一般都是在表上施加行级锁( row­ level lock)，并以各种复杂的方式来实现，以便在锁比较多的情况下尽可能地提供更好 的性能。 </p>
<p>两种最重要的锁策略：</p>
<ol>
<li>表锁（table lock）：表锁是 MySQL 中最基本的锁策略，井且是开销最小的策略。表锁会锁定整张表。一个用户在对表进行写操作(插入、删除、更新等) 前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得读锁，读锁之间是不相互阻塞的。 </li>
<li>行级锁（row lock）：行级锁可以最大程度地支持井发处理(同时也带来了最大的锁开销)。在 InnoDB 和 XtraDB，以及其他一些存储引擎中实现了行级锁。行级锁只在存储引擎层实  现，而 MySQL 服务器层没有实现。服务器层 完全不了解存储引擎中的锁实现。</li>
</ol>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务就是一组原子性的 SQL 查询，或者说一个独立的工作单元。事务内的语句，要么全部执行成功，要么全部执行失败。事务是由下层的存储引擎实现的。 </p>
<h4 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h4><p>原子性 (Atomicity)、一致性(Consistency)、隔离性(Isolation)和持久性(Durability)。一个运行良好的事务处理系统，必须具备这些标准特征。 </p>
<ul>
<li><strong>原子性 (Atomicity)</strong>：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全 部提交成功，要么全部失败回攘，对于一个事务来说，不可能只执行其中的一部分 操作，这就是事务的原子性。 </li>
<li><strong>一致性(Consistency)</strong>：数据库总是从一个一致性的状态转换到另外一个一致性的状态。</li>
<li><strong>隔离性(Isolation)</strong>：一个事务所做的修改在最终提交以前，对其他事务是不可见的。</li>
<li><strong>持久性(Durability)</strong>：一且事务提交，则其所做的修改就会永久保存到数据库中。</li>
</ul>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。较低级别 的隔离通常可以执行更高的井发，系统的开销也更低。 </p>
<ul>
<li><strong>READ UNCOMMITTED (未提交读)</strong>：在READ  UNCOMMITTED级别，事务中的修改，即使没有提交，对其他事务也都是可见 的。事务可以读取未提交的数据，这也被称为<strong>脏读( Dirty Read)</strong>。这个级别会导致很多问题，从性能上来说， READ UNCOMMITTED 不会比其他的级别好太多，但却缺乏 其他级别的很多好处，除非真的有非常必要的理由，在实际应用中一般很少使用。 </li>
<li><strong>READ COMMITTED (提交读)</strong>：大多数数据库系统的默认隔离级别都是 READ COMMITTED (但 MySQL 不是)。 READ COMMITTED 满足前面提到的隔离性的简单定义 : 一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做<strong>不可重复读( nonrepeatable read)</strong>，因为两次执行同样的查询，可能会得到不一样的结果。 </li>
<li><strong>REPEATABLE READ (可重复读)</strong>：<strong>可重复读是 MySQL 的默认事务隔离级别</strong>。REPEATABLE READ 解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读 (Phantom Read)的问题。所谓<strong>幻读</strong>，指的是当某个事务在读取某个范围内的记录时， 另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生<strong>幻行( Phantom Row)</strong>。 <strong>InnoDB 和 XtraDB 存储引擎通过多版本井发控制( MVCC, Multiversion Concurrency Control)解决了幻读的问题</strong>。 </li>
<li>SERIALIZABLE (可串行化)：SERIALIZABLE 是最高的隔离级别。它通过<strong>强制事务串行执行</strong>，避免了前面说的幻读的问题。简单来说， SERIALIZABLE 会在读取的每一行数据上都加锁，所以可能导致 大量的超时和锁争用的问题。实际应用中也很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有井发的情况下，才考虑采用该级别。 </li>
</ul>
<p><img src="%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.png" alt="隔离级别"></p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁是指两个或者多个事务在同一资源上相互占用，井请求锁定对方占用的资源，从而导致恶性循环的现象。复杂的系统，比如 InnoDB 存储引擎，越能检测到死锁的循环依赖，并立即返回一个错误。InnoDB 目前处理死锁的方站是，将持有最少行级排他锁的事务进行回攘(这是相对比较简单的死锁回滚算法)。 </p>
<h4 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h4><p>事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。</p>
<p>事务日志采用的是追加的方式，因此写日志的操作是磁盘 上一小块区域内的顺序 I/O，而不像随机 I/O 需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的，我们通常称之为<strong>预写式日志( Write-Ahead Logging)</strong>，修改数据需要写两次磁盘。 </p>
<h4 id="MySQL中的事务"><a href="#MySQL中的事务" class="headerlink" title="MySQL中的事务"></a>MySQL中的事务</h4><p>MySQL 提供了两种事务型的存储引擎: InnoDB 和 NDB Cluster。另外还有一些第三方 存储引擎也支持事务，比较知名的包括 XtraDB 和 PBXT 。</p>
<h5 id="自动提交-AUTOCOMMIT"><a href="#自动提交-AUTOCOMMIT" class="headerlink" title="自动提交( AUTOCOMMIT)"></a>自动提交( AUTOCOMMIT)</h5><p>MySQL 默认采用自动提交( AUTOCOMMIT)模式。既如果不是显式地开始一 个事务，则每个查询都被当作一个事务执行提交操作。在当前连接中，可以通过设置 AUTOCOMMIT 变量来启用或者禁用自动提交模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#39;AUTOCOMMIT&#39;;</span><br><span class="line">mysql&gt; SET AUTOCOMMIT &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>1或者 ON表示启用，0或者 OFF 表示禁用。当 AUTOCOMMIT=0时，所有的查询都是在一个 事务中，直到显式地执行 COMMIT提交或者 ROLLBACK 回滚，该事务结束，同时又开始了另一个新事物。修改 AUTOCOMMIT对非事务型的表，比如 MyISAM 或者内存表，不会有任何影响。 </p>
<p>MySQL 可以通过执行 SET TRANSACTION ISOLATION LEVEL 命令来设置隔离级别。新的隔离级别会在下一个事务开始的时候生效。可以在配置文件中设置整个数据库的隔离级别，也可以只改变当前会话的隔离级别: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br></pre></td></tr></table></figure>

<h5 id="在事务中混合使用存储引擎"><a href="#在事务中混合使用存储引擎" class="headerlink" title="在事务中混合使用存储引擎"></a>在事务中混合使用存储引擎</h5><p>MySQL 服务器层不管理事务，<strong>事务是由下层的存储引擎实现的</strong>。所以在同一个事务中，使用多种存储引擎是不可靠的。 </p>
<p>如果在事务中混合使用了事务型和非事务型的表(例如 InnoDB 和 MyISAM 表)，在正常提交的情况下不会有什么问题。但是在事务需要回滚时，非事务型的表上的变更无法撤销，这会导致数据库处于不一致的状态，这种情况很难修复，事务的最终结果将无法确定。所以，为每张表选择合适的存储引擎非常重要。 </p>
<h5 id="隐式和显式锁定"><a href="#隐式和显式锁定" class="headerlink" title="隐式和显式锁定"></a>隐式和显式锁定</h5><p>InnoDB 采用的是<strong>两阶段锁定协议( two-phase locking protocol)</strong>。在事务执行过程中，随时都可以执行锁定，锁只有在执行 COMMIT或者 ROLLBACK的时候才会释放，并且所有的锁是在同一时刻被释放。前面描述的锁定都是<strong>隐式锁定</strong>， InnoDB 会根据隔离级别在需要的时候自动加锁。 </p>
<p>InnoDB也支持通过特定的语句进行<strong>显式锁定</strong> ：</p>
<ul>
<li>SELECT — LOCK IN SHARE MODE</li>
<li>SELECT … FOR UPDATE</li>
</ul>
<blockquote>
<p>MySQL 也支持 LOCK TABLES和 UNLOCK TABLES语句，这是在服务器层实现的，和存储引擎无关。LOCK TABLES 和事务之间相互影响的话，情况会变得非常复杂，在某些 MySQL 版本 中甚至会产生无怯预料的结果。因此，除了事务中禁用了 AUTOCOMMIT, 可以使用 LOCK TABLES 之外，其他任何时候都不要显式地执行 LOCK TABLES，不管 使用的是什么存储引擎。 </p>
</blockquote>
<h3 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h3><p>MySQL 的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考 虑，它们一般都同时实现了多版本井发控制(MVCC)。</p>
<p>可以认为 MVCC 是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。MVCC 是通过保存数据在某个时间点的快照来实现的。</p>
<h3 id="MySQL-的存储引擎"><a href="#MySQL-的存储引擎" class="headerlink" title="MySQL 的存储引擎"></a>MySQL 的存储引擎</h3><p>在文件系统中， MySQL将每个数据库 (也可以称之为schema) 保存为数据目录下的一个<strong>子目录</strong>。创建表时，MySQL会在数据库子目录下创建一个<strong>和表同名的.frm文件</strong>保存表的定义。因为 MySQL 使用<strong>文件系统的目录</strong>和<strong>文件来</strong>保存数据库和表的定义，大小写敏感性和具体的平台密切相关。在 Windows 中，大小写是不敏感的，而在类 Unix 中则是敏感的。不同的存储引擎保存数据和索引的方式是不同的，但表的定义则是在 MySQL 服务层统一处理的。 </p>
<h4 id="lnnoDB-存储引擎"><a href="#lnnoDB-存储引擎" class="headerlink" title="lnnoDB 存储引擎"></a>lnnoDB 存储引擎</h4><h4 id="MylSAM-存储引擎"><a href="#MylSAM-存储引擎" class="headerlink" title="MylSAM 存储引擎"></a>MylSAM 存储引擎</h4><h4 id="MySQL-内建的其他存储引擎"><a href="#MySQL-内建的其他存储引擎" class="headerlink" title="MySQL 内建的其他存储引擎"></a>MySQL 内建的其他存储引擎</h4><h5 id="Archive-引擎"><a href="#Archive-引擎" class="headerlink" title="Archive 引擎"></a>Archive 引擎</h5><h5 id="Blackhole-引擎"><a href="#Blackhole-引擎" class="headerlink" title="Blackhole 引擎"></a>Blackhole 引擎</h5><h5 id="CSV-引擎"><a href="#CSV-引擎" class="headerlink" title="CSV 引擎"></a>CSV 引擎</h5><h5 id="Federated-引擎"><a href="#Federated-引擎" class="headerlink" title="Federated 引擎"></a>Federated 引擎</h5><h5 id="Memory-引擎"><a href="#Memory-引擎" class="headerlink" title="Memory 引擎"></a>Memory 引擎</h5><h5 id="Merge-引擎"><a href="#Merge-引擎" class="headerlink" title="Merge 引擎"></a>Merge 引擎</h5><h5 id="NOB-集群引擎"><a href="#NOB-集群引擎" class="headerlink" title="NOB 集群引擎"></a>NOB 集群引擎</h5><h4 id="第三方存储引擎"><a href="#第三方存储引擎" class="headerlink" title="第三方存储引擎"></a>第三方存储引擎</h4><h5 id="OLTP-类引擎"><a href="#OLTP-类引擎" class="headerlink" title="OLTP 类引擎"></a>OLTP 类引擎</h5><h5 id="面向列的存储引擎"><a href="#面向列的存储引擎" class="headerlink" title="面向列的存储引擎"></a>面向列的存储引擎</h5><h5 id="社区存储引擎"><a href="#社区存储引擎" class="headerlink" title="社区存储引擎"></a>社区存储引擎</h5><h4 id="选择合适的引擎"><a href="#选择合适的引擎" class="headerlink" title="选择合适的引擎"></a>选择合适的引擎</h4><h4 id="转换表的引擎"><a href="#转换表的引擎" class="headerlink" title="转换表的引擎"></a>转换表的引擎</h4><h2 id="创建高性能索引"><a href="#创建高性能索引" class="headerlink" title="创建高性能索引"></a>创建高性能索引</h2><p>索引是对数据库表中一个或多个列的值进行排序的数据结构，以协助快速查询、更新数据库表中数据。索引是在存储引擎层而不是服务器层实现的。</p>
<h3 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h3><h4 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h4><h5 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B-Tree 索引"></a>B-Tree 索引</h5><p>B-Tree（平衡多路查找树）通常意味着所有的值都是按顺序存储的，井且每一个叶子页到根的距离相同。下图是InnoDB索引抽象工作图：</p>
<p><img src="BTree%E7%B4%A2%E5%BC%95.png" alt="BTree索引"></p>
<p>B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要 的数据，取而代之的是从索引的根节点(图示并未圃出)开始进行搜索。根节点的槽中 存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和 要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值 的上限和下限。最终存储引擎要么是找到对应的值，要么该记录不存在。 </p>
<p>叶子节点比较特殊，它们的指针指向的是被索引的数据，而不是其他的节点页。</p>
<p>B-Tree 对索引列是顺序组织存储的，所以很适合查找范围数据。例如，在一个基于文本 域的索引树上，按字母顺序传递连续的值进行查找是非常合适的，所以像“找出所有以 I到 K开头的名字”这样的查找效率会非常高。 </p>
<p>下面语句会创建一个表然后创建这个表的B-Tree索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE People (</span><br><span class="line">    last_name  varchar(50)    not null,</span><br><span class="line">    first_name varchar(50)    not null,</span><br><span class="line">    dob        date           not null,</span><br><span class="line">    gender     enum(&#39;m&#39;, &#39;f&#39;) not null,</span><br><span class="line">    key(last_name, first_name, dob)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>B-Tree索引对如下类型的查询有效：</p>
<ul>
<li>全值匹配</li>
<li>匹配最左前缀</li>
<li>匹配列前缀</li>
<li>匹配范围值</li>
<li>精确匹配某一列并范围匹配另外一列</li>
<li>只访问索引的查询</li>
</ul>
<p>B-Tree索引的限制：</p>
<ul>
<li>如果不是按照索引的最左列开始查找，则无法使用索引。也无法查找姓氏以某个字母结尾的人。</li>
<li>不能跳过索引中的列。</li>
<li>如果查询中有某个列的范围查询，则其右边所有列都无怯使用索引优化查找。</li>
</ul>
<p><strong>索引列的顺序特别重要！</strong>，这些限制都和索引列的顺序有关。在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。</p>
<h5 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h5><p>哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码( hash code)，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希 码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p>
<p>在 MySQL 中，只有 Memory 引擎显式支持哈希索引。这也是 Memory 引擎表的默认索引类型， Memory 引擎同时也支持 B-Tree 索引。值得一提的是， Memory 引擎是支持非唯一哈希索引的，这在数据库世界里面是比较与众不同的。如果多个列的哈希值相同， 索引会以链表的方式存放多个记录指针到同一个哈希条目中。 </p>
<p>因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引查找 的速度非常快。然而，哈希索引也有它的限制：</p>
<ul>
<li>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避 免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响井不明显。 </li>
<li>哈希索引数据井不是按照索引值顺序存储的，所以也就无法用于排序。 </li>
<li>哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例如，在数据列(A,B)上建立哈希索引，如果查询只有数据列 A, 则无法使用该索引。 </li>
<li>哈希索引只支持等值比较查询，包括=、 IN()、&lt;=&gt; (注意。和〈=〉是不同的操作)。 也不支持任何范围查询，例如WHERE price &gt; 100. </li>
<li>访问哈希索引的数据非常快，除非有很多哈希冲突(不同的索引列值却有相同的哈 希值)。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。 </li>
<li>如果哈希冲突很多的话，一些索引维护操作的代价也会很高。例如，如果在某个选择性很低(哈希冲突很多)的列上建立哈希索引，那么当从表中删除一行时，存储引擎需要遍历对应哈希值的链表中的每一行，找到井删除对应行的引用，冲突越多，代价越大。 </li>
</ul>
<p>InnoDB 引擎有一个特殊的功能叫做“<strong>自适应哈希索引( adaptive hash index)”</strong>。当 InnoDB 注意到某些索引值被使用得非常频繁时，它会在内存中基于 B-Tree 索引之上再 创建一个哈希索引，这样就让 B-Tree 索引也具有哈希索引的一些优点，比如快速的哈希查找。这是一个完全自动的、内部的行为，用户无摇控制或者配置，不过如果有必要， 完全可以关闭该功能。 </p>
<h5 id="空间数据索引-R-Tree"><a href="#空间数据索引-R-Tree" class="headerlink" title="空间数据索引( R-Tree)"></a>空间数据索引( R-Tree)</h5><h5 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h5><h5 id="其他索引类别"><a href="#其他索引类别" class="headerlink" title="其他索引类别"></a>其他索引类别</h5><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><ul>
<li>大大加快数据的检索速度，这也是创建索引的最主要的原因；</li>
<li>加速表和表之间的连接；</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间；</li>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Spring MVC框架学习笔记</title>
    <url>/2018/08/06/Java-SpringMVC%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>Spring Web MVC是一个原生的构建在Servlet API上的Web框架，很早就被包含在Spring框架之中。Spring Web MVC最主要的两个作用是：1. 处理从客服端发来的请求，从请求中接收传入的参数。2. 将处理后的结果数据返回给页面。</p>
<a id="more"></a>

<hr>
<h2 id="Spring-MVC处理流程"><a href="#Spring-MVC处理流程" class="headerlink" title="Spring MVC处理流程"></a>Spring MVC处理流程</h2><p>Spring Web MVC框架处理请求的流程如下图所示：</p>
<p><img src="springmvc01.png" alt="springmvc01"></p>
<p>WebApplicationContext层级图如下所示：</p>
<p><img src="springmvc02.png" alt="springmvc02"></p>
<h2 id="Spring-MVC入门项目"><a href="#Spring-MVC入门项目" class="headerlink" title="Spring MVC入门项目"></a>Spring MVC入门项目</h2>]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Spring框架学习笔记</title>
    <url>/2018/07/18/Java-Spring%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>Spring框架的学习笔记。</p>
<a id="more"></a>

<hr>
<h2 id="IoC-Inversion-of-Control-控制反转"><a href="#IoC-Inversion-of-Control-控制反转" class="headerlink" title="IoC(Inversion of Control)控制反转"></a>IoC(Inversion of Control)控制反转</h2><h3 id="IoC的概念"><a href="#IoC的概念" class="headerlink" title="IoC的概念"></a>IoC的概念</h3><p>IoC(Inversion of Control)控制反转，又叫DI(Dependency Injection)依赖注入，是一个流程，对象可以通过这个流程来定义他们在运行时需要用到的其他对象（依赖），这些依赖的对象可以是构造方法中的参数，可以是工厂方法的返回值，可以是一个带有set方法的property。IoC容器在创建bean的时候将这些依赖注入到这个bean中。这个流程和正常流程是相反的，既我们将创将对象和注入依赖的控制权交给了容器，所以叫作控制反转。</p>
<h3 id="IoC的底层实现"><a href="#IoC的底层实现" class="headerlink" title="IoC的底层实现"></a>IoC的底层实现</h3><p>面向类的编程 =&gt; 面向接口的编程 =&gt; 工厂模式 =&gt; 工厂模式+反射+配置文件实现程序解耦</p>
<p>传统方式我们面向类编程，一个类型的引用只能对应该类型的对象例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyClass myClass = <span class="keyword">new</span> MyClass();</span><br></pre></td></tr></table></figure>

<p>经过改进后我们面向接口编程，一个接口类型的引用可以指向实现该接口的多种类型对象（多态）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyInterface myClass = <span class="keyword">new</span> MyClassImplMyInterface();</span><br></pre></td></tr></table></figure>

<p>这样接口和实现类耦合度过高，当我们要换其他实现类的时候必须修改源码。</p>
<p>为了满足程序设计的OCP原则，在尽量不修改程序源码的基础上对程序进行扩展，我们使用工厂模式，创建工厂类，利用工厂得到对应的对象，这时接口和实现类没有了耦合，但是当我们要更换实现类的时候需要修改工厂里的代码。</p>
<p>Spring IoC容器的出现让我们只需要修改配置文件，就可以轻松的替换一个bean对象的实现类，Ioc容器通过解析xml文件中bean的配置信息，拿到需要创建bean对象的类型信息，然后使用工厂类通过反射创建该类型的实例然后返回给用户。当我们需要修改一个bean的实现类的时候，只需要修改xml配置文件就可以了。</p>
<p>Ioc控制翻转：将创建对象的控制权交由Ioc容器管理。</p>
<p>DI依赖注入：在创建对象时自动注入对象的依赖，如设置属性的值。</p>
<h3 id="Spring的工厂类"><a href="#Spring的工厂类" class="headerlink" title="Spring的工厂类"></a>Spring的工厂类</h3><p>BeanFactory: 老版本工厂类</p>
<p>ApplicationContext: 新版本工厂类，现在都用新版本的。</p>
<h4 id="Spring工厂类的结构"><a href="#Spring工厂类的结构" class="headerlink" title="Spring工厂类的结构"></a>Spring工厂类的结构</h4><p><img src="SpringFactory.png" alt="SpringFactory"></p>
<p>ApplicationContext接口继承了BeanFactory接口，BeanFactory和ApplicationContext的区别：</p>
<ul>
<li>BeanFactory在调用getBean()方法的时候才会生成类的实例。</li>
<li>ApplicationContex在加载配置文件的时候就将Spring管理的类实例化。</li>
</ul>
<h4 id="最底层的两个实现类"><a href="#最底层的两个实现类" class="headerlink" title="最底层的两个实现类"></a>最底层的两个实现类</h4><p>ClassPathXmlApplicationContext: 用来加载类路径下的xml配置文件。</p>
<p>FileSystemXmlApplicationContext: 用来加载磁盘上的xml配置文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">MyClass myClass = (MyClass)applicationContext.getBean(<span class="string">"MyClassBeanID"</span>);</span><br></pre></td></tr></table></figure>



<h3 id="Bean的创建"><a href="#Bean的创建" class="headerlink" title="Bean的创建"></a>Bean的创建</h3><h4 id="1）无参构造方法（默认）"><a href="#1）无参构造方法（默认）" class="headerlink" title="1）无参构造方法（默认）"></a>1）无参构造方法（默认）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Bean的无参构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean"</span> <span class="attr">class</span>=<span class="string">"com.xinxing.Bean"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2）静态工厂实例化方式："><a href="#2）静态工厂实例化方式：" class="headerlink" title="2）静态工厂实例化方式："></a>2）静态工厂实例化方式：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticBeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bean <span class="title">staticBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Bean的静态实例化工厂</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean"</span> <span class="attr">class</span>=<span class="string">"com.xinxing.StaticBeanFactory"</span> <span class="attr">factory-method</span>=<span class="string">"staticBeanFactory"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3）实例化工厂实例化方式"><a href="#3）实例化工厂实例化方式" class="headerlink" title="3）实例化工厂实例化方式"></a>3）实例化工厂实例化方式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bean <span class="title">beanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Bean的实例化工厂</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanFactory"</span> <span class="attr">class</span>=<span class="string">"com.xinxing.BeanFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean"</span> <span class="attr">factory-bean</span>=<span class="string">"beanFactory"</span> <span class="attr">factory-method</span>=<span class="string">"beanFactory"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Bean的配置"><a href="#Bean的配置" class="headerlink" title="Bean的配置"></a>Bean的配置</h3><h4 id="Bean的id，name配置"><a href="#Bean的id，name配置" class="headerlink" title="Bean的id，name配置"></a>Bean的id，name配置</h4><p>id: 使用了唯一约束，里面不能出现特殊字符。</p>
<p>name: 没有唯一约束，可以出现特殊字符，通常会在Spring和struts1框架整合时遇到。</p>
<h4 id="Bean生命周期的配置"><a href="#Bean生命周期的配置" class="headerlink" title="Bean生命周期的配置"></a>Bean生命周期的配置</h4><p>init-method: Bean版初始化时候执行的方法。</p>
<p>destroy-methos：Bean被关闭时候执行的方法。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.xinxng.Person"</span> <span class="attr">init-method</span>=<span class="string">"myInitMethod"</span> <span class="attr">destroy-method</span>=<span class="string">"myDestroyMethod"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Bean的作用范围的配置"><a href="#Bean的作用范围的配置" class="headerlink" title="Bean的作用范围的配置"></a>Bean的作用范围的配置</h4><p>scope：Bean的作用范围</p>
<ul>
<li>singleton：默认的，Spring会采用单例模式创建这个对象。</li>
<li>prototype：多例模式。</li>
<li>request：应用在web项目中，Spring创建Bean后会放入到request范围中。</li>
<li>session：应用在web项目中，Spring创建Bean后会放入到session范围中。</li>
<li>globalsession：应用在web项目中，必须在porlet环境下使用。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.xinxng.Person"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="基于配置文件的属性注入"><a href="#基于配置文件的属性注入" class="headerlink" title="基于配置文件的属性注入"></a>基于配置文件的属性注入</h3><h4 id="1）导入6个Spring核心开发包"><a href="#1）导入6个Spring核心开发包" class="headerlink" title="1）导入6个Spring核心开发包"></a>1）导入6个Spring核心开发包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring-bean-x.x.x.RELEASE.jar</span><br><span class="line">spring-context-x.x.x.RELEASE.jar</span><br><span class="line">spring-core-x.x.x.RELEASE.jar</span><br><span class="line">spring-expression-x.x.x.RELEASE.jar</span><br><span class="line">com.springsource.org.apache.commons.logging-x.x.x.jar</span><br><span class="line">com.springsource.org.apache.log4j-x.x.x.jar</span><br></pre></td></tr></table></figure>

<h4 id="2）配置XML文件约束"><a href="#2）配置XML文件约束" class="headerlink" title="2）配置XML文件约束"></a>2）配置XML文件约束</h4><p>导入<strong>beans</strong>约束，参考官方文档：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#xsd-schemas-beans">9.1.4. The beans schema</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">"cacheName"</span> <span class="attr">value</span>=<span class="string">"foo"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Rick"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="普通类型属性注入方法"><a href="#普通类型属性注入方法" class="headerlink" title="普通类型属性注入方法"></a>普通类型属性注入方法</h4><h5 id="1）构造方法的属性注入"><a href="#1）构造方法的属性注入" class="headerlink" title="1）构造方法的属性注入"></a>1）构造方法的属性注入</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Person child;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, Person child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.child = child;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + age + child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person1"</span> <span class="attr">class</span>=<span class="string">"com.xinxing.Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span>, <span class="attr">value</span>=<span class="string">"xinxing"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span>, <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"child"</span>, <span class="attr">ref</span>=<span class="string">"childID"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="2）set方法的属性注入"><a href="#2）set方法的属性注入" class="headerlink" title="2）set方法的属性注入"></a>2）set方法的属性注入</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Person child;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Person child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.child = child;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + age + child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person2"</span> <span class="attr">class</span>=<span class="string">"com.xinxing.Person"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- value用来指定普通类型的值，ref用来指定对象的引用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"xinxing"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"child"</span> <span class="attr">ref</span>=<span class="string">"person1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="3）P名称空间的属性注入-Spring-2-5-以后"><a href="#3）P名称空间的属性注入-Spring-2-5-以后" class="headerlink" title="3）P名称空间的属性注入(Spring 2.5 以后)"></a>3）P名称空间的属性注入(Spring 2.5 以后)</h5><p>添加p名称空间约束<code>xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person3"</span> <span class="attr">class</span>=<span class="string">"com.xinxing.Person"</span> <span class="attr">p:name</span>=<span class="string">"xinxing"</span> <span class="attr">p:age</span>=<span class="string">"10"</span> <span class="attr">p:child-ref</span>=<span class="string">"person2"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="4）SpEL的属性注入-Spring-3-0-以后"><a href="#4）SpEL的属性注入-Spring-3-0-以后" class="headerlink" title="4）SpEL的属性注入(Spring 3.0 以后)"></a>4）SpEL的属性注入(Spring 3.0 以后)</h5><p>SpEL：Spring Expression Language</p>
<p>参考：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#expressions">4. Spring Expression Language (SpEL)</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person4"</span> <span class="attr">class</span>=<span class="string">"com.xinxing.Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"#&#123;person3.getName&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"#&#123;person3.getAge()&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"chile"</span> <span class="attr">value</span>=<span class="string">"#&#123;person3&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="数组、集合类型的属性注入方法"><a href="#数组、集合类型的属性注入方法" class="headerlink" title="数组、集合类型的属性注入方法"></a>数组、集合类型的属性注入方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] arrs;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; set;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; map;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArrs</span><span class="params">(String[] arrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arrs = arrs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setList</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSet</span><span class="params">(Set&lt;String&gt; set)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.set = set;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMap</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.map = map;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(arrs + list + set + map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"collectionBean"</span> <span class="attr">class</span>=<span class="string">"com.xinxing.CollectionBean"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- String[]数组的属性注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"arrs"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 普通类型的数组用value标签 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>xinxing1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>xinxing2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 自定义类型的数组用ref标签 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- &lt;ref/&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- list集合的属性注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>xinxing1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>xinxing2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- set集合的属性注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"set"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>xinxing1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>xinxing2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- map集合的属性注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"1"</span>, <span class="attr">value</span>=<span class="string">"xinxing1"</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"2"</span>, <span class="attr">value</span>=<span class="string">"xinxing2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="基于注解的属性注入"><a href="#基于注解的属性注入" class="headerlink" title="基于注解的属性注入"></a>基于注解的属性注入</h3><h4 id="1）导入6个核心包-AOP开发包：spring-aop-x-x-x-RELEASE-jar"><a href="#1）导入6个核心包-AOP开发包：spring-aop-x-x-x-RELEASE-jar" class="headerlink" title="1）导入6个核心包 + AOP开发包：spring-aop-x.x.x.RELEASE.jar"></a>1）导入6个核心包 + AOP开发包：spring-aop-x.x.x.RELEASE.jar</h4><h4 id="2）配置XML文件约束-1"><a href="#2）配置XML文件约束-1" class="headerlink" title="2）配置XML文件约束"></a>2）配置XML文件约束</h4><p>导入<strong>context</strong>约束，参考官方文档：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#xsd-schemas-context">9.1.3. The context schema</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span> <span class="comment">&lt;!-- bean definitions here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3）开启注解扫描器"><a href="#3）开启注解扫描器" class="headerlink" title="3）开启注解扫描器"></a>3）开启注解扫描器</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.xinxing.package"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Bean管理的常用注解"><a href="#Bean管理的常用注解" class="headerlink" title="Bean管理的常用注解"></a>Bean管理的常用注解</h4><h5 id="Component-value-”Id”"><a href="#Component-value-”Id”" class="headerlink" title="@Component(value=”Id”)"></a>@Component(value=”Id”)</h5><p>@Component作用在类上，用于给对应类的对象取一个Id。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(value=<span class="string">"Id"</span>) == &lt;bean id=<span class="string">"Id"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.xinxng.ClassName"</span>/&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(value=<span class="string">"userService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Component如果不加value属性，默认以<strong>类名首字母小写</strong>作为对象名。</p>
<p>Spring提供三个和@Component功能一样的衍生注解，分别应用在不同的层次中：</p>
<p><strong>@Controller</strong>：作用在Web层的类上。</p>
<p><strong>@Service</strong>：作用在Service层的类上。</p>
<p><strong>@Repository</strong>：作用在Dao层的类上。</p>
<h5 id="Scope-value-”scope”"><a href="#Scope-value-”scope”" class="headerlink" title="@Scope(value=”scope”)"></a>@Scope(value=”scope”)</h5><p>@Scope作用在类上，用于指定对象的作用范围：</p>
<ul>
<li>singleton：默认单例模式。</li>
<li>prototype：多例模式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(value=<span class="string">"userService"</span>)</span><br><span class="line"><span class="meta">@Scope</span>(value=<span class="string">"prototype"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Value-value-”value”"><a href="#Value-value-”value”" class="headerlink" title="@Value(value=”value”)"></a>@Value(value=”value”)</h5><p>@Value作用在属性上，用于<strong>基本数据类型</strong>的注入，使用注解方式注入属性可以不提供set方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(value=<span class="string">"userService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 相当于给name属性注入“xinxing”，而且可以省略setName()方法</span></span><br><span class="line">    <span class="meta">@Value</span>(value=<span class="string">"xinxing"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/*public void setName(String name) &#123;this.name = name&#125;*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Autowired-Qualifier-value-”ID”"><a href="#Autowired-Qualifier-value-”ID”" class="headerlink" title="@Autowired + @Qualifier(value=”ID”)"></a>@Autowired + @Qualifier(value=”ID”)</h5><p>@Autowired作用在属性上，用于对象属性的注入。</p>
<p>@Autowired注解单独使用时会按照类型自动注入对象，想要按照对象ID注入，必须在下面加@Qualifier(value=”ID”)注解，这两注解一起使用时可以完成按照对象ID注入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span>(value=<span class="string">"userDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>(value=<span class="string">"userService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//如果单独使用@Autowired 它会按照类型自动装配</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(value=<span class="string">"userDao"</span>) <span class="comment">//这两个注解一起使用会按照名称“userDao”注入属性</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Resource-name-”ID”"><a href="#Resource-name-”ID”" class="headerlink" title="@Resource(name=”ID”)"></a>@Resource(name=”ID”)</h5><p>@Resource是java提供的一个注解，在javax.annotation包中，Spring框架也支持这个注解，可以完成@Autowired+@Qualifier(value=”ID”)一样的功能，@Resource可以在Ioc容器中按照对象ID找到对应对象然后注入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>(value=<span class="string">"userService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"userDao"</span>)</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h5><p>@PostConstruct是java提供的注解在javax.annotation包中，作用在方法上指定对象的初始化方法，相当于bean标签里的init-method属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PastConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="PreDestroy"><a href="#PreDestroy" class="headerlink" title="@PreDestroy"></a>@PreDestroy</h5><p>@PreDestroy是java提供的注解在javax.annotation包中，作用在方法上指定对象的销毁方法，相当于bean标签的的destroy-method属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spring分模块开发的配置"><a href="#Spring分模块开发的配置" class="headerlink" title="Spring分模块开发的配置"></a>Spring分模块开发的配置</h3><h4 id="在一个配置文件里引入多个配置文件"><a href="#在一个配置文件里引入多个配置文件" class="headerlink" title="在一个配置文件里引入多个配置文件"></a>在一个配置文件里引入多个配置文件</h4><p>applicationContext1.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"applicationContext2.xml"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="加载配置文件的时候一次加载多个"><a href="#加载配置文件的时候一次加载多个" class="headerlink" title="加载配置文件的时候一次加载多个"></a>加载配置文件的时候一次加载多个</h4><p>新建applicationContext对象的时候向里面传入多个配置文件，相当于调用接收可变参数的构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext1.xml"</span>, <span class="string">"applicationContext2.xml"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Spring整合Web工程"><a href="#Spring整合Web工程" class="headerlink" title="Spring整合Web工程"></a>Spring整合Web工程</h3><p>我们将前端控制器配置好后开始往项目中整合Spring框架，原来在表现层中需要自己new一个服务层的服务对象，然后调用服务，现在这个服务层的服务对象应该交由Spring管理，所以我们执行下面的操作。</p>
<h4 id="1）导入项目依赖"><a href="#1）导入项目依赖" class="headerlink" title="1）导入项目依赖"></a>1）导入项目依赖</h4><p>将Spring的4个核心包导入项目：Beans，Core，Context，SpEL，然后导入loging，log4j一共6个jar包。</p>
<h4 id="2）创建applicationContex-xml配置文件并配置bean"><a href="#2）创建applicationContex-xml配置文件并配置bean" class="headerlink" title="2）创建applicationContex.xml配置文件并配置bean"></a>2）创建applicationContex.xml配置文件并配置bean</h4><p>在src下创建Spring配置文件applicationContext.xml，在配置文件中配置Service层相应业务的Bean</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"customerService"</span> <span class="attr">class</span>=<span class="string">"com.xinxing.CustomerServiceImpl"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样我们就将Service层中的CustomerService对象交由Spring管理。</p>
<p>在表现层中我们需要使用CustomerService对象来调用它的服务，想要得到CustomerService对象，我们就需要创建一个Spring工厂，然后通过Spring工厂得到CustomerService对象，表现层代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">        Customerservice cs = (CustomerService)ac.getBean(<span class="string">"customerService"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是表现层的控制器对象不是由Spring创建的，是由表现层框架创建的，每当网页发来一个请求，表现层框架就会调用这个Controller来处理请求，但是，每次来一个请求就需要加载Spring配置文件创建一次工厂来一个请求就需要创建一个工厂，这样会制造出很多无用的Sping工厂造成资源浪费，性能也是相当低的。</p>
<p>要解决上面的问题就需要用到Spring对Web项目的整合功能。</p>
<h4 id="3）添加spring-web-x-x-x-RELEASE-jar包"><a href="#3）添加spring-web-x-x-x-RELEASE-jar包" class="headerlink" title="3）添加spring-web-x.x.x.RELEASE.jar包"></a>3）添加spring-web-x.x.x.RELEASE.jar包</h4><h4 id="4）配置ServletContext对象监听器"><a href="#4）配置ServletContext对象监听器" class="headerlink" title="4）配置ServletContext对象监听器"></a>4）配置ServletContext对象监听器</h4><blockquote>
<p>Web容器在启动时会为每个Web应用创建一个ServletContext对象，ServletContext对象与Web应用具有同样的生命周期。ServletConfig对象中维护了ServletContext的引用，开发人员在编写Servlet时，可以通过ServletConfig.getServletContext方法获得ServletContext对象。由于一个Web应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为Context域对象</p>
<p>补充：一个类或一个控制器就相当于一个Servlet，一个部署在Tomcat上的war包就相当于一个Web应用，可见一个Web应用中可以包含很多Servlet。</p>
</blockquote>
<p>Spring的ServletContext对象监听器会在ServletContext对象被创建时执行我们配置好的方法，而ServletContext对象会在Web容器启动时被创建，所以通过配置ServletContext监听器我们可以在Web容器启动时加载Spring中配置好的对象，而且对象只被加载一次。</p>
<p>需要在web.xml中配置监听器：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>ContextLoaderListener默认情况下只能加载WEB-INF文件下的Spring配置文件，我们需要配置一下加载路径：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>补充：</p>
<ul>
<li><p>src不是classpath， WEB-INF/classes和WEB-INF/lib才是classpath，WEB-INF/ 是资源目录, 客户端不能直接访问。</p>
</li>
<li><p>WEB-INF/lib和WEB-INF/classes同属classpath，两者的访问优先级为: lib&gt;classes</p>
</li>
<li><p>WEB-INF/classes目录存放src目录里java文件编译之后的class文件，xml、properties等资源配置文件，这是一个定位资源的入口。</p>
</li>
<li><p>classpath 和 classpath* 区别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">classpath：只会到你的class路径中查找找文件;</span><br><span class="line">classpath*：不仅包含class路径，还包括jar文件中(class路径)进行</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Maven项目中这个classes文件被移到了target文件夹下，编译完成的class、xml和properties文件都被放到了target/classes文件里，classpath指的是target/classes文件夹。</p>
</li>
</ul>
</blockquote>
<h4 id="5）从ServletContext中获取WebApplicationContext，然后得到customerService对象。"><a href="#5）从ServletContext中获取WebApplicationContext，然后得到customerService对象。" class="headerlink" title="5）从ServletContext中获取WebApplicationContext，然后得到customerService对象。"></a>5）从ServletContext中获取WebApplicationContext，然后得到customerService对象。</h4><p>ServletContext监听器加载完配置文件后，会把相应的Web工厂对象放到ServletContext对象中去。修改前端控制器代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");*/</span></span><br><span class="line">        ServletContext sc = ServletActionContext.getServletContext();</span><br><span class="line">        WebApplicationContext ac = WebApplicationContextUtils.getWebApplicationContext(sc);</span><br><span class="line">        Customerservice cs = (CustomerService)ac.getBean(<span class="string">"customerService"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>补充：Web应用处理业务流程：</p>
<p>客户在网页操作发起业务请求，用户数据从网页传递到表现层，表现层调用相应的Controller处理数据然后完成，比如在Controller中会调用服务层的服务，服务层返回后跳转到操作成功页面，然后数据会被传递到服务层，服务层对数据做相应的处理完成业务逻辑，如果需要，服务层会调用持久层的服务把数据传递到持久层，持久层将数据保存在数据库，最后完成整个业务流程。</p>
<p>数据会从表现层 =&gt; 服务层 =&gt; 持久层。</p>
</blockquote>
<hr>
<h3 id="Spring整合Junit单元测试"><a href="#Spring整合Junit单元测试" class="headerlink" title="Spring整合Junit单元测试"></a>Spring整合Junit单元测试</h3><p>利用Spring Ioc向测试类中注入需要测试的类。</p>
<p>1）引入Junit的依赖包。</p>
<p>2）引入spring-test-x.x.x.RELEASE.jar包。</p>
<p>3）使用注解在测试类中引入需要测试的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">@ContextConfiguration("classpath:applicationContext.xml")</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"userService"</span>)</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="AOP-Aspect-Oriented-Programming-面向切面编程"><a href="#AOP-Aspect-Oriented-Programming-面向切面编程" class="headerlink" title="AOP(Aspect Oriented Programming)面向切面编程"></a>AOP(Aspect Oriented Programming)面向切面编程</h2><h3 id="AOP的概念"><a href="#AOP的概念" class="headerlink" title="AOP的概念"></a>AOP的概念</h3><blockquote>
<p>AOP(Aspect-Oriented Programming)面向切面编程，我们知道，面向对象的特点是继承、多态和封装。而封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用。</p>
<p>但是人们也发现，在分散代码的同时，也增加了代码的重复性。什么意思呢？比如说，我们在两个类中，可能都需要在每个方法中做日志。按面向对象的设计方法，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是因为面向对象的设计让类与类之间无法联系，而不能将这些重复的代码统一起来。</p>
<p>也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？<strong>这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。</strong> </p>
<p>一般而言，我们管切入到指定类指定方法的代码片段称为<strong>切面</strong>，而切入到哪些类、哪些方法则叫<strong>切入点</strong>。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。</p>
<p>这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。 AOP在编程历史上可以说是里程碑式的，对OOP编程是一种十分有益的补充。AOP采用横向抽取机制，取代了传统纵向继承体系结构，提高了代码的重用性。</p>
</blockquote>
<h3 id="AOP的底层实现原理"><a href="#AOP的底层实现原理" class="headerlink" title="AOP的底层实现原理"></a>AOP的底层实现原理</h3><p>AOP底层使用动态代理技术实现，提供两种动态代理方式：</p>
<ol>
<li>基于JDK的动态代理：必须是面向接口的，只有实现了具体接口的类才能生成代理对象。</li>
<li>基于CGLIB的动态代理：对于没有实现接口的类，也可以产生代理，产生这个类的之类的方式。</li>
</ol>
<p>AOP中根据类是否实现接口来采用上面两种动态代理的方式。</p>
<h4 id="基于JDK的动态代理"><a href="#基于JDK的动态代理" class="headerlink" title="基于JDK的动态代理"></a>基于JDK的动态代理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDatImpl</span> <span class="keyword">implements</span> <span class="title">UserDat</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"save user data..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"update user data..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需求：在UserDao的save()方法执行之前打印日志。由于UserDao是接口，所以我们可以使用基于JDK的动态代理。</p>
<p>首先创建一个工具类，类里使用Proxy类创建代理对象然后返回，Proxy中的静态方法newProxyInstance中必须要求传入目标对象实现的接口，所以使用JDK Proxy类实现动态代理要求目标对象必须要有实现的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用JDK的方式生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProxyUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserDao <span class="title">getProxy</span><span class="params">(<span class="keyword">final</span> UserDao dao)</span> </span>&#123;</span><br><span class="line">        UserDao proxy = (UserDao)Proxy.newProxyInstance(dao.getClass().getClassLoader(), dao.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="comment">// 只要代理对象被调用，这个回调方法就会被执行</span></span><br><span class="line">            <span class="comment">// proxy代表当前生成的代理对象</span></span><br><span class="line">            <span class="comment">// method表示当前代理对象调用目标函数的方法</span></span><br><span class="line">            <span class="comment">// agrs表示method方法中传入的参数</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">// 增强目标对象中的save方法</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"save"</span>.equals(method.getName())) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"记录日志"</span>);</span><br><span class="line">                    <span class="comment">// 开启事务</span></span><br><span class="line">                    <span class="comment">// method.invoke(dao, args);</span></span><br><span class="line">                    <span class="comment">// 提交事务</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 让dao中的方法正常执行，method是代理对象调用目标对象中的方法</span></span><br><span class="line">                <span class="keyword">return</span> method.invoke(dao, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 原始方式</span></span><br><span class="line">        UserDao dao = <span class="keyword">new</span> UserDatImpl(); <span class="comment">// 目标对象</span></span><br><span class="line">        dao.save();</span><br><span class="line">        dao.update();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 代理方式</span></span><br><span class="line">        <span class="comment">// 使用工具类获取代理对象</span></span><br><span class="line">        UserDao proxy = MyProxyUtils.getProxy(dao); <span class="comment">// 代理对象</span></span><br><span class="line">        proxy.save(); <span class="comment">// 它会执行proxy里面的invoke()方法，不会执行dao中的save()方法。</span></span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基于CGLIB的动态代理"><a href="#基于CGLIB的动态代理" class="headerlink" title="基于CGLIB的动态代理"></a>基于CGLIB的动态代理</h4><p>Spring核心包spring-core-x.x.x.RELEASE.jar中包含CGLIB的开发包。CBLIB内部是使用生成子类的方法生成代理对象，所以不要求目标类实现接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCglibUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用cglib的方式生成代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Book <span class="title">getProxy</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置父类</span></span><br><span class="line">        enhancer.setSuperclass(book.getClass());</span><br><span class="line">        <span class="comment">// 设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="comment">// 当代理对象被调用的时候，回调函数就会执行</span></span><br><span class="line">            <span class="comment">// proxy表示当前的代理对象</span></span><br><span class="line">            <span class="comment">// method表示代理对象调用目标函数的方法</span></span><br><span class="line">            <span class="comment">// args表示method中传入的参数</span></span><br><span class="line">            <span class="comment">// methodProxy表示目标函数method的代理方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">// 增强目标函数方法</span></span><br><span class="line">                <span class="keyword">if</span>(method.getName().equals(<span class="string">"save"</span>)) &#123;</span><br><span class="line">                    <span class="comment">// do something</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 正常执行目标函数的方法</span></span><br><span class="line">                <span class="keyword">return</span> methodProxy.invokeSuper(proxy, args)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 生成代理对象</span></span><br><span class="line">        Book proxy = (Book)enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function">publci <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 原始方式</span></span><br><span class="line">        Book book = <span class="keyword">new</span> Book();</span><br><span class="line">        book.save();</span><br><span class="line">        book.update();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 代理方式</span></span><br><span class="line">        Book proxy = MyCglibUtils.getProxy(book);</span><br><span class="line">        proxy.save();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AOP相关术语"><a href="#AOP相关术语" class="headerlink" title="AOP相关术语"></a>AOP相关术语</h3><ul>
<li><strong>Aspect</strong>(切面)：切入点和我们对切入点做的增强功能形成了一个切面，切入点需要配置，增强功能需要我们自己编写。</li>
<li><strong>Join point</strong>(连接点)：一个类中的所有方法都可以成为连结点</li>
<li><strong>Advice</strong>(通知/增强)：我们对切入点添加的功能。 </li>
<li><strong>Pointcut</strong>(切入点)：我们对一些方法(连接点)进行增强，这个增强的连结点就是切入点。</li>
<li><strong>Introduction</strong>(引介)：引介是一种特殊的通知，可以在运行期为类动态地添加一些方法或属性。</li>
<li><strong>Target object</strong>(目标对象)：我们要对其创建代理的对象。</li>
<li><strong>AOP proxy</strong>(代理)：代理对象，JDK动态代理对象或者CGLIB动态代理对象。</li>
<li><strong>Weaving</strong>(织入)：织入是一个过程，是指给目标对象的切入点添加新的功能，然后创建代理对象的过程。</li>
</ul>
<h3 id="基于AspectJ的XML方式的AOP开发"><a href="#基于AspectJ的XML方式的AOP开发" class="headerlink" title="基于AspectJ的XML方式的AOP开发"></a>基于AspectJ的XML方式的AOP开发</h3><h4 id="1）导入项目依赖-1"><a href="#1）导入项目依赖-1" class="headerlink" title="1）导入项目依赖"></a>1）导入项目依赖</h4><p>6个核心开发包</p>
<p>2个AOP开发包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring-aop-x.x.x.RELEASE.jar</span><br><span class="line">com.springsource.org.aopalliance-x.x.x.jar</span><br></pre></td></tr></table></figure>

<p>2个AspectJ开发包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.springsource.org.aspectj.weaver-x.x.x.RELEASE.jar</span><br><span class="line">spring-aspects-x.x.x.RELEASE.jar</span><br></pre></td></tr></table></figure>

<h4 id="2）配置XML文件约束-2"><a href="#2）配置XML文件约束-2" class="headerlink" title="2）配置XML文件约束"></a>2）配置XML文件约束</h4><p>导入AOP约束，参考官方文档：<a href="https://docs.spring.io/spring/docs/5.0.7.RELEASE/spring-framework-reference/core.html#xsd-schemas-aop">9.1.2. The aop schema</a></p>
<p>applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span> <span class="comment">&lt;!-- bean definitions here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3）创建包结构，编写接口和实现类"><a href="#3）创建包结构，编写接口和实现类" class="headerlink" title="3）创建包结构，编写接口和实现类"></a>3）创建包结构，编写接口和实现类</h4><p>CustomerDao.jave</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Interface CustomerDao &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CustomerDaoImpl.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerDaoImpl</span> <span class="keyword">implements</span> <span class="title">CustomerDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>applicationContext.xml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"customerDao"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.xinxing.CustomerDaoImpl"</span>/&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4）编写切面类"><a href="#4）编写切面类" class="headerlink" title="4）编写切面类"></a>4）编写切面类</h4><p>需求：我们有一个CustomerDaoImpl类实现了CustomerDao接口的save(), update()方法，我们想要在save()方法执行前打印日志，现在需要编写增强代码。</p>
<p>切面类 MyAspectXml.java ，MyAspectXml类的对象应该交给IoC容器管理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspectXml</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通知/增强功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录日志</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将切面类交给容器管理。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置切面类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myAspectXml"</span> <span class="attr">class</span>=<span class="string">"com.xinxing.MyAspectXml"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5）配置AOP"><a href="#5）配置AOP" class="headerlink" title="5）配置AOP"></a>5）配置AOP</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置AOP --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置切面：切入点 + 通知/增强(类型) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"myAspectXml"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置前置通知：save()方法执行之前，增强方法log()先执行 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 切入点表达式：execution(public void com.xinxing.CustomerDaoImpl.save()) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"log"</span> <span class="attr">pointcut</span>=<span class="string">"execution(public void com.xinxing.CustomerDaoImpl.save())"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="切入点表达式写法"><a href="#切入点表达式写法" class="headerlink" title="切入点表达式写法"></a>切入点表达式写法</h3><p>切入点表达式的固定格式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">execution([修饰符] 返回值类型 包名.类名.方法名(参数))</span><br></pre></td></tr></table></figure>

<p>1）修饰符，如<code>public</code>，可以省略不写，其他 部分都不能省略。</p>
<p>2）返回值类型，<code>*</code>代表任意返回值类型。</p>
<p>3）包名，如 <code>com.xinxing</code>，有下面几种写法：</p>
<ul>
<li><code>com.*</code>表示在com包中搜索。</li>
<li><code>*..*</code>表示在任意包下搜索。</li>
</ul>
<p>4）类名，如<code>CustomerDaoImpl</code>，有下面几种写法：</p>
<ul>
<li><code>Customer*</code>表示以<code>Customer</code>开头的类名。</li>
<li><code>*DaoImpl</code>表示以<code>DaoImpl</code>结尾的类名</li>
</ul>
<p>5）方法名，如<code>save</code>，有下面几种写法：</p>
<ul>
<li><code>*</code>表示所有方法。</li>
<li><code>save*()</code>表示以save开头的方法。</li>
<li><code>*save()</code>表示以save结尾的方法。</li>
</ul>
<p>6）参数名，如<code>(Sring, int)</code>，有下面几种写法：</p>
<ul>
<li><code>(*)</code>表示任意的一个参数。</li>
<li><code>(..)</code>表示任意参数，相当于可变参数。</li>
</ul>
<h3 id="AOP通知-增强类型"><a href="#AOP通知-增强类型" class="headerlink" title="AOP通知/增强类型"></a>AOP通知/增强类型</h3><h4 id="1）Before-前置通知"><a href="#1）Before-前置通知" class="headerlink" title="1）Before 前置通知"></a>1）Before 前置通知</h4><p>在目标对象方法执行之前执行的增强方法。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"adviceMethod"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>应用：验证方法的传入参数。</p>
<h4 id="2）After-后置通知"><a href="#2）After-后置通知" class="headerlink" title="2）After 后置通知"></a>2）After 后置通知</h4><p>在目标对象方法执行之后执行的增强方法。如果目标对象方法出现异常，增强方法也会执行。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"adviceMethod"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>应用：释放资源。</p>
<h4 id="3）After-returning-正常返回通知"><a href="#3）After-returning-正常返回通知" class="headerlink" title="3）After-returning 正常返回通知"></a>3）After-returning 正常返回通知</h4><p>目标对象方法正常返回后执行的增强方法。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"adviceMethod"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>应用：修改方法返回值。</p>
<h4 id="4）After-throwing-异常返回通知"><a href="#4）After-throwing-异常返回通知" class="headerlink" title="4）After-throwing 异常返回通知"></a>4）After-throwing 异常返回通知</h4><p>目标对象方法抛出异常后才执行增强方法。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"adviceMethod"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>应用：包装异常信息。</p>
<h4 id="5）Around-环绕通知"><a href="#5）Around-环绕通知" class="headerlink" title="5）Around 环绕通知"></a>5）Around 环绕通知</h4><p>在目标对象方法执行的前后执行增强方法，<strong>默认情况下目标对象的方法不执行</strong>，需要手动让目标对象的方法执行。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"around"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 环绕通知1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 手动执行目标对象方法</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        joinPoint.proceed();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 环绕通知2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用：事务管理，方法执行前开启事务，方法执行后提交事务。</p>
<h3 id="基于AspectJ的注解方式的AOP开发"><a href="#基于AspectJ的注解方式的AOP开发" class="headerlink" title="基于AspectJ的注解方式的AOP开发"></a>基于AspectJ的注解方式的AOP开发</h3><h4 id="1）导入项目依赖-2"><a href="#1）导入项目依赖-2" class="headerlink" title="1）导入项目依赖"></a>1）导入项目依赖</h4><p>和Xml方式的一样。</p>
<h4 id="2）配置XML文件约束-3"><a href="#2）配置XML文件约束-3" class="headerlink" title="2）配置XML文件约束"></a>2）配置XML文件约束</h4><p>这个XML文件是最全的包含了注解、AOP和事务的约束。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/tx/spring-tx.xsd"</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3）创将包结构，编写接口和实现类"><a href="#3）创将包结构，编写接口和实现类" class="headerlink" title="3）创将包结构，编写接口和实现类"></a>3）创将包结构，编写接口和实现类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> CustomerDaoImpl implements CustomerDao &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置目标对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"customerDao"</span> <span class="attr">class</span>=<span class="string">"com.xinxing.CustomerDaoImpl"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.Runwith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">@ContextConfiguration("classpath:applicationContext.xml")</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"customerDao"</span>)</span><br><span class="line">    <span class="keyword">private</span> CustomerDao customerDao;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        customerDao.save();</span><br><span class="line">        customerDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4）编写切面类-1"><a href="#4）编写切面类-1" class="headerlink" title="4）编写切面类"></a>4）编写切面类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspectAnnotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录日志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将切面类交给容器管理</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置切面类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myAspectAnnotation"</span> <span class="attr">class</span>=<span class="string">"com.xinxing.MyAspectAnnotation"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5）-添加注解"><a href="#5）-添加注解" class="headerlink" title="5） 添加注解"></a>5） 添加注解</h4><h5 id="1-在切面类上添加-Aspect注解"><a href="#1-在切面类上添加-Aspect注解" class="headerlink" title="1. 在切面类上添加@Aspect注解"></a>1. 在切面类上添加@Aspect注解</h5><h5 id="2-在增强方法上添加通知类型注解"><a href="#2-在增强方法上添加通知类型注解" class="headerlink" title="2. 在增强方法上添加通知类型注解"></a>2. 在增强方法上添加通知类型注解</h5><p><strong>@Before</strong> : 前置通知</p>
<p><strong>@After</strong> : 后置通知</p>
<p><strong>@AfterReturing</strong> : 正常返回通知</p>
<p><strong>@AfterThrowing</strong> : 异常返回通知</p>
<p><strong>@Around</strong> : 环绕通知</p>
<h5 id="3-在通知类型里设置切入点"><a href="#3-在通知类型里设置切入点" class="headerlink" title="3. 在通知类型里设置切入点"></a>3. 在通知类型里设置切入点</h5><p><code>value=&quot;execution(public void com.xinxing.CustomerDaoImpl.save())&quot;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspectj;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span>  <span class="comment">// 标注当前类为一个切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspectAnnotation</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置通知类型为Before，在目标方法执行之前执行，value设置切入点</span></span><br><span class="line">    <span class="meta">@Before</span>(value=<span class="string">"execution(public void com.xinxing.CustomerDaoImpl.save())"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录日志</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@After</span>(value=<span class="string">"execution(public void com.xinxing.CustomerDaoImpl.update())"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-自定义切入点"><a href="#4-自定义切入点" class="headerlink" title="4. 自定义切入点"></a>4. 自定义切入点</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspectAnnotation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(value=<span class="string">"execution(public void com.xinxing.CustomerDaoImpl.save())"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before</span>(value=<span class="string">"MyAspectAnnotation.fn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@After</span>(value=<span class="string">"MyAspectAnnotation.fn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around</span>(value=<span class="string">"MyAspectAnnotation.fn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 让目标对象执行</span></span><br><span class="line">            joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStacktrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do someting</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6）开启自动代理"><a href="#6）开启自动代理" class="headerlink" title="6）开启自动代理"></a>6）开启自动代理</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启自动代理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Spring的JDBC模板技术"><a href="#Spring的JDBC模板技术" class="headerlink" title="Spring的JDBC模板技术"></a>Spring的JDBC模板技术</h2><h3 id="开发环境环境搭建"><a href="#开发环境环境搭建" class="headerlink" title="开发环境环境搭建"></a>开发环境环境搭建</h3><h4 id="1）引入相关依赖"><a href="#1）引入相关依赖" class="headerlink" title="1）引入相关依赖"></a>1）引入相关依赖</h4><p>6个Spring核心开发包</p>
<p>1个Spring-aop开发包</p>
<p>3个JDBC模板需要的jar包</p>
<ul>
<li>MySQL数据库驱动</li>
<li>Spring-jdbc.jar</li>
<li>Spring-tx.jar</li>
</ul>
<h4 id="2）编写模板类"><a href="#2）编写模板类" class="headerlink" title="2）编写模板类"></a>2）编写模板类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DriverManagerDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Spring管家提供了内置的连接池，如果不想使用内置连接池可以整合其他的连接池</span></span><br><span class="line">        DriverManagerDataSource dataSource = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">"jdbc:mysql://192.168.3.86/springdb"</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">"astro"</span>);</span><br><span class="line">        <span class="comment">// 创建模板类</span></span><br><span class="line">        JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate();</span><br><span class="line">        <span class="comment">// 设置连接池</span></span><br><span class="line">        template.setDataSource(dataSource);</span><br><span class="line">        <span class="comment">// 完成操作</span></span><br><span class="line">        template.update(<span class="string">"insert into t_account values (null,?,?)"</span>, <span class="string">"xinxing"</span>, <span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3）将JDBC连接池和模板类对象交给Spring管理"><a href="#3）将JDBC连接池和模板类对象交给Spring管理" class="headerlink" title="3）将JDBC连接池和模板类对象交给Spring管理"></a>3）将JDBC连接池和模板类对象交给Spring管理</h4><p>applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置JDBC数据库连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://192.168.3.86/springdb"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"astro"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置JDBC的模板类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4）修改模板类，使用IoC容器注入属性"><a href="#4）修改模板类，使用IoC容器注入属性" class="headerlink" title="4）修改模板类，使用IoC容器注入属性"></a>4）修改模板类，使用IoC容器注入属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">@ContextConfiguration("classpath:applicationContext.xml")</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCTest01</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span>(name = <span class="string">"jdbcTemplate"</span>)</span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"insert into t_account values (null,?,?)"</span>, <span class="string">"xinxing1"</span>, <span class="number">20000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5）整合DBCP连接池"><a href="#5）整合DBCP连接池" class="headerlink" title="5）整合DBCP连接池"></a>5）整合DBCP连接池</h4><p>导入两个依赖包:</p>
<ul>
<li>com.springsource.org.apache.commons.dbcp-x.x.x.osgi.jar</li>
<li>com.springsource.org.apache.commons.pool-x.x.x.jar</li>
</ul>
<p>在applicationContext.xml中配置DBCP连接池</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置DBCP连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp2.BasicDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://192.168.3.86/springdb"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"astro"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="6）整合C3P0连接池"><a href="#6）整合C3P0连接池" class="headerlink" title="6）整合C3P0连接池"></a>6）整合C3P0连接池</h4><p>导入依赖：</p>
<ul>
<li>com.springsource.com.mchange.v2.c3p0-x.x.x.x.jar</li>
</ul>
<p>在applicationContext.xml中配置C3P0连接池</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置C3P0连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://192.168.3.86/springdb"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"astro"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="JDBC模板类中的常用方法"><a href="#JDBC模板类中的常用方法" class="headerlink" title="JDBC模板类中的常用方法"></a>JDBC模板类中的常用方法</h3><h4 id="update-方法可以完成数据库的增删改操作"><a href="#update-方法可以完成数据库的增删改操作" class="headerlink" title="update()方法可以完成数据库的增删改操作"></a>update()方法可以完成数据库的增删改操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    jdbcTemplate.update(<span class="string">"insert into t_account values (null,?,?)"</span>, <span class="string">"xinxing1"</span>, <span class="number">20000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    jdbcTemplate.update(<span class="string">"delete from t_account where id = ?"</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    jdbcTemplate.update(<span class="string">"update t_account set name = ? where id = ?"</span>, <span class="string">"xx"</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="queryForObject完成对单行数据查询"><a href="#queryForObject完成对单行数据查询" class="headerlink" title="queryForObject完成对单行数据查询"></a>queryForObject完成对单行数据查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Account ac = jdbcTemplate.queryForObject(<span class="string">"select * from t_account where  id = ?"</span>, <span class="keyword">new</span> BeanMapper(), <span class="number">2</span>);</span><br><span class="line">    System.out.println(ac);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>POJO类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(Double money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>手动封装数据，创建BeanMapper类，实现RowMapper接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自己手动封装数据</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeanMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">Account</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 一行一行封装数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">mapRow</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Account ac = <span class="keyword">new</span> Account();</span><br><span class="line">        ac.setId(resultSet.getInt(<span class="number">1</span>));</span><br><span class="line">        ac.setName(resultSet.getString(<span class="number">2</span>));</span><br><span class="line">        ac.setMoney(resultSet.getDouble(<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">return</span> ac;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="query-完成多行数据的查询"><a href="#query-完成多行数据的查询" class="headerlink" title="query()完成多行数据的查询"></a>query()完成多行数据的查询</h4><p>用匿名内部类的方法封装数据，和上面的一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Account&gt; list = jdbcTemplate.query(<span class="string">"select * from t_account"</span>, <span class="keyword">new</span> RowMapper&lt;Account&gt;() &#123;</span><br><span class="line">        <span class="comment">// 手动封装数据，一行一行封装</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Account <span class="title">mapRow</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            Account ac = <span class="keyword">new</span> Account();</span><br><span class="line">            ac.setId(resultSet.getInt(<span class="number">1</span>));</span><br><span class="line">            ac.setName(resultSet.getString(<span class="number">2</span>));</span><br><span class="line">            ac.setMoney(resultSet.getDouble(<span class="number">3</span>));</span><br><span class="line">            <span class="keyword">return</span> ac;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Spring事务管理"><a href="#Spring事务管理" class="headerlink" title="Spring事务管理"></a>Spring事务管理</h2><h3 id="事务的基本概念"><a href="#事务的基本概念" class="headerlink" title="事务的基本概念"></a>事务的基本概念</h3><blockquote>
<p>1）事务：是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。</p>
<p>2）事务的特性ACID：</p>
<ul>
<li><strong>原子性（Atomicity）</strong>：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li>
<li><strong>一致性（Consistency）</strong>：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。<em>一致状态</em>的含义是数据库中的数据应满足完整性约束。</li>
<li><strong>隔离性（Isolation）</strong>：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li>
<li><strong>持久性（Durability）</strong>：已被提交的事务对数据库的修改应该永久保存在数据库中。</li>
</ul>
<p>3）如果不考虑隔离性，引发安全性问题</p>
<ul>
<li>读问题：<ul>
<li>脏读：一个事务对数据进行了修改，修改还没有提交时，另外一个事务也访问这个数据，然后使用了这个数据。</li>
<li>不可重复读：在一个事务内多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。在第一个事务中的两次读数据之间，由于第二个事务的修改，第一个事务两次读到的的数据可能不一样的，称为是不可重复读。</li>
<li>幻读：第一个事务对一个表中全部数据行进行了修改，同时第二个事务向表中插入一行新数据。第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</li>
</ul>
</li>
<li>写问题：<ul>
<li>丢失更新</li>
</ul>
</li>
</ul>
<p>4）如何解决安全性问题</p>
<ul>
<li>读问题：设置数据库隔离级别。</li>
<li>写问题：悲观锁和乐观锁。</li>
</ul>
<p>5）事务隔离级别</p>
<ul>
<li>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据。</li>
<li><strong>提交读(Read Committed)</strong>：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)。</li>
<li>可重复读(Repeated Read)：可重复读。在同一个事务内的查询都和事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻读。</li>
<li>串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读(Dirty Read)</th>
<th align="center">不可重复读(NonRepeatable Read)</th>
<th align="center">幻读(Phantom Read)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">未提交读(Read Uncommitted)</td>
<td align="center">可能</td>
<td align="center">可能</td>
<td align="center">可能</td>
</tr>
<tr>
<td align="center">提交读(Read Committed)</td>
<td align="center">不可能</td>
<td align="center">可能</td>
<td align="center">可能</td>
</tr>
<tr>
<td align="center">可重复读(Repeated Read)</td>
<td align="center">不可能</td>
<td align="center">不可能</td>
<td align="center">可能</td>
</tr>
<tr>
<td align="center">串行读(Serializable)</td>
<td align="center">不可能</td>
<td align="center">不可能</td>
<td align="center">不可能</td>
</tr>
</tbody></table>
</blockquote>
<h3 id="Spring事务管理相关API"><a href="#Spring事务管理相关API" class="headerlink" title="Spring事务管理相关API"></a>Spring事务管理相关API</h3><ol>
<li><strong>PlatformTransactionManager</strong>：平台事务管理器(真正管理事务的类)。该接口有具体的实现类，根据不同的持久层框架，需要选择不同的实现类。</li>
<li><strong>TransactionDefinition</strong>：事务定义信息(事务的隔离级别,传播行为,超时,只读)。</li>
<li><strong>ransactionStatus</strong>：事务的状态。</li>
</ol>
<p>PlatformTransactionManager根据TransactionDefinition定义的事务信息进行事务管理，在管理事务中产生一些状态记录到TransactionStatus中。</p>
<h4 id="PlatformTransactionManager实现类和常用方法"><a href="#PlatformTransactionManager实现类和常用方法" class="headerlink" title="PlatformTransactionManager实现类和常用方法"></a>PlatformTransactionManager实现类和常用方法</h4><p>实现类：</p>
<ul>
<li><strong>DataSourceTransactionManager</strong>：使用Spring的JDBC模板或者MyBatis框架时使用。</li>
<li><strong>HibernateTransactionManager</strong>：使用Hibernate框架时使用。</li>
</ul>
<p>常用方法：</p>
<ul>
<li>void commit(TransactionStatus status) </li>
<li>TransactionStatus getTransaction(TransactionDefinition definition) </li>
<li>void rollback(TransactionStatus status)</li>
</ul>
<h4 id="TransactionDefinition定义事务隔离级别和传播行为"><a href="#TransactionDefinition定义事务隔离级别和传播行为" class="headerlink" title="TransactionDefinition定义事务隔离级别和传播行为"></a>TransactionDefinition定义事务隔离级别和传播行为</h4><h5 id="事务隔离级别（Isolation）"><a href="#事务隔离级别（Isolation）" class="headerlink" title="事务隔离级别（Isolation）"></a><strong>事务隔离级别（Isolation）</strong></h5><ol>
<li><strong>static int ISOLATION_DEFAULT</strong> ：采用数据库默认隔离级别。</li>
<li>static int ISOLATION_READ_UNCOMMITTED ：未提交读。</li>
<li>static int ISOLATION_READ_COMMITTED ：提交读。</li>
<li>static int ISOLATION_REPEATABLE_READ ：可重复读。</li>
<li>static int ISOLATION_SERIALIZABLE ：串行读。</li>
</ol>
<h5 id="事务传播行为（Propagation）"><a href="#事务传播行为（Propagation）" class="headerlink" title="事务传播行为（Propagation）"></a><strong>事务传播行为（Propagation）</strong></h5><p>解决Service层之间方法调用时事务的管理问题。</p>
<p>假设业务层有两个方法A和B，A中调用B方法，则有：</p>
<ol>
<li><strong>PROPAGATION_REQUIRED</strong>（默认值）：保证有事务。A中有事务，使用A中的事务。如果没有，B就会开启一个新的事务，将A包含进来，默认值！！<br> . PROPAGATION_SUPPORTS    ：保证支持事务。A中有事务，使用A中的事务。如果A中没有事务，那么B也不使用事务。</li>
<li>PROPAGATION_MANDATORY ：强制使用事务。A中有事务，使用A中的事务。如果A没有事务抛出异常。</li>
<li>PROPAGATION_REQUIRES_NEW ：保证使用一个新的事务。A中有事务，将A中的事务挂起，B创建一个新的事务。</li>
<li>PROPAGATION_NOT_SUPPORTED ：保证不支持事务。A中有事务，将A中的事务挂起。</li>
<li>PROPAGATION_NEVER ：保证没有事务。A中有事务，抛出异常。</li>
<li>PROPAGATION_NESTED ：使用嵌套型事务。当A执行之后，就会在这个位置设置一个保存点，如果B没有问题执行通过，如果B出现异常，运行客户根据需求回滚(选择回滚到保存点或者是最初始状态)。</li>
</ol>
<h3 id="应用：搭建事务管理转账案例的环境"><a href="#应用：搭建事务管理转账案例的环境" class="headerlink" title="应用：搭建事务管理转账案例的环境"></a>应用：搭建事务管理转账案例的环境</h3><h4 id="1）创建Web工程，引入依赖："><a href="#1）创建Web工程，引入依赖：" class="headerlink" title="1）创建Web工程，引入依赖："></a>1）创建Web工程，引入依赖：</h4><ul>
<li>6个IOC核心开发包。</li>
<li>4个AOP包。</li>
<li>1个C3P0包。</li>
<li>1个MySQL驱动包</li>
<li>2个JDBC事务包。</li>
<li>1个整合JUnit测试包。</li>
</ul>
<h4 id="2）编写XML文件约束"><a href="#2）编写XML文件约束" class="headerlink" title="2）编写XML文件约束"></a>2）编写XML文件约束</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/tx/spring-tx.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3）创建包结构和类"><a href="#3）创建包结构和类" class="headerlink" title="3）创建包结构和类"></a>3）创建包结构和类</h4><p>Interface com.xinxing.tx.AccountService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xinxing.tx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> outId, <span class="keyword">int</span> inId, <span class="keyword">double</span> money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Class com.xinxing.tx.AccountServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xinxing.tx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(AccountDao accountDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> outId, <span class="keyword">int</span> inId, <span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 扣钱</span></span><br><span class="line">        accountDao.outMoney(outId, money);</span><br><span class="line">        <span class="comment">// 加钱</span></span><br><span class="line">        accountDao.inMoney(inId, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Interface com.xinxing.tx.AccountDao</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xinxing.tx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">outMoney</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">double</span> money)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inMoney</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">double</span> money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Class com.xinxing.tx.AccountDaoImpl</p>
<p>Spring提供了一个JdbcDaoSupport类里面可以根据数据库连接池自动为我们创建JdbcTemple模板类，可以直接继承该类简化开发。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xinxing.tx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//import org.springframework.jdbc.core.JdbcTemplate;</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.support.JdbcDaoSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*private JdbcTemplate jdbcTemplate;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;</span></span><br><span class="line"><span class="comment">        this.jdbcTemplate = jdbcTemplate;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扣钱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outMoney</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// jdbcTemplate.update()</span></span><br><span class="line">        <span class="keyword">this</span>.getJdbcTemplate().update(<span class="string">"update t_account set money = money - ? where id = ?"</span>, money, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加钱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inMoney</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.getJdbcTemplate().update(<span class="string">"update t_account set money = money + ? where id = ?"</span>, money, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JdbcDaoSupport类中可以根据数据库连接池创建JdbcTemplate模板类，所以在配置的时候只需要配置DataSource数据库连接池，然后将该类注入到JdbcDaoSupport的dataSource属性中去就可以。</p>
<h4 id="4）配置beans"><a href="#4）配置beans" class="headerlink" title="4）配置beans"></a>4）配置beans</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置业务层和持久层 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.xinxing.tx.AccountServiceImpl"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accountDao"</span> <span class="attr">ref</span>=<span class="string">"accountDao"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span> <span class="attr">class</span>=<span class="string">"com.xinxing.tx.AccountDaoImpl"</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name="jdbcTemplate" ref="jdbcTemplate"/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置C3P0连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://192.168.3.86/springdb"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"astro"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5）编写测试程序"><a href="#5）编写测试程序" class="headerlink" title="5）编写测试程序"></a>5）编写测试程序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">@ContextConfiguration("classpath:applicationContext.xml")</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span>(name = <span class="string">"accountService"</span>)</span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        accountService.pay(<span class="number">2</span>, <span class="number">3</span>, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>环境搭建完成。</p>
<h3 id="Spring事务管理分类"><a href="#Spring事务管理分类" class="headerlink" title="Spring事务管理分类"></a>Spring事务管理分类</h3><ol>
<li>Spring编程时事务管理（不推荐使用）：手动编写代码完成事务管理。</li>
<li>Spring声明式事务管理（底层采用AOP技术，推荐使用）：通过配置的方式完成事务管理。</li>
</ol>
<h3 id="Spring编程式事务管理"><a href="#Spring编程式事务管理" class="headerlink" title="Spring编程式事务管理"></a>Spring编程式事务管理</h3><p>Spring为了简化事务管理的代码，提供了模板类 TransactionTemplate，所以手动编程的方式来管理事务，只需要使用该模板类即可。</p>
<h4 id="1）配置平台事务管理器和连接池"><a href="#1）配置平台事务管理器和连接池" class="headerlink" title="1）配置平台事务管理器和连接池"></a>1）配置平台事务管理器和连接池</h4><p>Spring使用PlatformTransactionManager接口来管理事务，所以咱们需要使用到他的实现类：<strong>DataSourceTransactionManager</strong>或者<strong>HibernateTransactionManager</strong>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2）配置事务模板"><a href="#2）配置事务模板" class="headerlink" title="2）配置事务模板"></a>2）配置事务模板</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置事务管理的模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.transaction.support.TransactionTemplate"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionManager"</span> <span class="attr">ref</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3）在Service中注入事务管理模板"><a href="#3）在Service中注入事务管理模板" class="headerlink" title="3）在Service中注入事务管理模板"></a>3）在Service中注入事务管理模板</h4><p>AccountServiceImpl.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransactionTemplate</span><span class="params">(TransactionTemplate transactionTemplate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.transactionTemplate = transactionTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.itheima.demo1.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accountDao"</span> <span class="attr">ref</span>=<span class="string">"accountDao"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionTemplate"</span> <span class="attr">ref</span>=<span class="string">"transactionTemplate"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4）在Service层使用事务模板管理事务"><a href="#4）在Service层使用事务模板管理事务" class="headerlink" title="4）在Service层使用事务模板管理事务"></a>4）在Service层使用事务模板管理事务</h4><p>AccountServiceImpl.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注入事务模板对象</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransactionTemplate</span><span class="params">(TransactionTemplate transactionTemplate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.transactionTemplate = transactionTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(<span class="keyword">final</span> String out, <span class="keyword">final</span> String in, <span class="keyword">final</span> <span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">    transactionTemplate.execute(<span class="keyword">new</span> TransactionCallbackWithoutResult() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 事务的执行，如果没有问题则提交奥，如果出现异常则回滚</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doInTransactionWithoutResult</span><span class="params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 扣钱</span></span><br><span class="line">            accountDao.outMoney(out, money);</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 加钱</span></span><br><span class="line">            accountDao.inMoney(in, money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spring声明式事务管理（基于AOP）"><a href="#Spring声明式事务管理（基于AOP）" class="headerlink" title="Spring声明式事务管理（基于AOP）"></a>Spring声明式事务管理（基于AOP）</h3><p>声明式事务管理又分为两种：</p>
<ol>
<li>基于AspectJ的XML方式的事务管理</li>
<li>基于AspectJ的注解方式的事务管理</li>
</ol>
<h4 id="1-基于AspectJ的XML方式的事务管理"><a href="#1-基于AspectJ的XML方式的事务管理" class="headerlink" title="1. 基于AspectJ的XML方式的事务管理"></a>1. 基于AspectJ的XML方式的事务管理</h4><h5 id="1）配置事务管理器"><a href="#1）配置事务管理器" class="headerlink" title="1）配置事务管理器"></a>1）配置事务管理器</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置平台事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="2）配置事务增强功能（Advice）"><a href="#2）配置事务增强功能（Advice）" class="headerlink" title="2）配置事务增强功能（Advice）"></a>2）配置事务增强功能（Advice）</h5><p>Spring中事务管理的切面类是现成的，我们只需要在xml文件中配置一下就可以使用。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 声明式事务（采用XML配置文件的方式） --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 第一步 配置通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"myAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定哪些方法加事务，name属性可以使用通配符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"pay*"</span> <span class="attr">isolation</span>=<span class="string">"DEFAULT"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;tx:method&gt;</code>标签中可以有很多属性：</p>
<ul>
<li>name：必须有，指定哪些方法使用事务，可以用通配符表示如<code>pay*</code>表示所有以pay开头的方法。</li>
<li>propagation：事务传播行为。</li>
<li>isalation：事务隔离级别。</li>
<li>read-only：是否只读。</li>
<li>timout：超时信息。</li>
<li>rollback-for：发生哪些异常时回滚。</li>
<li>no-rollback-for：发生哪些异常时不回滚。</li>
</ul>
<h5 id="3）配置AOP"><a href="#3）配置AOP" class="headerlink" title="3）配置AOP"></a>3）配置AOP</h5><p>在<code>&lt;aop:config&gt;</code>标签中，如果是自己编写的切面类要使用<code>&lt;aop:aspect&gt;</code>配置切面，如果使用Spring提供的切面类要使用<code>&lt;aop:advisor&gt;</code>配置切面。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第二步 配置AOP --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果是自己编写的AOP，使用&lt;aop:aspect&gt;配置，如果使用Spring提供的AOP使用&lt;aop:advisor&gt;配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"myAdvice"</span> <span class="attr">pointcut</span>=<span class="string">"execution(public void com.xinxing.tx.AccountServiceImpl.pay(int,int,double))"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>事务配置完成。</p>
<h4 id="2-基于AspectJ的注解方式的事务管理（重点，最简单的方式）"><a href="#2-基于AspectJ的注解方式的事务管理（重点，最简单的方式）" class="headerlink" title="2. 基于AspectJ的注解方式的事务管理（重点，最简单的方式）"></a>2. 基于AspectJ的注解方式的事务管理（重点，最简单的方式）</h4><h5 id="1）配置事务管理器-1"><a href="#1）配置事务管理器-1" class="headerlink" title="1）配置事务管理器"></a>1）配置事务管理器</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置平台事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="2）开启注解事务"><a href="#2）开启注解事务" class="headerlink" title="2）开启注解事务"></a>2）开启注解事务</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启事务的注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="3）在类或方法上添加-Transactional注解"><a href="#3）在类或方法上添加-Transactional注解" class="headerlink" title="3）在类或方法上添加@Transactional注解"></a>3）在类或方法上添加@Transactional注解</h5><ul>
<li>如果在类上加@Transactional，类中的所有方法就都有事务了。</li>
<li>如果在方法上加@Transactional，只有该方法有事务。</li>
</ul>
<p>和<code>&lt;tx:method&gt;</code>标签一样@Transactional同样可以设置事务的属性。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>为什么重写equals方法就必须重写hashCode方法</title>
    <url>/2017/08/14/Java-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E5%B0%B1%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99hashCode%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>SUN的官方文档中规定，如果重定义equals方法，就必须重定义hashCode方法,以便用户可以将对象插入到散列(哈希)表中。</p>
<a id="more"></a>

<hr>
<p>在定义集合时往往会自定义覆盖hashCode和equals方法，是因为需要遵守equals的特性规则：</p>
<blockquote>
<p>equals与hashCode的定义必须一致，两个对象equals为true,就必须有相同的hashCode。反之则不成立。</p>
</blockquote>
<p>例如：如果定义的equals比较的是雇员ID，那么hashCode就需要散列ID，而不是雇员的姓名或住址，用不到哈希表可以不复写，除非你确认类的对象不会放入 HashSet,Hashtable,HashMap.等哈希表集合中。 即使暂时用不到哈希表，为其提供一个与equals一致的hashCode方法也没什么坏处，万一以后用到了呢？ 所以，在定义元素类时，为了避免不必要的麻烦，复写equals方法时通常有必要复写hashCode方法，以保证判定结果的一致性。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>如何创建并运行Java线程</title>
    <url>/2017/08/06/Java-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CJava%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>创建并运行Java线程的两种方法。</p>
<a id="more"></a>

<hr>
<h2 id="方法1-实现Runnable接口"><a href="#方法1-实现Runnable接口" class="headerlink" title="方法1: 实现Runnable接口"></a>方法1: 实现Runnable接口</h2><p>先来看一下Runnable接口，非常简单，里面只有一个run()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现了Runnble接口的类的对象是被用来创建线程的，start这个线程会导致对象的run方法在这个线程中被调用。</p>
<p>最常使用的方法是在Thread的构造方法中传入一个实现了Runnable接口的匿名内部类，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread myThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"myThread is running"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    myThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当新建的线程很多的时候，为了区分线程，需要给线程起个名字，可以在Thread构造方法中直接传入新建线程的名字，然后使用<code>Thread.currentThread().getName()</code>来得到这个线程的名字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread myThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">"myThread"</span>);</span><br><span class="line">    myThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：在启动线程时要使用<code>Thread.start()</code>，不能直接调用<code>Thread.run()</code>。使用start()方法JVM会新建一个线程然后使用新建的线程执行run()方法，如果直接调用run()方法，JVM不会新建线程，相当于在当前线程中执行Thread对象中的run()方法。</p>
<h2 id="方法2-创建Thread的子类"><a href="#方法2-创建Thread的子类" class="headerlink" title="方法2: 创建Thread的子类"></a>方法2: 创建Thread的子类</h2><p>Thread类实现了Runnable接口，我们可以创建Thread类的子类，然后重写run()方法，然后通过新建该类的对象来新建线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is MyThread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以创建一个Thread的匿名子类对象来新建线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"this is myThread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法3-实现Callable接口"><a href="#方法3-实现Callable接口" class="headerlink" title="方法3: 实现Callable接口"></a>方法3: 实现Callable接口</h2><p><code>java.util.concurrent.Callable</code>接口里面只有一个方法，跟Runnable接口很类似，Callable接口源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用这种方法创建线程分以下几步：</p>
<p>1.创建一个类实现Callable接口中的call()方法.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" is running"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.新建Callable对象，使用Callabe对象作为传入参数新建FutureTask对象，FutureTask对Callable的call()方法的返回值进行了封装，然后使用FutureTask对象作为参数新建Thread对象，然后使用Thread.start()方法启动线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadExample02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" is running"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Callable myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(myThread);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask, <span class="string">"myThread"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"子线程返回值 ："</span> + futureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三种方法对比"><a href="#三种方法对比" class="headerlink" title="三种方法对比"></a>三种方法对比</h2><p>使用时间Runnable，Callable接口的方法：</p>
<ul>
<li>优势：由于只实现了接口，所以还可以继承其他类。多个Thread可以共享同一个target对象，适合多个相同线程来处理同一份资源的情况，可以将CPU、代码和数据分开，形成清晰的模型。</li>
<li>劣势：编程复杂，访问当前线程必须使用Thread.currentThread()方法。</li>
</ul>
<p>使用继承Thread类的方法：</p>
<ul>
<li>优势：编程简单，访问当前线程直接使用this。</li>
<li>劣势：由于线程类已经继承了Thread类，所以不能再继承其他类。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java学习路线及阿里Java技术栈</title>
    <url>/2017/05/01/Java-%E8%BD%AC-Java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E5%8F%8A%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
    <content><![CDATA[<blockquote>
<p>本文转载自：<a href="https://blog.csdn.net/justloveyou_/article/details/69055978">Java知识图谱(附：阿里Java学习计划)</a></p>
</blockquote>
<p>本文主要描绘了Java基础学习过程，给出Java知识结构图，以及阿里Java岗学习计划，对Java学习爱好者、准备及将要从事Java开发方面的同学大有裨益。 </p>
<a id="more"></a>

<p>温馨提示：    </p>
<p><strong>由于CSDN对图片的压缩，导致图片观看效果不理想，建议大家通过右键“在新标签页打开图片”进行观看或直接把图片下载下来观看。</strong></p>
<blockquote>
<p>JVM</p>
<ol>
<li>内存模型(内存分为几部分？堆溢出、栈溢出原因及实例？线上如何排查？)</li>
<li>类加载机制</li>
<li>垃圾回收 </li>
</ol>
<p>Java基础</p>
<ul>
<li>什么是接口？什么是抽象类？区别是什么？</li>
<li>什么是序列化？</li>
<li>网络通信过程及实践</li>
<li>什么是线程？java线程池运行过程及实践（Executors）</li>
<li>java反射机制实践</li>
</ul>
<p>设计模式</p>
<ul>
<li>单例模式</li>
<li>原型模式</li>
<li>动态代理模式</li>
</ul>
<p>Spring</p>
<ul>
<li>什么是IOC</li>
<li>什么是AOP</li>
<li>spring事务管理：模板事务跟标注事务的区别及运理原理，什么是事务的传播机制</li>
</ul>
<p>数据库</p>
<ul>
<li>锁机制：锁的作用是什么，什么是乐观锁，什么是悲观锁，怎么实现 ？</li>
<li>索引：熟悉联合索引及sql执行计划</li>
</ul>
</blockquote>
<br />

<blockquote>
<ol>
<li><p>java内存模型<br>学习内容：学习java内存模型<br>实验方法：写一段代码触发内存溢出，分别触发栈内存和堆内存溢出，写一段代码导致持久代溢出。使用工具查看内存占用情况，学会如何分析内存溢出。</p>
</li>
<li><p>多线程<br>学习内容：多线程的NIO实现，IO实现（两种实现，阻塞，非阻塞）<br>试验方法：写一段代码实现多人聊天室，包括双人聊天和多人聊天。</p>
</li>
<li><p>动态代理（工厂模式）<br>（1）学习内容：JDK动态代理实现，<br>试验方法：一个方法的前置拦截，后置拦截，前置打印获取类名，方法名字，调用参数打印。后置打印返回结果（返回的结果是一个复杂的类）。<br>（2）学习内容：spring框架<br>试验方法：对某一包下，所有类的方法做切面，打印日志。</p>
</li>
<li><p>反射机制<br>学习内容：java的反射机制<br>试验方法：写一段程序，调用一个Bean下实现了标注（“autocall”）的方法</p>
</li>
<li><p>配置数据源<br>学习内容：配置数据源<br>实验方法：自己建一张表，引入数据库连接池，自动插入20万条数据，创建联合索引，验证走索引和不走索引的耗时，查看sql是否走索引，学会查看查询，计划实验，用标注式事务，编程式事务（查看编程式事务源码实现）；用乐观锁和悲观锁实现数据更新。</p>
</li>
</ol>
</blockquote>
<p><br />                           <img src="java%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84.png" alt="java知识结构"></p>
<p><img src="%E9%98%BF%E9%87%8C%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92-5154784.png" alt="阿里学习计划-5154784"></p>
<p><img src="%E9%98%BF%E9%87%8C%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%922.png" alt="阿里学习计划2"></p>
<p>​                                  </p>
<h4 id="学习需要知道："><a href="#学习需要知道：" class="headerlink" title="学习需要知道："></a><strong>学习需要知道：</strong></h4><p><strong>1、是什么</strong><br><strong>2、解决了什么问题</strong>  </p>
<p><strong>3、怎么实现的</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop集群搭建即HDFS基本操作</title>
    <url>/2017/08/01/%E5%A4%A7%E6%95%B0%E6%8D%AE-Hadoop%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E5%8D%B3HDFS%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>HDFS就是一个基于分布式、自动冗余、可以动态扩展的大硬盘，Hadoop目前不支持Java9最好装Java7或者Java8。</p>
<a id="more"></a>
<p>虚拟机系统：centos7</p>
<h4 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h4><p><code>rpm -ivh ./jdk….</code><br><code>rpm -qa | grep jdk</code></p>
<h4 id="Hadoop安装"><a href="#Hadoop安装" class="headerlink" title="Hadoop安装"></a>Hadoop安装</h4><p><code>tar –xvf ./hadoop-2.7.2.tar.gz</code><br><code>tar -zxvf filename.tar -C /specific dir</code></p>
<h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p><code>export JAVA_HOME=/usr/java/default</code><br><code>export $PATH:/usr/local/hadoop/bin:/usr/local/hadoop/sbin</code></p>
<h4 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h4><p><code>hostnamectl set-hostname NAME</code><br><code>ifconfig</code><br><code>/etc/sysconfig/network-scripts/ifcfg-enp0s3</code><br><code>service network restart</code><br><code>/etc/hosts</code><br><code>systemctl stop firewalld</code><br><code>systemctl disable firewalld</code></p>
<p>VirtualBox桥接模式虚拟机连外网配置:</p>
<table>
<thead>
<tr>
<th>步骤</th>
</tr>
</thead>
<tbody><tr>
<td>1.将各个虚拟机的网络连接方式设置成桥接，映射的网卡应为电脑上连网的那个网卡</td>
</tr>
<tr>
<td>2.修改/etc/sysconfig/network-scripts/ifcfg-enp0s3中如下配置：</td>
</tr>
<tr>
<td>BOOTPROTO=static</td>
</tr>
<tr>
<td>ip地址获取方式为静态ip（只改这个地方不够，重启后ip会变</td>
</tr>
<tr>
<td>IPADDR=192.168.3.100</td>
</tr>
<tr>
<td>将ip地址设置为和主机同网段ip</td>
</tr>
<tr>
<td>NETMASK=255.255.255.0</td>
</tr>
<tr>
<td>设置子网掩码</td>
</tr>
<tr>
<td>GATEWAY=192.168.3.1</td>
</tr>
<tr>
<td>设置网关（路由器地址）</td>
</tr>
<tr>
<td>3.在/etc/sysconfig/network中设置DNS1和DNS2</td>
</tr>
<tr>
<td>DNS1=192.168.3.1    路由器地址</td>
</tr>
<tr>
<td>DNS2=8.8.8.8</td>
</tr>
<tr>
<td>谷歌默认DNS地址</td>
</tr>
<tr>
<td>4.service network restart</td>
</tr>
<tr>
<td>重启网络服务</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hadoop集群</tag>
        <tag>HDFS</tag>
      </tags>
  </entry>
  <entry>
    <title>AMD平台装机方案</title>
    <url>/2018/03/25/%E5%85%B6%E4%BB%96-AMD%E5%B9%B3%E5%8F%B0%E8%A3%85%E6%9C%BA%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>基于AMD Ryzen系列CPU的装机方案。</p>
<a id="more"></a>

<hr>
<h3 id="AMD-Ryzen-7-2700X-装机方案"><a href="#AMD-Ryzen-7-2700X-装机方案" class="headerlink" title="AMD Ryzen 7 2700X 装机方案"></a>AMD Ryzen 7 2700X 装机方案</h3><table>
<thead>
<tr>
<th>组件</th>
<th>具体型号</th>
<th>京东 ¥</th>
<th>Amazon$</th>
<th>差价¥</th>
</tr>
</thead>
<tbody><tr>
<td>CPU</td>
<td>AMD 锐龙 7 2700X 处理器 8核16线程 AM4 接口 3.7GHz 盒装（自带CPU散热器）</td>
<td><a href="https://item.jd.com/6902456.html">2699</a></td>
<td><a href="https://www.amazon.com/AMD-Ryzen-Processor-Wraith-Cooler/dp/B07B428M7F/ref=sr_1_3?s=electronics&ie=UTF8&qid=1523660263&sr=1-3&keywords=amd+ryzen+7+2700x">329.00</a></td>
<td>633.54</td>
</tr>
<tr>
<td>内存</td>
<td>金士顿(Kingston)骇客神条 Predator系列 DDR4 3600 16G(8Gx2)套装</td>
<td><a href="http://item.jd.com/4533077.html#crumb-wrap">1899</a></td>
<td><a href="https://www.amazon.com/Kingston-Technology-HyperX-HX432C16PB3K2-16/dp/B01GCWQBQQ/ref=sr_1_3?s=electronics&ie=UTF8&qid=1523659856&sr=1-3&keywords=Predator%2BDDR4&th=1">290</a></td>
<td>79</td>
</tr>
<tr>
<td></td>
<td>金士顿(Kingston)骇客神条 Predator系列 DDR4 3600 32G(8Gx4)套装</td>
<td><a href="http://item.jd.com/4523079.html#crumb-wrap">3599</a></td>
<td><a href="https://www.amazon.com/Kingston-Technology-HyperX-HX432C16PB3K2-16/dp/B072JTLSYV/ref=sr_1_3?s=electronics&ie=UTF8&qid=1523659856&sr=1-3&keywords=Predator%2BDDR4&th=1">530.99</a></td>
<td>265.44</td>
</tr>
<tr>
<td>主板</td>
<td>玩家国度（REPUBLIC OF GAMERS ）ROG STRIX X470-F GAMING 声波雷达 游戏主板（AMD X470/socket AM4）</td>
<td><a href="https://item.jd.com/7252367.html">1999</a></td>
<td><a href="https://www.amazon.com/dp/B07C4PH429/ref=sr_1_1?s=electronics&ie=UTF8&qid=1523659761&sr=1-1&keywords=ROG+STRIX+X470-F+GAMING">214.99</a></td>
<td>649.29</td>
</tr>
<tr>
<td></td>
<td>华硕 （ASUS） PRIME X470-PRO主板“吃鸡”游戏主板（AMD X470/socket AM4)</td>
<td><a href="https://item.jd.com/7038904.html">1499</a></td>
<td><a href="https://www.amazon.com/dp/B07C57Q1XH/ref=sr_1_2?rps=1&ie=UTF8&qid=1523659655&sr=8-2&keywords=PRIME+X470-PRO">184.99</a></td>
<td>337.63</td>
</tr>
<tr>
<td>SSD</td>
<td>三星(SAMSUNG) 960 EVO 250G M.2 NVMe 固态硬盘</td>
<td><a href="http://item.jd.com/3739097.html#crumb-wrap">729</a></td>
<td><a href="https://www.amazon.com/Samsung-960-EVO-Internal-MZ-V6E250BW/dp/B01LYFKX41/ref=sr_1_fkmr0_1?s=electronics&ie=UTF8&qid=1523660332&sr=1-1-fkmr0&keywords=960+EVO+250G+M.2+NVMe">119.99</a></td>
<td>-24.3</td>
</tr>
<tr>
<td>电源</td>
<td>美商海盗船（USCorsair）额定650W RM650x 电源</td>
<td><a href="http://item.jd.com/1905013.html#crumb-wrap">869</a></td>
<td><a href="https://www.amazon.com/Corsair-RM650x-Modular-Supply-Certified/dp/B015YEIBJ8/ref=sr_1_3?s=electronics&ie=UTF8&qid=1523660482&sr=1-3&keywords=RM650x">119.99</a></td>
<td>115.7</td>
</tr>
<tr>
<td></td>
<td>安钛克（Antec）额定650W EAG650 PRO 模组电源</td>
<td><a href="http://item.jd.com/1331794.html#crumb-wrap">649</a></td>
<td><a href="https://www.amazon.com/Antec-VP-450-Power-Supply/dp/B0716GK7Z6/ref=sr_1_1?s=electronics&ie=UTF8&qid=1523660680&sr=1-1&keywords=antec%2Bpsu&th=1">55.54</a></td>
<td>300.2</td>
</tr>
</tbody></table>
<ul>
<li>电源应该选择海盗船650W电源</li>
<li>三星的SSD应该在国内买</li>
</ul>
<h3 id="AMD-Ryzen-7-1800X-装机方案"><a href="#AMD-Ryzen-7-1800X-装机方案" class="headerlink" title="AMD Ryzen 7 1800X 装机方案"></a>AMD Ryzen 7 1800X 装机方案</h3><table>
<thead>
<tr>
<th>组件</th>
<th>具体型号</th>
<th>京东 ¥</th>
<th>Amazon$</th>
</tr>
</thead>
<tbody><tr>
<td>CPU</td>
<td><a href="http://item.jd.com/3885175.html#crumb-wrap">锐龙 AMD Ryzen 7 1800X 处理器8核AM4接口 3.6GHz 盒装</a></td>
<td>2699</td>
<td><a href="https://www.amazon.com/AMD-Ryzen-1800X-Processor-YD180XBCAEWOF/dp/B06W9JXK4G/ref=sr_1_1?s=electronics&ie=UTF8&qid=1521996810&sr=1-1&keywords=amd+ryzen+7+1800x">329</a></td>
</tr>
<tr>
<td>CPU散热器</td>
<td><a href="http://item.jd.com/2329757.html">猫头鹰（NOCTUA）NH-D9L CPU散热器</a></td>
<td>439</td>
<td><a href="https://www.amazon.com/Noctua-Cooler-2011-0-2011-3-NH-D9L/dp/B00QCEWTAW/ref=sr_1_1?s=electronics&ie=UTF8&qid=1521997050&sr=1-1&keywords=nh-d9l">54.59</a></td>
</tr>
<tr>
<td>内存条</td>
<td><a href="http://item.jd.com/4533077.html#crumb-wrap">金士顿(Kingston)骇客神条 Predator系列 DDR4 3600 16G(8Gx2)套装</a></td>
<td>1899</td>
<td><a href="https://www.amazon.com/Kingston-Technology-HyperX-HX430C15PB3K2-32/dp/B071G19NY3/ref=sr_1_16?s=electronics&ie=UTF8&qid=1521997187&sr=1-16&keywords=kingston%2Bhyperx%2Bddr4&th=1">264.99</a></td>
</tr>
<tr>
<td>主板</td>
<td><a href="http://item.jd.com/3887247.html">华硕（ASUS）PRIME X370-PRO 主板（AMD X370/socket AM4）</a></td>
<td>999</td>
<td><a href="https://www.amazon.com/Prime-X370-Pro-Ryzen-Motherboard-Lighting/dp/B06WD4N297/ref=sr_1_2?s=electronics&ie=UTF8&qid=1521997360&sr=1-2&keywords=asus+x370">150.58</a></td>
</tr>
<tr>
<td>SSD</td>
<td><a href="http://item.jd.com/3739097.html#crumb-wrap">三星(SAMSUNG) 960 EVO 250G M.2 NVMe 固态硬盘</a></td>
<td>769</td>
<td><a href="https://www.amazon.com/Samsung-960-EVO-Internal-MZ-V6E500BW/dp/B01LYFKX41/ref=sr_1_1?s=electronics&ie=UTF8&qid=1521998647&sr=1-1&keywords=samsung%2B960%2Bevo&th=1">119.99</a></td>
</tr>
<tr>
<td>电源</td>
<td><a href="http://item.jd.com/1331794.html#crumb-wrap">安钛克（Antec）额定650W EAG650 PRO 模组电源</a></td>
<td>649</td>
<td><a href="https://www.amazon.com/Antec-VP-450-Power-Supply/dp/B0716GK7Z6/ref=sr_1_1?s=electronics&ie=UTF8&qid=1521997592&sr=1-1&keywords=antec%2Bpower%2Bsupply&th=1">53.09</a></td>
</tr>
<tr>
<td>机箱</td>
<td><a href="http://item.jd.com/2285652.html#crumb-wrap">追风者(PHANTEKS) 416PSC主动静音版 ATX全金属RGB水冷机箱</a></td>
<td>349</td>
<td><a href="https://www.amazon.com/dp/B01BLYB5HK/ref=psdc_572238_t2_B01NALAFU9?th=1">78.40</a></td>
</tr>
<tr>
<td>显卡</td>
<td>自己之前的GTX950</td>
<td></td>
<td></td>
</tr>
<tr>
<td>显示器</td>
<td><a href="http://item.jd.com/3446665.html?dist=jd">LG 27UD58-B 27英寸4K IPS硬屏 低闪屏滤蓝光LED背光液晶显示器</a></td>
<td>2499</td>
<td><a href="https://www.amazon.com/LG-Splitscreen-Accessories-Universal-Transformer/dp/B06XGHR38R/ref=sr_1_2_sspa?s=electronics&ie=UTF8&qid=1521998203&sr=1-2-spons&keywords=lg+27ud58-b&psc=1">342.99</a></td>
</tr>
<tr>
<td></td>
<td></td>
<td>10302</td>
<td>1393.27</td>
</tr>
</tbody></table>
<p>亚马逊上的价格比国内的价格总体便宜1500块左右。</p>
<h3 id="AMD-Threadripper-1950X-装机方案"><a href="#AMD-Threadripper-1950X-装机方案" class="headerlink" title="AMD Threadripper 1950X 装机方案"></a>AMD Threadripper 1950X 装机方案</h3><table>
<thead>
<tr>
<th>组件</th>
<th>具体型号</th>
<th>京东¥</th>
<th>Amazon$</th>
</tr>
</thead>
<tbody><tr>
<td>CPU</td>
<td><a href="http://item.jd.com/4620609.html">锐龙 AMD Threadripper （线程撕裂者）1950X 处理器16核32线程</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>CPU散热器</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>内存条</td>
<td><a href="http://item.jd.com/4533077.html#crumb-wrap">金士顿(Kingston)骇客神条 Predator系列 DDR4 3600 16G(8Gx2)套装</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>主板</td>
<td><a href="http://item.jd.com/4620627.html#none">华硕（ASUS）PRIME X399-A 主板（AMD X399/Socket TR4）</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>SSD</td>
<td><a href="http://item.jd.com/3739097.html#crumb-wrap">三星(SAMSUNG) 960 EVO 250G M.2 NVMe 固态硬盘</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>电源</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>机箱</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>显卡</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>显示器</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="比较好的机箱"><a href="#比较好的机箱" class="headerlink" title="比较好的机箱"></a>比较好的机箱</h3><table>
<thead>
<tr>
<th>机箱</th>
<th>价格¥</th>
</tr>
</thead>
<tbody><tr>
<td><a href="http://item.jd.com/3783597.html#crumb-wrap">Tt（Thermaltake）Core G3 黑色 薄型机箱（支持ATX主板/支持长显卡/垂直或平躺摆放/侧透/双U3 140*370*454mm</a></td>
<td>359</td>
</tr>
<tr>
<td><a href="http://item.jd.com/3595525.html#crumb-wrap">FD（Fractal Design）Node 202 Slim机箱 立卧两用/ITX主板/SFX电源/智能风道/支持310mm显卡 82*330*377mm</a></td>
<td>699</td>
</tr>
<tr>
<td><a href="http://item.jd.com/2285666.html">追风者(PHANTEKS) 416P黑色 中塔ATX侧透RGB水冷机箱(RGB呼吸灯控/配2把风扇/280水冷/防尘/背线/SSD)</a></td>
<td>299</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>Git使用指南</title>
    <url>/2017/03/28/%E5%85%B6%E4%BB%96-Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>Git是现在最流行的分布式版本控制系统，Git可以在离线状态下工作而且它的分支管理操作特别好用。本文是最精简的Git使用指南</p>
<a id="more"></a>

<p>在GitHub上新建一个库以后</p>
<p>当我们要在本地新建一个库，并且关联远程仓库时，执行一下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "# Blog" &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m "first commit"</span><br><span class="line">git remote add origin git@github.com:XinXingAstro/Blog.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>当我们要为现有库添加与远程仓库，并且提交现有代码到远程仓库时，执行一下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:XinXingAstro/Blog.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>操作git的更详细内容如下：</p>
<h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><p><a href="https://git-for-windows.github.io/">Windows版官网下载地址</a> 使用默认选项安装；<br>Mac上面直接安装xcode；<br>安装完成后配置全局用户名和邮件：<br><code>git config --global user.name &quot;Your Name&quot;  //--global是设置全局的username和useremail</code><br><code>git config --global user.email &quot;email@example.com&quot;</code><br>如果不进行全局设置，可以在每个库中单独设置:<br><code>git config --local --list  //查看本地库的属性，里面有username和useremail</code></p>
<h4 id="Git库的基本操作"><a href="#Git库的基本操作" class="headerlink" title="Git库的基本操作"></a>Git库的基本操作</h4><p>Git追踪<strong>文件修改</strong>而不是文件本身；<br>通过 <code>git --help</code> 来查看所有命令的说明；<br><code>.gitignore</code>文件会让git忽略一些文件<a href="https://github.com/github/gitignore">这里是官网的模版</a></p>
<p><code>ssh-keygen -t rsa -C &quot;youremail@address.com&quot;  //创建SSH密钥</code><br><code>git clone &lt;SSH Key/HTTPS&gt;  //克隆远程库，git支持https协议但是通过SSH克隆速度最快；从远程克隆的时候，git自动把本地的master分支和远程的master分支对应起来了，远程仓库的默认名称是origin</code><br><code>git init  //将项目文件夹初始化为git仓库</code><br><code>git pull  //将远程库的更改合并到当前分支，相当与git fetch origin dev +  git merge FETCH_HEAD</code><br><code>git remote  //管理正在追踪的远程仓库，-v 查看仓库名 地址 和fetch pull权限</code><br><code>git remote add origin &lt;SSH KEY/HTTPS&gt;  //关联远程仓库</code><br><code>git branch --set-upstream &lt;localbranch&gt; origin/&lt;branch&gt;  //建立本地分支和远程分支的关联</code><br><code>git push -u origin master  //将本地master分支推送到远程origin库； -u 参数会关联本地分支和远程分支</code><br><code>git checkout -b dev origin/dev  //本地创建和远程分支对应的分支</code><br><code>git status  //查看仓库当前的状态</code></p>
<p><img src="git.png" alt="git结构图">在我们编辑文件时，Git会将其视为已修改，我们分阶段修改的文件，可以一次性提交所有更改，循环重复。<br><code>git add &lt;filename&gt;  //将文件修改提交到暂存区</code><br><code>git commit -m &quot;本次提交的说明&quot;  //将暂存去的全部文件修改提交到当前分支</code><br><code>git diff &lt;filename&gt;  //查看具体的变更内容</code><br><code>diff</code>的输出格式可参考<a href="http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html">这个网站</a><br><code>git log  //显示从最近到最远的提交日志，加上 --pretty=oneline 参数每条日志仅占一行</code><br><code>git reflog  //查看引用日志</code></p>
<h4 id="撤销更改"><a href="#撤销更改" class="headerlink" title="撤销更改"></a>撤销更改</h4><p><code>git reset --hard HEAD~1  //将版本库回退到上一个版本，git用HEAD指针指向当前分支的当前版本，HEAD~n表示上n个版本</code><br><code>git reset --hard &lt;commit id&gt;  //将版本库设置成任意一个版本</code><br><code>git checkout -- &lt;filename&gt;  //丢弃工作区修改</code><br>如果修改提交到暂存区，想丢弃修改分两步：</p>
<p>1) <code>git reset HEAD &lt;filename&gt;  //将修改撤回到工作区</code><br>2) <code>git checkout -- &lt;filename&gt;  //丢弃工作区修改</code><br>如果修改提交到当前分支时，就要用版本回退撤销修改<br><code>git rm &lt;filename&gt;  //将文件从版本库中删除，如果文件没从版本库中删除，而是被误删，可以用 git checkout -- &lt;filename&gt; 将文件恢复到之前提交的最新版本</code></p>
<p><code>git config --global color.ui true  //让git显示颜色</code></p>
<h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p><code>git branch  //查看分支</code><br><code>git branch &lt;branchname&gt;  //创建分支</code><br><code>git checkout -b &lt;branchname&gt;  //创建+切换分支</code><br><code>git checkout &lt;branchname&gt;  //切换分支</code><br><code>git merge &lt;branchname&gt;  // 默认使用Fast forward模式合并某分支到当前分支，删除被合并分支后会丢掉分支信息。当</code>git<code>无法自动合并时，必须手动解决冲突，然后再提交合并</code><br><code>git merge --no-ff -m &quot;your commit mesage&quot; &lt;branchname&gt;  //使用普通模式合并分支，合并完成后可以看到合并历史</code><br><code>git branch -d &lt;branchname&gt;  //删除分支</code><br><code>git branch -D &lt;branchname&gt;  //强行删除没有被合并过的分支</code><br><code>git log --graph  //查看分支合并图，可以加</code>–pretty=oneline –abbrev-commit<code>参数</code><br>开发一个功能，修改一个bug，最好在原分支上新建一个分支进行操作，完成后再合并回原来分支</p>
<h4 id="tag操作"><a href="#tag操作" class="headerlink" title="tag操作"></a>tag操作</h4><p><code>git tag  //查看所有标签</code><br><code>git show &lt;tagname&gt;  //查看标签信息</code><br><code>git tag &lt;name&gt;  //name一般是版本号，就会在当前分支上的当前commit上打一个tag，tag就是指向某个commit的指针，tag不能移动</code><br><code>git tag &lt;commit id&gt;  //为指定commit打标签，可以用git log --pretty=oneline --abbrev-commit 查看历史commit id</code><br><code>git push origin &lt;tagname&gt;  //推送一个标签到远程库</code><br><code>git push origin --tags  //推送全部标签到远程库</code><br><code>git tag -a &lt;tagname&gt; -m &lt;tagmessage&gt; &lt;commit id&gt;  //-a指定标签名，-m指定说明文字</code><br><code>git tag -d &lt;tagname&gt;  //删除标签</code><br><code>git push origin :refs/tags/&lt;tagname&gt;  //删除一个远程标签，首先要删除本地标签，然后再用本命令删除远程标签</code></p>
<h4 id="保存工作现场操作"><a href="#保存工作现场操作" class="headerlink" title="保存工作现场操作"></a>保存工作现场操作</h4><p><code>git stash  //保存工作现场</code><br><code>git stash list  //查看工作现场列表</code><br><code>git stash apply stash@{n} //恢复第n个工作现场，恢复后stash内容不删除</code><br><code>git stash drop stash@{n}  //删除第n个工作现场</code><br><code>git stash pop //恢复工作现场并删除stash内容</code></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux设置开机自启程序方法</title>
    <url>/2018/07/13/%E5%85%B6%E4%BB%96-Linux%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E7%A8%8B%E5%BA%8F%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>本文讲解在Linux中设置开机自启动程序的方法。</p>
<a id="more"></a>

<hr>
<h3 id="方法1-在-etc-rc-local中添加启动脚本"><a href="#方法1-在-etc-rc-local中添加启动脚本" class="headerlink" title="方法1: 在/etc/rc.local中添加启动脚本"></a>方法1: 在<code>/etc/rc.local</code>中添加启动脚本</h3><p>注意<code>/etc/rc.local</code>文件默认是没有执行权限的，修改完要给<code>rc.local</code>添加执行权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmode +x &#x2F;etc&#x2F;rc.local</span><br></pre></td></tr></table></figure>

<h3 id="方法2-使用chkconfig添加自启动服务"><a href="#方法2-使用chkconfig添加自启动服务" class="headerlink" title="方法2: 使用chkconfig添加自启动服务"></a>方法2: 使用chkconfig添加自启动服务</h3><p>在<code>/etc/rc.d/init.d</code>中创建你的执行脚本，加入叫<code>myscript</code>，在这个脚本开头添加下面三行语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;bin&#x2F;bash  &#x2F;&#x2F;指定执行该脚本的程序</span><br><span class="line"># chkconfig: 2345 10 90  &#x2F;&#x2F;设置启动优先级</span><br><span class="line"># description:  &#x2F;&#x2F;对该服务的描述</span><br></pre></td></tr></table></figure>
<p>保存后对该脚本文件添加执行权限，然后在chkconfig中加入该服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x myscript</span><br><span class="line">chkconfig --add myscript</span><br></pre></td></tr></table></figure>

<p>查看<code>myscript</code>服务的启动情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chkconfig --list myscript</span><br></pre></td></tr></table></figure>

<p>启动<code>myscript</code>服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chkconfig myscript on</span><br></pre></td></tr></table></figure>

<p><code>chkconfig</code>命令的更详细内容可以参考：<a href="https://www.cnblogs.com/panjun-Donet/archive/2010/08/10/1796873.html">Linux下chkconfig命令详解</a></p>
<h3 id="方法3-使用systemctl添加系统服务"><a href="#方法3-使用systemctl添加系统服务" class="headerlink" title="方法3: 使用systemctl添加系统服务"></a>方法3: 使用<code>systemctl</code>添加系统服务</h3><p>参考：<a href="https://blog.csdn.net/yuanguozhengjust/article/details/38019923">在CentOS 7上利用systemctl添加自定义系统服务</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>MacOS里使用sed命令修改文件内容</title>
    <url>/2017/06/04/%E5%85%B6%E4%BB%96-MacOS%E9%87%8C%E4%BD%BF%E7%94%A8sed%E5%91%BD%E4%BB%A4%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<p>Mac上sed命令使用的一个小例子。</p>
<a id="more"></a>

<hr>
<p>Mac上-i命令和Linux上有一点不同：</p>
<blockquote>
<p>-i <u>extension</u></p>
<p>Edit files in-place, saving backups with the specified extension.  If a zero-length extension  is given, no backup will be saved.  It is not recommended to give a zero-length extension when  in-place editing files, as you risk corruption or partial content in situations where disk space is exhausted, etc.</p>
</blockquote>
<p>Mac上-i后面需要加一个字符串，表示备份文件的扩展名，如果添加一个空串，就不会有备份文件。</p>
<p>一个小例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">cd ~/myProjects/Blog</span><br><span class="line">hexo new $1</span><br><span class="line">if  [ "$2" ] ;then </span><br><span class="line">    sed -i "" "s/categories:/categories: $2/g" source/_posts/$1.md</span><br><span class="line">    mv source/_posts/$1.md source/_posts/$2/</span><br><span class="line">    open source/_posts/$2/$1.md</span><br><span class="line">else</span><br><span class="line">    open source/_posts/$1.md</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>用hexo创建一个博客文件，如果命令后面跟了分类信息，则将分类信息补充到categories: 后面。</p>
<p>注意：如果要在字符串中添加传入参数，则必须使用双引号，使用单引号无法引用传入参数。如上面如果将<code>&quot;s/categories:/categories: $2/g&quot;</code> 换成<code>&#39;s/categories:/categories: $2/g&#39;</code>，在文件中只会写入<code>categories: $2</code>。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac安装配置JDK</title>
    <url>/2017/08/12/%E5%85%B6%E4%BB%96-Mac%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEJDK/</url>
    <content><![CDATA[<p>Mac OS下安装配置JDK。</p>
<a id="more"></a>

<hr>
<h3 id="下载安装JDK"><a href="#下载安装JDK" class="headerlink" title="下载安装JDK"></a>下载安装JDK</h3><p>首先在Oracle官网下载Mac OS版本的JDK安装包安装，安装完成后可以通过<code>java -version</code>命令查看JDK版本号。</p>
<h3 id="配置JAVA-HOME-CLASS-PATH环境变量"><a href="#配置JAVA-HOME-CLASS-PATH环境变量" class="headerlink" title="配置JAVA_HOME, CLASS_PATH环境变量"></a>配置JAVA_HOME, CLASS_PATH环境变量</h3><p>Mac OS X 10.5以后的版本中Mac系统提供了Java框架支持，在系统中安装多个版本的JDK时，系统会自动检查最新的JDK然后使用其中的JAVA_HOME。如果想删除某个版本的JDK直接删除/Library/Java/JavaVirtualMachines中的某个jdk文件夹，系统会自动检测当前剩下的jdk，然后让/usr/libexec/java_home连接到当前最新版本的jdk中的home文件夹。</p>
<p>安装多个版本的JDK时可以使用下面指令列出所有JAVA_HOME</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/libexec/java_home -V</span><br></pre></td></tr></table></figure>

<p>用户的JAVA_HOME环境变量可以随意指定，也可以跟系统一样使用最新JDK版本的JAVA_HOEM，推荐如下设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=$(/usr/libexec/java_home)</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export CLASS_PATH=$JAVA_HOME/lib</span><br></pre></td></tr></table></figure>

<p>第二行是将jdk中的bin目录加到PATH环境变量中，由于jdk在安装时已经在/usr/bin下新建了alias所以可以不写。</p>
<p>JDK就配置完成了。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>在Win10上安装配置MySQL</title>
    <url>/2017/03/21/%E5%85%B6%E4%BB%96-Win10%E5%AE%89%E8%A3%85MySQL/</url>
    <content><![CDATA[<p>由于网上很多在Win10上的MySQL安装教程不对或者对新版MySQL不适用，所以我总结一下我的安装过程</p>
<a id="more"></a>
<h4 id="下载压缩文件并解压"><a href="#下载压缩文件并解压" class="headerlink" title="下载压缩文件并解压"></a>下载压缩文件并解压</h4><p>在官网下载最新的<a href="https://dev.mysql.com/downloads/mysql/">MySQL Community Server</a>这个版本是免费的（我下载的是mysql-5.7.17-winx64.zip）直接解压到你想要安装的目录，在MySQL的根目录下新建一个<code>my.ini</code>文件，将以下代码复制进去<strong>注意要将路径改为自己的安装路径</strong>：  </p>
<blockquote>
<p>[mysql]<br>default-character-set=utf8<br>[mysqld]<br>port = 3306<br>basedir=yourMySQLInstallPath<br>datadir=yourMySQLInstallPath\data<br>max_connections=200<br>character-set-server=utf8<br>default-storage-engine=INNODB</p>
</blockquote>
<h4 id="新建data目录"><a href="#新建data目录" class="headerlink" title="新建data目录"></a>新建data目录</h4><p>在MySQL根目录下新建data目录，如果没有这个目录在后面启动服务时会出现  <code>NET HELPMSG 3534</code> 错误；</p>
<h4 id="安装MySQL服务并初始化"><a href="#安装MySQL服务并初始化" class="headerlink" title="安装MySQL服务并初始化"></a>安装MySQL服务并初始化</h4><p>启动管理员命令行提示符（win + x  a ）， 进入MySQl根目录中的<code>bin</code>目录，执行以下命令：<br>&emsp;<code>mysql -install                           //提示Service successfully installed</code><br>&emsp;<code>mysql --initialize --user=root --console //最后会出现mysql的root用户默认登陆密码</code></p>
<h4 id="启动mysql服务"><a href="#启动mysql服务" class="headerlink" title="启动mysql服务:"></a>启动mysql服务:</h4><p>&emsp;<code>net start mysql</code></p>
<h4 id="登陆mysql："><a href="#登陆mysql：" class="headerlink" title="登陆mysql："></a>登陆mysql：</h4><p>&emsp;<code>mysql -u root -p      //会提示Enter password 输入刚才出现的登陆密码就可以登陆</code></p>
<h4 id="重设登陆密码"><a href="#重设登陆密码" class="headerlink" title="重设登陆密码"></a>重设登陆密码</h4><p>进入mysql环境后才可以重设密码：<br>&emsp;<code>set password = password(&#39;yournewpassword&#39;);</code></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>vim使用技巧</title>
    <url>/2017/06/05/%E5%85%B6%E4%BB%96-vim%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>vim常用技巧总结。</p>
<a id="more"></a>

<hr>
<h4 id="批量替换"><a href="#批量替换" class="headerlink" title="批量替换"></a>批量替换</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:s&#x2F;XXX&#x2F;YYY&#x2F;g</span><br><span class="line">其中XXX是需要替换的字符串,YYY是替换后的字符串</span><br><span class="line">以上这句只对当前行进行替换,如果需要进行全局替换,则要:</span><br><span class="line">%s&#x2F;XXX&#x2F;YYY&#x2F;g</span><br><span class="line"></span><br><span class="line">如果需要对指定部分进行替换,可以用V进入visual模式,再进行</span><br><span class="line">:s&#x2F;XXX&#x2F;YYY&#x2F;g</span><br><span class="line">或者可以指定行数对指定范围进行替换:</span><br><span class="line">:100, 102s&#x2F;XXX&#x2F;YYY&#x2F;g</span><br></pre></td></tr></table></figure>

<h4 id="Visual模式"><a href="#Visual模式" class="headerlink" title="Visual模式"></a>Visual模式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">visual模式就是选择模式</span><br><span class="line">v:进入单个字符选择模式</span><br><span class="line">V:进入行选择模式</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>关于MacOS环境变量和自定义命令</title>
    <url>/2018/03/17/%E5%85%B6%E4%BB%96-%E5%85%B3%E4%BA%8EMacOS%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p><strong>OSX系统环境变量加载顺序:</strong></p>
<blockquote>
<p><strong>/etc/profile</strong> -&gt; <strong>/etc/paths</strong> -&gt; <strong>~/.bash_porfile</strong> -&gt; <strong>~/.bash_login</strong> -&gt; <strong>~/.profile</strong> -&gt; <strong>~/.bashrc</strong></p>
</blockquote>
<a id="more"></a>

<h4 id="OS-X系统环境变量加载顺序"><a href="#OS-X系统环境变量加载顺序" class="headerlink" title="OS X系统环境变量加载顺序"></a>OS X系统环境变量加载顺序</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/profile</span><br><span class="line"></span><br><span class="line">/etc/paths</span><br><span class="line"></span><br><span class="line">~/.bash_porfile</span><br><span class="line"></span><br><span class="line">~/.bash_login</span><br><span class="line"></span><br><span class="line">~/.profile</span><br><span class="line"></span><br><span class="line">~/.bashrc</span><br></pre></td></tr></table></figure>


<p>/etc/profile 和 /etc/paths 系统启动时自动加载。</p>
<p><del>/.bash_profile，</del>/.bash_login，<del>/.profile按照从前往后的顺序读取，如果</del>/.bash_profile文件存在，则后面的几个文件就会被忽略不读了，如果~/.bash_profile文件不存在，才会以此类推读取后面的文件。</p>
<p>mac上面重启终端后 ~/.bashrc 不会自动加载。</p>
<h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p><code>echo $PATH</code> 查看当前环境变量</p>
<p><code>export VALUE_HOME = /.../.../...</code> 定义新环境变量是一个目录地址</p>
<p><code>export PATH=$VALUE_HOME/bin:$PATH</code> 将/bin目录加入环境变量的头部</p>
<p><code>source .bashrc</code> 执行修改过的配置文件，使环境变量生效</p>
<h4 id="自定义命令"><a href="#自定义命令" class="headerlink" title="自定义命令"></a>自定义命令</h4><h5 id="方法一：利用alias在配置文件中自定义命令"><a href="#方法一：利用alias在配置文件中自定义命令" class="headerlink" title="方法一：利用alias在配置文件中自定义命令"></a>方法一：利用alias在配置文件中自定义命令</h5><p><code>alias ll=&quot;ls -la&quot;</code> </p>
<p><code>alias nb=&quot;cd /Users/xinxing/myProjects/Blog;hexo new $1&quot;</code></p>
<h5 id="方法二：将存放自定义脚本的目录加入PATH变量中"><a href="#方法二：将存放自定义脚本的目录加入PATH变量中" class="headerlink" title="方法二：将存放自定义脚本的目录加入PATH变量中"></a>方法二：将存放自定义脚本的目录加入PATH变量中</h5><p><code>export PATH=$PATH:/Users/xinxing/.my_cmd</code></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title>删除BIOS中无用的启动项</title>
    <url>/2018/07/09/%E5%85%B6%E4%BB%96-%E5%88%A0%E9%99%A4BIOS%E4%B8%AD%E6%97%A0%E7%94%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E9%A1%B9/</url>
    <content><![CDATA[<p>在卸载完Ubuntu后，重启电脑发现Boot Menu中还有Ubuntu的启动项，这篇文章告诉你正确删除无用启动项的方法。</p>
<a id="more"></a>

<hr>
<h3 id="清除BIOS中无用的引导项"><a href="#清除BIOS中无用的引导项" class="headerlink" title="清除BIOS中无用的引导项"></a>清除BIOS中无用的引导项</h3><p>我们在装完Ubuntu系统后将其卸载，重启时发现BIOS的Boot Menu中还有Ubuntu系统的引导，Boot Menu中存在无用的启动项是因为电脑的EFI分区中存在该系统的引导文件，由于正常情况下EFI分区是不可见的，所以我们需要使用windows中的diskpart工具给EFI分区分配盘符，先让它在资源管理器中出现，然后我们再使用管理员权限进入EFI分区，删除分区中的多余文件，操作步骤如下：</p>
<p>1）右键开始菜单，运行，<code>diskpart</code></p>
<p>2）<code>list disk</code>列出所有磁盘信息。</p>
<p><img src="bios01-1179206.png" alt="bios01-1179206"></p>
<p>3）<code>select disk 0</code>要选中系统安装盘，我这里只有一个盘所以选0。</p>
<p>4）<code>list partition</code>列出磁盘中的分区信息。</p>
<p><img src="bios02.png" alt="bios02"></p>
<p>5）其中类型为系统的分区就是EFI分区一般大小再一二百MB，<code>select partition 2</code>选中EFI分区。</p>
<p>6）<code>assign letter=p</code>给EFI分区分配盘符，这样就可以在资源管理器中看到EFI分区了，但是这时候我们是无法进入该分区的，因为权限不够，我们需要使用管理员权限进入该分区。</p>
<p>7）可以用管理员权限随便打开一个软件，比如winrar，7z。然后通过该软件就可以进入该分区了。</p>
<p><img src="bios03.png" alt="bios03"></p>
<p>这是我用管理员权限进入EFI分区后7z，里面的内容，在EFI文件夹中会有一个ubuntu文件夹，或者grub文件夹，我们将其右键删除即可。</p>
<p>8）然后我们回到命令行输入<code>remove letter=p</code>删除EFI分区的盘符。</p>
<p>重启时进入Boot Menu，发现之前装过的Ubuntu系统引导就没有了。</p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/mtllyb/article/details/78635757">彻底删除Ubuntu EFI分区及启动项</a></p>
</blockquote>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>科学上网配置指南</title>
    <url>/2017/07/22/%E5%85%B6%E4%BB%96-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>科学上网配置和优化详细步骤。</p>
<a id="more"></a>

<hr>
<p>首先你需要有一个可以上外网的vpn，推荐安装CentOS 7系统，下面是基本配置过程。</p>
<p>1）安装ss</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install python-setuptools</span><br><span class="line">easy_install pip</span><br><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure>

<p>使用下面这条命令判断一下端口是否能用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssserver -p 443 -k password -m rc4-md5</span><br></pre></td></tr></table></figure>

<p>2）新建配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi ssconfig</span><br></pre></td></tr></table></figure>

<p>输入以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;::&quot;,</span><br><span class="line">    &quot;server_port&quot;:刚才测试成功的端口号,</span><br><span class="line">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;password&quot;:&quot;你的密码&quot;,</span><br><span class="line">    &quot;timeout&quot;:300,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</span><br><span class="line">    &quot;fast_open&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）设置开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;rc.d&#x2F;</span><br><span class="line">chmod +x rc.local</span><br><span class="line">vi rc.local</span><br></pre></td></tr></table></figure>

<p>添加下面一条语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssserver -c 配置文件觉得路径 -d start</span><br></pre></td></tr></table></figure>

<p>优化过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;sysctl.d&#x2F;local.conf</span><br></pre></td></tr></table></figure>

<p>添加下面内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># max open files</span><br><span class="line">fs.file-max &#x3D; 51200</span><br><span class="line"># max read buffer</span><br><span class="line">net.core.rmem_max &#x3D; 67108864</span><br><span class="line"># max write buffer</span><br><span class="line">net.core.wmem_max &#x3D; 67108864</span><br><span class="line"># default read buffer</span><br><span class="line">net.core.rmem_default &#x3D; 65536</span><br><span class="line"># default write buffer</span><br><span class="line">net.core.wmem_default &#x3D; 65536</span><br><span class="line"># max processor input queue</span><br><span class="line">net.core.netdev_max_backlog &#x3D; 4096</span><br><span class="line"># max backlog</span><br><span class="line">net.core.somaxconn &#x3D; 4096</span><br><span class="line"></span><br><span class="line"># resist SYN flood attacks</span><br><span class="line">net.ipv4.tcp_syncookies &#x3D; 1</span><br><span class="line"># reuse timewait sockets when safe</span><br><span class="line">net.ipv4.tcp_tw_reuse &#x3D; 1</span><br><span class="line"># turn off fast timewait sockets recycling</span><br><span class="line">net.ipv4.tcp_tw_recycle &#x3D; 0</span><br><span class="line"># short FIN timeout</span><br><span class="line">net.ipv4.tcp_fin_timeout &#x3D; 30</span><br><span class="line"># short keepalive time</span><br><span class="line">net.ipv4.tcp_keepalive_time &#x3D; 1200</span><br><span class="line"># outbound port range</span><br><span class="line">net.ipv4.ip_local_port_range &#x3D; 10000 65000</span><br><span class="line"># max SYN backlog</span><br><span class="line">net.ipv4.tcp_max_syn_backlog &#x3D; 4096</span><br><span class="line"># max timewait sockets held by system simultaneously</span><br><span class="line">net.ipv4.tcp_max_tw_buckets &#x3D; 5000</span><br><span class="line"># turn on TCP Fast Open on both client and server side</span><br><span class="line">net.ipv4.tcp_fastopen &#x3D; 3</span><br><span class="line"># TCP receive buffer</span><br><span class="line">net.ipv4.tcp_rmem &#x3D; 4096 87380 67108864</span><br><span class="line"># TCP write buffer</span><br><span class="line">net.ipv4.tcp_wmem &#x3D; 4096 65536 67108864</span><br><span class="line"># turn on path MTU discovery</span><br><span class="line">net.ipv4.tcp_mtu_probing &#x3D; 1</span><br><span class="line"></span><br><span class="line"># for high-latency network</span><br><span class="line">net.ipv4.tcp_congestion_control &#x3D; hybla</span><br><span class="line"></span><br><span class="line"># for low-latency network, use cubic instead</span><br><span class="line"># net.ipv4.tcp_congestion_control &#x3D; cubic</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sysctl --system</span><br></pre></td></tr></table></figure>

<p>然后重启系统就可以了。</p>
<p>参考：<a href="https://github.com/shadowsocks/shadowsocks/wiki">shadowsocks wiki</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>LRU Cache的原理及实现</title>
    <url>/2018/07/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-LRUCache%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>LRU近期最少使用缓存替换策略的原理及实现。</p>
<a id="more"></a>

<hr>
<blockquote>
<p>局部性原理：CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。</p>
<p>三种不同的局部性：</p>
<p>时间局部性（Temporal Locality）：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。程序循环、堆栈等是产生时间局部性的原因。</p>
<p>空间局部性（Spatial Locality）：在最近的将来将用到的信息很可能与现在正在使用的信息在空间地址上是临近的。</p>
<p>顺序局部性（Order Locality）：在典型程序中，除转移类指令外，大部分指令是顺序进行的。顺序执行和非顺序执行的比例大致是5:1。此外，对大型数组访问也是顺序的。指令的顺序执行、数组的连续存放等是产生顺序局部性的原因。</p>
</blockquote>
<blockquote>
<p>LRU(Least Recently Used)近期最少使用算法，是内存管理的一种页面置换算法，通常用与缓存的淘汰策略实现，由于缓存的内存非常宝贵，所以需要根据某种规则来剔除数据，保证内存不被撑满。</p>
</blockquote>
<p>常用的缓存Redis中可以设置内存的最大使用量，当内存的使用量超过这个最大值时，Redis就会实施淘汰策略，Redis中有6种常用的数据淘汰策略：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>volatile-lru</td>
<td>从已设置过期时间的数据集中挑选<strong>最近最少使用</strong>的数据淘汰</td>
</tr>
<tr>
<td>volatile-ttl</td>
<td>从已设置过期时间的数据集中挑选<strong>将要过期</strong>的数据淘汰</td>
</tr>
<tr>
<td>volatile-random</td>
<td>从已设置过期时间的数据集中<strong>随机挑选</strong>数据淘汰</td>
</tr>
<tr>
<td>allkeys-lru</td>
<td>从全部数据集中挑选<strong>最近最少使用</strong>的数据淘汰</td>
</tr>
<tr>
<td>allkeys-random</td>
<td>从全部数据集中<strong>随机挑选</strong>数据淘汰</td>
</tr>
<tr>
<td>no-enviction</td>
<td>禁止驱逐数据</td>
</tr>
</tbody></table>
<p>在Mybatis中也实现了使用LRU策略的缓存，我们通过Mybatis中的<a href="https://github.com/mybatis/mybatis-3/blob/master/src/main/java/org/apache/ibatis/cache/decorators/LruCache.java">LruCache.java</a>看一下LRU Cache的实现原理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.cache.decorators;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.cache.Cache;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Lru (least recently used) cache decorator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;Object, Object&gt; keyMap;</span><br><span class="line">  <span class="keyword">private</span> Object eldestKey;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(Cache delegate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    setSize(<span class="number">1024</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    keyMap = <span class="keyword">new</span> LinkedHashMap&lt;Object, Object&gt;(size, .<span class="number">75F</span>, <span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4267176411845948333L</span>;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Object, Object&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> tooBig = size() &gt; size;</span><br><span class="line">        <span class="keyword">if</span> (tooBig) &#123;</span><br><span class="line">          eldestKey = eldest.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tooBig;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    delegate.putObject(key, value);</span><br><span class="line">    cycleKeyList(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">removeObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate.removeObject(key);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cycleKeyList</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    keyMap.put(key, key);</span><br><span class="line">    <span class="keyword">if</span> (eldestKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">      delegate.removeObject(eldestKey);</span><br><span class="line">      eldestKey = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    keyMap.get(key); <span class="comment">//touch</span></span><br><span class="line">    <span class="keyword">return</span> delegate.getObject(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LruCache类中定义了三个属性，其中keyMap指向一个LinkedHashMap对象用来存储缓存数据，eldestKey指向当前数据中最老的节点（既LinkedHashMap中的头节点）。</p>
<p>在LurCache的构造方法中指定缓存的默认大小是1024个节点，在新建LinkedHashMap对象时指定了LinkedHashMap的容量（默认1024），负载因子0.75，并且指定元素的顺序为按<strong>访问顺序</strong>排序，在指定按照访问顺序排序后，我们每次调用get方法后都会将这次访问的节点移至链表末尾，不断访问可以形成按照访问顺序排序的链表，这就是为什么链表头节点是链表中最近最少访问的节点。（关于LinkedHashMap的实现原理请参考：LinkedHashMap底层实现原理）</p>
<p>在新建LinkedHashMap对象时，还重写了LinkedHashMap的removeEldestEntry方法，在该方法中判断，如果当前链表的节点数大于1024时就将tooBig变量设为true，然后将eldestKey指向LinkedHashMap的头节点，在cycleKeyList方法中每次向链表中put完节点后，都会检查eldestKey是否为null，如果不为null就删除eldestKey指向的节点，然后将eldestKey设为null，至此就实现了使用LRU策略的缓存。</p>
<blockquote>
<p>参考：<a href="http://ifeve.com/动手实现一个-lru-cache/#more-37981">动手实现一个 LRU cache</a></p>
<p><a href="http://wiki.jikexueyuan.com/project/java-collection/linkedhashmap.html">LinkedHashMap 的实现原理</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Leetcode题解</category>
      </categories>
  </entry>
  <entry>
    <title>Markdown设置字体、字号和颜色</title>
    <url>/2018/05/01/%E5%85%B6%E4%BB%96-%E8%BD%AC-markdown%E8%AE%BE%E7%BD%AE%E5%AD%97%E4%BD%93%E5%AD%97%E5%8F%B7%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<blockquote>
<p>文本转载自：<a href="https://blog.csdn.net/testcs_dn/article/details/45719357">CSDN-markdown编辑器语法——字体、字号与颜色</a></p>
</blockquote>
<a id="more"></a>

<hr>
<p><strong>Markdown</strong>是一种可以使用普通文本编辑器编写的标记语言，通过类似HTML的标记语法，它可以使普通文本内容具有一定的格式。但是它本身是不支持修改字体、字号与颜色等功能的！</p>
<p><strong>CSDN-markdown</strong>编辑器是其衍生版本，扩展了Markdown的功能（如表格、脚注、<strong>内嵌HTML</strong>等等）！对，就是<strong>内嵌HTML</strong>，接下来要讲的功能就需要使用<strong>内嵌HTML</strong>的方法来实现。</p>
<h3 id="字体、字号与颜色"><a href="#字体、字号与颜色" class="headerlink" title="字体、字号与颜色"></a>字体、字号与颜色</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;font face&#x3D;&quot;黑体&quot;&gt;我是黑体字&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font face&#x3D;&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font face&#x3D;&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font color&#x3D;#0099ff size&#x3D;7 face&#x3D;&quot;黑体&quot;&gt;color&#x3D;#0099ff size&#x3D;72 face&#x3D;&quot;黑体&quot;&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font color&#x3D;#00ffff size&#x3D;72&gt;color&#x3D;#00ffff&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font color&#x3D;gray size&#x3D;72&gt;color&#x3D;gray&lt;&#x2F;font&gt;</span><br></pre></td></tr></table></figure>

<p>Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3。</p>
<h3 id="呈现效果"><a href="#呈现效果" class="headerlink" title="呈现效果"></a>呈现效果</h3><hr>
<p><font face="黑体">我是黑体字</font><br><font face="微软雅黑">我是微软雅黑</font><br><font face="STCAIYUN">我是华文彩云</font><br><font color=#0099ff size=7 face="黑体">color=#0099ff size=72 face=”黑体”</font><br><font color=#00ffff size=72>color=#00ffff</font><br><font color=gray size=72>color=gray</font></p>
<h3 id="颜色名列表"><a href="#颜色名列表" class="headerlink" title="颜色名列表"></a>颜色名列表</h3><hr>
<table><tbody><tr><th>颜色名</th><th>十六进制颜色值</th><th>颜色</th></tr><tr><td><font color="AliceBlue">AliceBlue</font></td><td><font color="#F0F8FF">#F0F8FF</font></td><td bgcolor="#F0F8FF">rgb(240, 248, 255)</td></tr><tr><td><font color="AntiqueWhite">AntiqueWhite</font></td><td><font color="#FAEBD7">#FAEBD7</font></td><td bgcolor="#FAEBD7">rgb(250, 235, 215)</td></tr><tr><td><font color="Aqua">Aqua</font></td><td><font color="#00FFFF">#00FFFF</font></td><td bgcolor="#00FFFF">rgb(0, 255, 255)</td></tr><tr><td><font color="Aquamarine">Aquamarine</font></td><td><font color="#7FFFD4">#7FFFD4</font></td><td bgcolor="#7FFFD4">rgb(127, 255, 212)</td></tr><tr><td><font color="Azure">Azure</font></td><td><font color="#F0FFFF">#F0FFFF</font></td><td bgcolor="#F0FFFF">rgb(240, 255, 255)</td></tr><tr><td><font color="Beige">Beige</font></td><td><font color="#F5F5DC">#F5F5DC</font></td><td bgcolor="#F5F5DC">rgb(245, 245, 220)</td></tr><tr><td><font color="Bisque">Bisque</font></td><td><font color="#FFE4C4">#FFE4C4</font></td><td bgcolor="#FFE4C4">rgb(255, 228, 196)</td></tr><tr><td><font color="Black">Black</font></td><td><font color="#000000">#000000</font></td><td bgcolor="#000000">rgb(0, 0, 0)</td></tr><tr><td><font color="BlanchedAlmond">BlanchedAlmond</font></td><td><font color="#FFEBCD">#FFEBCD</font></td><td bgcolor="#FFEBCD">rgb(255, 235, 205)</td></tr><tr><td><font color="Blue">Blue</font></td><td><font color="#0000FF">#0000FF</font></td><td bgcolor="#0000FF">rgb(0, 0, 255)</td></tr><tr><td><font color="BlueViolet">BlueViolet</font></td><td><font color="#8A2BE2">#8A2BE2</font></td><td bgcolor="#8A2BE2">rgb(138, 43, 226)</td></tr><tr><td><font color="Brown">Brown</font></td><td><font color="#A52A2A">#A52A2A</font></td><td bgcolor="#A52A2A">rgb(165, 42, 42)</td></tr><tr><td><font color="BurlyWood">BurlyWood</font></td><td><font color="#DEB887">#DEB887</font></td><td bgcolor="#DEB887">rgb(222, 184, 135)</td></tr><tr><td><font color="CadetBlue">CadetBlue</font></td><td><font color="#5F9EA0">#5F9EA0</font></td><td bgcolor="#5F9EA0">rgb(95, 158, 160)</td></tr><tr><td><font color="Chartreuse">Chartreuse</font></td><td><font color="#7FFF00">#7FFF00</font></td><td bgcolor="#7FFF00">rgb(127, 255, 0)</td></tr><tr><td><font color="Chocolate">Chocolate</font></td><td><font color="#D2691E">#D2691E</font></td><td bgcolor="#D2691E">rgb(210, 105, 30)</td></tr><tr><td><font color="Coral">Coral</font></td><td><font color="#FF7F50">#FF7F50</font></td><td bgcolor="#FF7F50">rgb(255, 127, 80)</td></tr><tr><td><font color="CornflowerBlue">CornflowerBlue</font></td><td><font color="#6495ED">#6495ED</font></td><td bgcolor="#6495ED">rgb(100, 149, 237)</td></tr><tr><td><font color="Cornsilk">Cornsilk</font></td><td><font color="#FFF8DC">#FFF8DC</font></td><td bgcolor="#FFF8DC">rgb(255, 248, 220)</td></tr><tr><td><font color="Crimson">Crimson</font></td><td><font color="#DC143C">#DC143C</font></td><td bgcolor="#DC143C">rgb(220, 20, 60)</td></tr><tr><td><font color="Cyan">Cyan</font></td><td><font color="#00FFFF">#00FFFF</font></td><td bgcolor="#00FFFF">rgb(0, 255, 255)</td></tr><tr><td><font color="DarkBlue">DarkBlue</font></td><td><font color="#00008B">#00008B</font></td><td bgcolor="#00008B">rgb(0, 0, 139)</td></tr><tr><td><font color="DarkCyan">DarkCyan</font></td><td><font color="#008B8B">#008B8B</font></td><td bgcolor="#008B8B">rgb(0, 139, 139)</td></tr><tr><td><font color="DarkGoldenRod">DarkGoldenRod</font></td><td><font color="#B8860B">#B8860B</font></td><td bgcolor="#B8860B">rgb(184, 134, 11)</td></tr><tr><td><font color="DarkGray">DarkGray</font></td><td><font color="#A9A9A9">#A9A9A9</font></td><td bgcolor="#A9A9A9">rgb(169, 169, 169)</td></tr><tr><td><font color="DarkGreen">DarkGreen</font></td><td><font color="#006400">#006400</font></td><td bgcolor="#006400">rgb(0, 100, 0)</td></tr><tr><td><font color="DarkKhaki">DarkKhaki</font></td><td><font color="#BDB76B">#BDB76B</font></td><td bgcolor="#BDB76B">rgb(189, 183, 107)</td></tr><tr><td><font color="DarkMagenta">DarkMagenta</font></td><td><font color="#8B008B">#8B008B</font></td><td bgcolor="#8B008B">rgb(139, 0, 139)</td></tr><tr><td><font color="DarkOliveGreen">DarkOliveGreen</font></td><td><font color="#556B2F">#556B2F</font></td><td bgcolor="#556B2F">rgb(85, 107, 47)</td></tr><tr><td><font color="Darkorange">Darkorange</font></td><td><font color="#FF8C00">#FF8C00</font></td><td bgcolor="#FF8C00">rgb(255, 140, 0)</td></tr><tr><td><font color="DarkOrchid">DarkOrchid</font></td><td><font color="#9932CC">#9932CC</font></td><td bgcolor="#9932CC">rgb(153, 50, 204)</td></tr><tr><td><font color="DarkRed">DarkRed</font></td><td><font color="#8B0000">#8B0000</font></td><td bgcolor="#8B0000">rgb(139, 0, 0)</td></tr><tr><td><font color="DarkSalmon">DarkSalmon</font></td><td><font color="#E9967A">#E9967A</font></td><td bgcolor="#E9967A">rgb(233, 150, 122)</td></tr><tr><td><font color="DarkSeaGreen">DarkSeaGreen</font></td><td><font color="#8FBC8F">#8FBC8F</font></td><td bgcolor="#8FBC8F">rgb(143, 188, 143)</td></tr><tr><td><font color="DarkSlateBlue">DarkSlateBlue</font></td><td><font color="#483D8B">#483D8B</font></td><td bgcolor="#483D8B">rgb(72, 61, 139)</td></tr><tr><td><font color="DarkSlateGray">DarkSlateGray</font></td><td><font color="#2F4F4F">#2F4F4F</font></td><td bgcolor="#2F4F4F">rgb(47, 79, 79)</td></tr><tr><td><font color="DarkTurquoise">DarkTurquoise</font></td><td><font color="#00CED1">#00CED1</font></td><td bgcolor="#00CED1">rgb(0, 206, 209)</td></tr><tr><td><font color="DarkViolet">DarkViolet</font></td><td><font color="#9400D3">#9400D3</font></td><td bgcolor="#9400D3">rgb(148, 0, 211)</td></tr><tr><td><font color="DeepPink">DeepPink</font></td><td><font color="#FF1493">#FF1493</font></td><td bgcolor="#FF1493">rgb(255, 20, 147)</td></tr><tr><td><font color="DeepSkyBlue">DeepSkyBlue</font></td><td><font color="#00BFFF">#00BFFF</font></td><td bgcolor="#00BFFF">rgb(0, 191, 255)</td></tr><tr><td><font color="DimGray">DimGray</font></td><td><font color="#696969">#696969</font></td><td bgcolor="#696969">rgb(105, 105, 105)</td></tr><tr><td><font color="DodgerBlue">DodgerBlue</font></td><td><font color="#1E90FF">#1E90FF</font></td><td bgcolor="#1E90FF">rgb(30, 144, 255)</td></tr><tr><td><font color="Feldspar">Feldspar</font></td><td><font color="#D19275">#D19275</font></td><td bgcolor="#D19275">rgb(209, 146, 117)</td></tr><tr><td><font color="FireBrick">FireBrick</font></td><td><font color="#B22222">#B22222</font></td><td bgcolor="#B22222">rgb(178, 34, 34)</td></tr><tr><td><font color="FloralWhite">FloralWhite</font></td><td><font color="#FFFAF0">#FFFAF0</font></td><td bgcolor="#FFFAF0">rgb(255, 250, 240)</td></tr><tr><td><font color="ForestGreen">ForestGreen</font></td><td><font color="#228B22">#228B22</font></td><td bgcolor="#228B22">rgb(34, 139, 34)</td></tr><tr><td><font color="Fuchsia">Fuchsia</font></td><td><font color="#FF00FF">#FF00FF</font></td><td bgcolor="#FF00FF">rgb(255, 0, 255)</td></tr><tr><td><font color="Gainsboro">Gainsboro</font></td><td><font color="#DCDCDC">#DCDCDC</font></td><td bgcolor="#DCDCDC">rgb(220, 220, 220)</td></tr><tr><td><font color="GhostWhite">GhostWhite</font></td><td><font color="#F8F8FF">#F8F8FF</font></td><td bgcolor="#F8F8FF">rgb(248, 248, 255)</td></tr><tr><td><font color="Gold">Gold</font></td><td><font color="#FFD700">#FFD700</font></td><td bgcolor="#FFD700">rgb(255, 215, 0)</td></tr><tr><td><font color="GoldenRod">GoldenRod</font></td><td><font color="#DAA520">#DAA520</font></td><td bgcolor="#DAA520">rgb(218, 165, 32)</td></tr><tr><td><font color="Gray">Gray</font></td><td><font color="#808080">#808080</font></td><td bgcolor="#808080">rgb(128, 128, 128)</td></tr><tr><td><font color="Green">Green</font></td><td><font color="#008000">#008000</font></td><td bgcolor="#008000">rgb(0, 128, 0)</td></tr><tr><td><font color="GreenYellow">GreenYellow</font></td><td><font color="#ADFF2F">#ADFF2F</font></td><td bgcolor="#ADFF2F">rgb(173, 255, 47)</td></tr><tr><td><font color="HoneyDew">HoneyDew</font></td><td><font color="#F0FFF0">#F0FFF0</font></td><td bgcolor="#F0FFF0">rgb(240, 255, 240)</td></tr><tr><td><font color="HotPink">HotPink</font></td><td><font color="#FF69B4">#FF69B4</font></td><td bgcolor="#FF69B4">rgb(255, 105, 180)</td></tr><tr><td><font color="IndianRed">IndianRed</font></td><td><font color="#CD5C5C">#CD5C5C</font></td><td bgcolor="#CD5C5C">rgb(205, 92, 92)</td></tr><tr><td><font color="Indigo">Indigo</font></td><td><font color="#4B0082">#4B0082</font></td><td bgcolor="#4B0082">rgb(75, 0, 130)</td></tr><tr><td><font color="Ivory">Ivory</font></td><td><font color="#FFFFF0">#FFFFF0</font></td><td bgcolor="#FFFFF0">rgb(255, 255, 240)</td></tr><tr><td><font color="Khaki">Khaki</font></td><td><font color="#F0E68C">#F0E68C</font></td><td bgcolor="#F0E68C">rgb(240, 230, 140)</td></tr><tr><td><font color="Lavender">Lavender</font></td><td><font color="#E6E6FA">#E6E6FA</font></td><td bgcolor="#E6E6FA">rgb(230, 230, 250)</td></tr><tr><td><font color="LavenderBlush">LavenderBlush</font></td><td><font color="#FFF0F5">#FFF0F5</font></td><td bgcolor="#FFF0F5">rgb(255, 240, 245)</td></tr><tr><td><font color="LawnGreen">LawnGreen</font></td><td><font color="#7CFC00">#7CFC00</font></td><td bgcolor="#7CFC00">rgb(124, 252, 0)</td></tr><tr><td><font color="LemonChiffon">LemonChiffon</font></td><td><font color="#FFFACD">#FFFACD</font></td><td bgcolor="#FFFACD">rgb(255, 250, 205)</td></tr><tr><td><font color="LightBlue">LightBlue</font></td><td><font color="#ADD8E6">#ADD8E6</font></td><td bgcolor="#ADD8E6">rgb(173, 216, 230)</td></tr><tr><td><font color="LightCoral">LightCoral</font></td><td><font color="#F08080">#F08080</font></td><td bgcolor="#F08080">rgb(240, 128, 128)</td></tr><tr><td><font color="LightCyan">LightCyan</font></td><td><font color="#E0FFFF">#E0FFFF</font></td><td bgcolor="#E0FFFF">rgb(224, 255, 255)</td></tr><tr><td><font color="LightGoldenRodYellow">LightGoldenRodYellow</font></td><td><font color="#FAFAD2">#FAFAD2</font></td><td bgcolor="#FAFAD2">rgb(250, 250, 210)</td></tr><tr><td><font color="LightGrey">LightGrey</font></td><td><font color="#D3D3D3">#D3D3D3</font></td><td bgcolor="#D3D3D3">rgb(211, 211, 211)</td></tr><tr><td><font color="LightGreen">LightGreen</font></td><td><font color="#90EE90">#90EE90</font></td><td bgcolor="#90EE90">rgb(144, 238, 144)</td></tr><tr><td><font color="LightPink">LightPink</font></td><td><font color="#FFB6C1">#FFB6C1</font></td><td bgcolor="#FFB6C1">rgb(255, 182, 193)</td></tr><tr><td><font color="LightSalmon">LightSalmon</font></td><td><font color="#FFA07A">#FFA07A</font></td><td bgcolor="#FFA07A">rgb(255, 160, 122)</td></tr><tr><td><font color="LightSeaGreen">LightSeaGreen</font></td><td><font color="#20B2AA">#20B2AA</font></td><td bgcolor="#20B2AA">rgb(32, 178, 170)</td></tr><tr><td><font color="LightSkyBlue">LightSkyBlue</font></td><td><font color="#87CEFA">#87CEFA</font></td><td bgcolor="#87CEFA">rgb(135, 206, 250)</td></tr><tr><td><font color="LightSlateBlue">LightSlateBlue</font></td><td><font color="#8470FF">#8470FF</font></td><td bgcolor="#8470FF">rgb(132, 112, 255)</td></tr><tr><td><font color="LightSlateGray">LightSlateGray</font></td><td><font color="#778899">#778899</font></td><td bgcolor="#778899">rgb(119, 136, 153)</td></tr><tr><td><font color="LightSteelBlue">LightSteelBlue</font></td><td><font color="#B0C4DE">#B0C4DE</font></td><td bgcolor="#B0C4DE">rgb(176, 196, 222)</td></tr><tr><td><font color="LightYellow">LightYellow</font></td><td><font color="#FFFFE0">#FFFFE0</font></td><td bgcolor="#FFFFE0">rgb(255, 255, 224)</td></tr><tr><td><font color="Lime">Lime</font></td><td><font color="#00FF00">#00FF00</font></td><td bgcolor="#00FF00">rgb(0, 255, 0)</td></tr><tr><td><font color="LimeGreen">LimeGreen</font></td><td><font color="#32CD32">#32CD32</font></td><td bgcolor="#32CD32">rgb(50, 205, 50)</td></tr><tr><td><font color="Linen">Linen</font></td><td><font color="#FAF0E6">#FAF0E6</font></td><td bgcolor="#FAF0E6">rgb(250, 240, 230)</td></tr><tr><td><font color="Magenta">Magenta</font></td><td><font color="#FF00FF">#FF00FF</font></td><td bgcolor="#FF00FF">rgb(255, 0, 255)</td></tr><tr><td><font color="Maroon">Maroon</font></td><td><font color="#800000">#800000</font></td><td bgcolor="#800000">rgb(128, 0, 0)</td></tr><tr><td><font color="MediumAquaMarine">MediumAquaMarine</font></td><td><font color="#66CDAA">#66CDAA</font></td><td bgcolor="#66CDAA">rgb(102, 205, 170)</td></tr><tr><td><font color="MediumBlue">MediumBlue</font></td><td><font color="#0000CD">#0000CD</font></td><td bgcolor="#0000CD">rgb(0, 0, 205)</td></tr><tr><td><font color="MediumOrchid">MediumOrchid</font></td><td><font color="#BA55D3">#BA55D3</font></td><td bgcolor="#BA55D3">rgb(186, 85, 211)</td></tr><tr><td><font color="MediumPurple">MediumPurple</font></td><td><font color="#9370D8">#9370D8</font></td><td bgcolor="#9370D8">rgb(147, 112, 216)</td></tr><tr><td><font color="MediumSeaGreen">MediumSeaGreen</font></td><td><font color="#3CB371">#3CB371</font></td><td bgcolor="#3CB371">rgb(60, 179, 113)</td></tr><tr><td><font color="MediumSlateBlue">MediumSlateBlue</font></td><td><font color="#7B68EE">#7B68EE</font></td><td bgcolor="#7B68EE">rgb(123, 104, 238)</td></tr><tr><td><font color="MediumSpringGreen">MediumSpringGreen</font></td><td><font color="#00FA9A">#00FA9A</font></td><td bgcolor="#00FA9A">rgb(0, 250, 154)</td></tr><tr><td><font color="MediumTurquoise">MediumTurquoise</font></td><td><font color="#48D1CC">#48D1CC</font></td><td bgcolor="#48D1CC">rgb(72, 209, 204)</td></tr><tr><td><font color="MediumVioletRed">MediumVioletRed</font></td><td><font color="#C71585">#C71585</font></td><td bgcolor="#C71585">rgb(199, 21, 133)</td></tr><tr><td><font color="MidnightBlue">MidnightBlue</font></td><td><font color="#191970">#191970</font></td><td bgcolor="#191970">rgb(25, 25, 112)</td></tr><tr><td><font color="MintCream">MintCream</font></td><td><font color="#F5FFFA">#F5FFFA</font></td><td bgcolor="#F5FFFA">rgb(245, 255, 250)</td></tr><tr><td><font color="MistyRose">MistyRose</font></td><td><font color="#FFE4E1">#FFE4E1</font></td><td bgcolor="#FFE4E1">rgb(255, 228, 225)</td></tr><tr><td><font color="Moccasin">Moccasin</font></td><td><font color="#FFE4B5">#FFE4B5</font></td><td bgcolor="#FFE4B5">rgb(255, 228, 181)</td></tr><tr><td><font color="NavajoWhite">NavajoWhite</font></td><td><font color="#FFDEAD">#FFDEAD</font></td><td bgcolor="#FFDEAD">rgb(255, 222, 173)</td></tr><tr><td><font color="Navy">Navy</font></td><td><font color="#000080">#000080</font></td><td bgcolor="#000080">rgb(0, 0, 128)</td></tr><tr><td><font color="OldLace">OldLace</font></td><td><font color="#FDF5E6">#FDF5E6</font></td><td bgcolor="#FDF5E6">rgb(253, 245, 230)</td></tr><tr><td><font color="Olive">Olive</font></td><td><font color="#808000">#808000</font></td><td bgcolor="#808000">rgb(128, 128, 0)</td></tr><tr><td><font color="OliveDrab">OliveDrab</font></td><td><font color="#6B8E23">#6B8E23</font></td><td bgcolor="#6B8E23">rgb(107, 142, 35)</td></tr><tr><td><font color="Orange">Orange</font></td><td><font color="#FFA500">#FFA500</font></td><td bgcolor="#FFA500">rgb(255, 165, 0)</td></tr><tr><td><font color="OrangeRed">OrangeRed</font></td><td><font color="#FF4500">#FF4500</font></td><td bgcolor="#FF4500">rgb(255, 69, 0)</td></tr><tr><td><font color="Orchid">Orchid</font></td><td><font color="#DA70D6">#DA70D6</font></td><td bgcolor="#DA70D6">rgb(218, 112, 214)</td></tr><tr><td><font color="PaleGoldenRod">PaleGoldenRod</font></td><td><font color="#EEE8AA">#EEE8AA</font></td><td bgcolor="#EEE8AA">rgb(238, 232, 170)</td></tr><tr><td><font color="PaleGreen">PaleGreen</font></td><td><font color="#98FB98">#98FB98</font></td><td bgcolor="#98FB98">rgb(152, 251, 152)</td></tr><tr><td><font color="PaleTurquoise">PaleTurquoise</font></td><td><font color="#AFEEEE">#AFEEEE</font></td><td bgcolor="#AFEEEE">rgb(175, 238, 238)</td></tr><tr><td><font color="PaleVioletRed">PaleVioletRed</font></td><td><font color="#D87093">#D87093</font></td><td bgcolor="#D87093">rgb(216, 112, 147)</td></tr><tr><td><font color="PapayaWhip">PapayaWhip</font></td><td><font color="#FFEFD5">#FFEFD5</font></td><td bgcolor="#FFEFD5">rgb(255, 239, 213)</td></tr><tr><td><font color="PeachPuff">PeachPuff</font></td><td><font color="#FFDAB9">#FFDAB9</font></td><td bgcolor="#FFDAB9">rgb(255, 218, 185)</td></tr><tr><td><font color="Peru">Peru</font></td><td><font color="#CD853F">#CD853F</font></td><td bgcolor="#CD853F">rgb(205, 133, 63)</td></tr><tr><td><font color="Pink">Pink</font></td><td><font color="#FFC0CB">#FFC0CB</font></td><td bgcolor="#FFC0CB">rgb(255, 192, 203)</td></tr><tr><td><font color="Plum">Plum</font></td><td><font color="#DDA0DD">#DDA0DD</font></td><td bgcolor="#DDA0DD">rgb(221, 160, 221)</td></tr><tr><td><font color="PowderBlue">PowderBlue</font></td><td><font color="#B0E0E6">#B0E0E6</font></td><td bgcolor="#B0E0E6">rgb(176, 224, 230)</td></tr><tr><td><font color="Purple">Purple</font></td><td><font color="#800080">#800080</font></td><td bgcolor="#800080">rgb(128, 0, 128)</td></tr><tr><td><font color="Red">Red</font></td><td><font color="#FF0000">#FF0000</font></td><td bgcolor="#FF0000">rgb(255, 0, 0)</td></tr><tr><td><font color="RosyBrown">RosyBrown</font></td><td><font color="#BC8F8F">#BC8F8F</font></td><td bgcolor="#BC8F8F">rgb(188, 143, 143)</td></tr><tr><td><font color="RoyalBlue">RoyalBlue</font></td><td><font color="#4169E1">#4169E1</font></td><td bgcolor="#4169E1">rgb(65, 105, 225)</td></tr><tr><td><font color="SaddleBrown">SaddleBrown</font></td><td><font color="#8B4513">#8B4513</font></td><td bgcolor="#8B4513">rgb(139, 69, 19)</td></tr><tr><td><font color="Salmon">Salmon</font></td><td><font color="#FA8072">#FA8072</font></td><td bgcolor="#FA8072">rgb(250, 128, 114)</td></tr><tr><td><font color="SandyBrown">SandyBrown</font></td><td><font color="#F4A460">#F4A460</font></td><td bgcolor="#F4A460">rgb(244, 164, 96)</td></tr><tr><td><font color="SeaGreen">SeaGreen</font></td><td><font color="#2E8B57">#2E8B57</font></td><td bgcolor="#2E8B57">rgb(46, 139, 87)</td></tr><tr><td><font color="SeaShell">SeaShell</font></td><td><font color="#FFF5EE">#FFF5EE</font></td><td bgcolor="#FFF5EE">rgb(255, 245, 238)</td></tr><tr><td><font color="Sienna">Sienna</font></td><td><font color="#A0522D">#A0522D</font></td><td bgcolor="#A0522D">rgb(160, 82, 45)</td></tr><tr><td><font color="Silver">Silver</font></td><td><font color="#C0C0C0">#C0C0C0</font></td><td bgcolor="#C0C0C0">rgb(192, 192, 192)</td></tr><tr><td><font color="SkyBlue">SkyBlue</font></td><td><font color="#87CEEB">#87CEEB</font></td><td bgcolor="#87CEEB">rgb(135, 206, 235)</td></tr><tr><td><font color="SlateBlue">SlateBlue</font></td><td><font color="#6A5ACD">#6A5ACD</font></td><td bgcolor="#6A5ACD">rgb(106, 90, 205)</td></tr><tr><td><font color="SlateGray">SlateGray</font></td><td><font color="#708090">#708090</font></td><td bgcolor="#708090">rgb(112, 128, 144)</td></tr><tr><td><font color="Snow">Snow</font></td><td><font color="#FFFAFA">#FFFAFA</font></td><td bgcolor="#FFFAFA">rgb(255, 250, 250)</td></tr><tr><td><font color="SpringGreen">SpringGreen</font></td><td><font color="#00FF7F">#00FF7F</font></td><td bgcolor="#00FF7F">rgb(0, 255, 127)</td></tr><tr><td><font color="SteelBlue">SteelBlue</font></td><td><font color="#4682B4">#4682B4</font></td><td bgcolor="#4682B4">rgb(70, 130, 180)</td></tr><tr><td><font color="Tan">Tan</font></td><td><font color="#D2B48C">#D2B48C</font></td><td bgcolor="#D2B48C">rgb(210, 180, 140)</td></tr><tr><td><font color="Teal">Teal</font></td><td><font color="#008080">#008080</font></td><td bgcolor="#008080">rgb(0, 128, 128)</td></tr><tr><td><font color="Thistle">Thistle</font></td><td><font color="#D8BFD8">#D8BFD8</font></td><td bgcolor="#D8BFD8">rgb(216, 191, 216)</td></tr><tr><td><font color="Tomato">Tomato</font></td><td><font color="#FF6347">#FF6347</font></td><td bgcolor="#FF6347">rgb(255, 99, 71)</td></tr><tr><td><font color="Turquoise">Turquoise</font></td><td><font color="#40E0D0">#40E0D0</font></td><td bgcolor="#40E0D0">rgb(64, 224, 208)</td></tr><tr><td><font color="Violet">Violet</font></td><td><font color="#EE82EE">#EE82EE</font></td><td bgcolor="#EE82EE">rgb(238, 130, 238)</td></tr><tr><td><font color="VioletRed">VioletRed</font></td><td><font color="#D02090">#D02090</font></td><td bgcolor="#D02090">rgb(208, 32, 144)</td></tr><tr><td><font color="Wheat">Wheat</font></td><td><font color="#F5DEB3">#F5DEB3</font></td><td bgcolor="#F5DEB3">rgb(245, 222, 179)</td></tr><tr><td><font color="White">White</font></td><td><font color="#FFFFFF">#FFFFFF</font></td><td bgcolor="#FFFFFF">rgb(255, 255, 255)</td></tr><tr><td><font color="WhiteSmoke">WhiteSmoke</font></td><td><font color="#F5F5F5">#F5F5F5</font></td><td bgcolor="#F5F5F5">rgb(245, 245, 245)</td></tr><tr><td><font color="Yellow">Yellow</font></td><td><font color="#FFFF00">#FFFF00</font></td><td bgcolor="#FFFF00">rgb(255, 255, 0)</td></tr><tr><td><font color="YellowGreen">YellowGreen</font></td><td><font color="#9ACD32">#9ACD32</font></td><td bgcolor="#9ACD32">rgb(154, 205, 50)</td></tr></tbody></table>]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>什么是UTF-8编码</title>
    <url>/2018/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E4%BB%80%E4%B9%88%E6%98%AFUTF-8%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<p>UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字元编码，也是一种前缀码。它可以用来表示Unicode标准中的任何字元，且其编码中的第一个位元组仍和ASCII相容，这使得原来处理ASCII字元的软件无需或只须做少部分修改，即可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。</p>
<a id="more"></a>

<hr>
<p>在计算机体系里，无论是硬盘中的文件，网络上的页面，还是我们的电子邮件，所有的数据在底层都是一堆01串，为什么数据都可以按照10串的形式存储或者传输，就是因为有编码的存在，我们平常所说的编码方式就是一种将我们熟悉的符号翻译成对应的01串的规则。</p>
<p>ASCII（<strong>A</strong>merican <strong>S</strong>tandard <strong>C</strong>ode for <strong>I</strong>nformation <strong>I</strong>nterchange，<strong>美国信息交换标准代码</strong> ）是上世纪60年代美国制定的一套编码规则，一直沿用至今。ASCII码中一共定义了128个字符对应的编码，如下图所示：</p>
<p><img src="asciifull.gif" alt="asciifull"></p>
<p>对于英语，128个字符是够用了，但是对于其他语言如法语、俄语、汉语，128个字符是远远不够用的，很多欧洲国家都对ASCII码进行了扩展，但是不同的国家使用不同的编码，我们想要打开不同国家的文件，就需要知道这个文件对应的编码方式，否则就会出现乱码，如果有一种编码，将世界上所有的符号都纳入其中，给每一个符号定义一个独一无二的编码，那就会解决乱码的问题了，Unicode码就是这样的一种符号编码，Unicode是一个很大的集合，可以容纳100多万个符号，每个符号对应唯一的编码。由于定义的符号数量巨大，所以每个符号的编码可能需要1~4个字节来存储。</p>
<p>Unicode只是一个编码集合，它定义了符号和编码的对应关系，但是没有定义怎样存储这些符号，UTF-8中定义了这些符号应该怎样存储。</p>
<p>UTF-8是互联网上使用最广泛的一种Unicode的实现方式，它是一种变长的编码方式可以使用1~4表示一个符号，根据不同的符号变化字节的长度，UTF-8的编码规则如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">码点位数</th>
<th>码点范围</th>
<th>字节序列</th>
<th>Byte1</th>
<th>Byte2</th>
<th>Byte3</th>
<th>Byte4</th>
<th>Byte5</th>
<th>Byte6</th>
</tr>
</thead>
<tbody><tr>
<td align="center">7</td>
<td>0000~007F</td>
<td>1</td>
<td>0xxxxxxx</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">11</td>
<td>0080~07FF</td>
<td>2</td>
<td>110xxxxx</td>
<td>10xxxxxx</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">16</td>
<td>0800~FFFF</td>
<td>3</td>
<td>1110xxxx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">21</td>
<td>10000~1FFFFF</td>
<td>4</td>
<td>11110xxx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">26</td>
<td>200000~3FFFFFF</td>
<td>5</td>
<td>111110xx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
<td></td>
</tr>
<tr>
<td align="center">31</td>
<td>4000000~7FFFFFFF</td>
<td>6</td>
<td>1111110x</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
</tr>
</tbody></table>
<p>上表中x代表可以存储编码的位，由上表可以看到UTF-8的编码规则非常简单:</p>
<ol>
<li>对于单字节的符号，字节的第一位设置为0，后买7为是这个符号的Unicode码。因此对于英语，UTF-8和ASCII码是相同的。</li>
<li>对于n &gt; 1个字节的符号，第一个字节最高位1的个数代表编码的字节数，剩下的字节每个字节以10开头。</li>
</ol>
<p>有了UTF-8定义的编码存储方式，我们拿到一段编码后就能清楚的看到这段编码由多少字节组成，每一个字节中编码的内容，得到字符编码后，通过查询Unicode编码表我们就可以得知这个符号是什么了。</p>
<p>参考：<a href="https://zh.wikipedia.org/wiki/UTF-8">UTF-8</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">字符编码笔记：ASCII，Unicode 和 UTF-8</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>同步、异步、阻塞、非阻塞总结</title>
    <url>/2018/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本文对于同步、异步、阻塞和非阻塞等概念进行总结。</p>
<a id="more"></a>

<hr>
<p>对于一个线程调用一个方法，同步异步说的是这个方法的返回方式，既方法和线程之间的通信机制，而阻塞非阻塞说的是这个线程在发起这个调用后的执行状态。</p>
<p><strong>同步(Synchronization)</strong>：这个方法在没有得到结果之前不返回，既等到方法执行完以后再返回。</p>
<p><strong>异步(Asynchronization)</strong>：这个方法被调用后立即返回，等到方法执行完后会通知线程来处理这个方法执行结果。</p>
<p><strong>阻塞(Blocking)</strong>：线程在调用这个方法后原地等待(挂起)，等到这个方法返回后再继续执行。</p>
<p><strong>非阻塞(Non-blocking)</strong>：线程在调用这个方法后继续向下执行。</p>
<p>举一个例子：</p>
<p>小明想订一张机票，所以他给航空公司客服打电话。</p>
<p>如果客服是<strong>同步</strong>通信机制，那就就会告诉他，你等一会儿不要挂电话，查到结果以后告诉你。</p>
<p>如果客服是<strong>异步</strong>通信机制，那么就会告诉他，我现在会去查，我查到以后打电话通知你。</p>
<p>如果小明是<strong>阻塞式</strong>的，那么他在问完客服以后就什么都不干，一直等待，直到客服返回给他结果，他再进行处理。</p>
<p>如果小明是<strong>非阻塞式</strong>的，那么他在打完电话后就去干其他事，直到客服给他回电话时或者查到结果时，他再回来处理。</p>
<p>上面小明的状态和客服的状态两两组合就会出现四种模式：</p>
<p><strong>同步阻塞</strong>：小明问完后拿着电话什么都不干等结果，客服查到结果后再告诉他。</p>
<p><strong>同步非阻塞</strong>：小明问完后拿着电话干其他事，时不时检查一下客服是否返回结果。</p>
<p><strong>异步阻塞</strong>：小明问完后挂了电话在电话前等待，什么都不做，客服查到结果后打电话通知他。</p>
<p><strong>异步非阻塞</strong>：小明问完后挂了电话继续干其他事，客服查到结果后打电话通知他。</p>
<p>Node.js就使用异步非阻塞的I/O模型。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>优质技术博客推荐</title>
    <url>/2018/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E4%BC%98%E8%B4%A8%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>记录了一些优质的技术博客。</p>
<a id="more"></a>

<p><a href="https://blog.csdn.net/jackfrued">骆昊的技术专栏</a></p>
<p><a href="http://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html">计算机网络之面试常考题</a></p>
<p><a href="http://blog.51cto.com/hyman1994/1663623">数据库常见面试题</a></p>
<p><a href="https://blog.csdn.net/hectorhua/article/details/13767361">数据库常见笔试面试题</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/23713529">常见面试题整理—数据库篇（每位开发者必备）</a></p>
<p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL索引背后的数据结构及算法原理</a></p>
<p><a href="https://blog.csdn.net/v_JULY_v/article/details/6279498">十道海量数据处理面试题与十个方法大总结</a></p>
<p><a href="https://www.nowcoder.com/discuss/68802?type=0&order=0&pos=3&page=1">2018校招笔试真题汇总</a></p>
<p><a href="https://blog.csdn.net/acingdreamer/article/details/78479476">2018秋招面经-后端开发</a></p>
<p><a href="https://blog.csdn.net/u013007900/article/details/79008993">技术面试的系统设计题</a></p>
<p><a href="https://blog.csdn.net/justloveyou_">Rico’s Blogs</a></p>
<p><a href="https://blog.csdn.net/u012813201">LingLee</a></p>
<p><a href="https://blog.csdn.net/xuhuanfeng232">曾经沧海难为水，除却巫山不是云</a></p>
<p><a href="http://www.cnblogs.com/JavaArchitect/">hsm_computer</a></p>
<p><a href="http://www.importnew.com/">ImportNew</a></p>
<p><a href="http://ifeve.com/">并发编程网</a></p>
<p><a href="http://blog.codinglabs.org/">CodingLabs</a></p>
<p><a href="http://design-patterns.readthedocs.io/zh_CN/latest/">图说设计模式</a></p>
<p><a href="https://blog.csdn.net/quinnnorris">QuinnNorris的博客</a></p>
<p><a href="https://www.cnblogs.com/xrq730/">五月的仓颉</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>并发、并行、串行总结</title>
    <url>/2018/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E4%B8%B2%E8%A1%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本文对并发、并行、串行的概念进行总结。</p>
<a id="more"></a>

<hr>
<p><img src="ConcurrentAndParallel.jpg" alt="ConcurrentAndParallel"></p>
<p><strong>并发</strong>是两队人交替使用一台咖啡机，<strong>并行</strong>是两队人使用两台咖啡机，<strong>串行</strong>是一个队列使用一台咖啡机。一个<strong>并发程序</strong>如果可以被多个CPU同时执行，那么就说这个并发程序可以被并行的执行，如果只有一个CPU那么就不能叫并行执行，因为并发程序中的多个线程是被这一个CPU轮流切换的执行。如果这个CPU不支持轮流切换的执行多个线程，那么这个CPU就只能串行的执行非并发程序。</p>
<blockquote>
<p>如果某个系统支持两个或者多个动作（Action）<strong>同时存在</strong>，那么这个系统就是一个<strong>并发系统</strong>。如果某个系统支持两个或者多个动作<strong>同时执行</strong>，那么这个系统就是一个<strong>并行系统</strong>。并发系统与并行系统这两个定义之间的关键差异在于<strong>“存在”</strong>这个词。</p>
<p>在并发程序中可以同时拥有两个或者多个线程。这意味着，如果程序在单核处理器上运行，那么这两个线程将交替地换入或者换出内存。这些线程是同时“存在”的——每个线程都处于执行过程中的某个状态。如果程序能够并行执行，那么就一定是运行在多核处理器上。此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。</p>
<p>我相信你已经能够得出结论——<strong>“并行”概念是“并发”概念的一个子集</strong>。也就是说，你可以编写一个拥有多个线程或者进程的并发程序，但如果没有多核处理器来执行这个程序，那么就不能以并行方式来运行代码。因此，凡是在求解单个问题时涉及多个执行流程的编程模式或者执行行为，都属于并发编程的范畴。</p>
<p>摘自：《并发的艺术》 — 〔美〕布雷谢斯</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>死锁总结</title>
    <url>/2017/08/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%AD%BB%E9%94%81%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>分析死锁形成的原理，与避免死锁的方法。</p>
<a id="more"></a>

<hr>
<h2 id="死锁的形成原理"><a href="#死锁的形成原理" class="headerlink" title="死锁的形成原理"></a>死锁的形成原理</h2><p>先用一段代码来模拟死锁:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String A = <span class="string">"A"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String B = <span class="string">"B"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(A) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (interruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span>(B) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"t1"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(B) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span>(A) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"t2"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码t1线程锁定资源A，然后睡眠2秒后需要锁定资源B才能结束运行，t2线程直接锁定了资源B，然后需要锁定资源A才能结束运行，由于两个线程都无法拿到需要的资源，所以都处于阻塞状态。</p>
<h2 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h2><ol>
<li>避免一个线程同时获取多个锁。</li>
<li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁子占用一个资源。</li>
<li>使用定时锁lock.tryLock(timeout)来代替内部锁机制。</li>
<li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</li>
</ol>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络知识点总结</title>
    <url>/2018/07/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>计算机网络知识点总结。</p>
<a id="more"></a>

<hr>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP构建在TCP/IP协议上，默认端口<strong>80</strong>，是<strong>无连接状态</strong>的。</p>
<blockquote>
<p>参考：<a href="https://juejin.im/entry/5981c5df518825359a2b9476">HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</a></p>
</blockquote>
<h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><h4 id="HTTP请求报文头如下所示"><a href="#HTTP请求报文头如下所示" class="headerlink" title="HTTP请求报文头如下所示"></a>HTTP请求报文头如下所示</h4><p><img src="httpRequest.png" alt="httpRequest"></p>
<h4 id="HTTP响应报文头如下所示"><a href="#HTTP响应报文头如下所示" class="headerlink" title="HTTP响应报文头如下所示"></a>HTTP响应报文头如下所示</h4><p><img src="httpResponse.png" alt="httpResponse"></p>
<h3 id="HTTP版本号的作用"><a href="#HTTP版本号的作用" class="headerlink" title="HTTP版本号的作用"></a>HTTP版本号的作用</h3><p>版本号说明的是应用程序支持的最高HTTP版本，例如与HTTP 1.1的应用通信的HTTP 1.2应用知道它不支持HTTP 1.2的新特性，最多只能支持到HTTP 1.1的特性。</p>
<h3 id="HTTP-1-0-1-1-2-0-的区别"><a href="#HTTP-1-0-1-1-2-0-的区别" class="headerlink" title="HTTP 1.0 / 1.1 / 2.0 的区别"></a>HTTP 1.0 / 1.1 / 2.0 的区别</h3><h4 id="HTTP-1-0-和-HTTP-1-1的区别"><a href="#HTTP-1-0-和-HTTP-1-1的区别" class="headerlink" title="HTTP 1.0 和 HTTP 1.1的区别"></a>HTTP 1.0 和 HTTP 1.1的区别</h4><ol>
<li><strong>缓存处理</strong>：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong>：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li><strong>错误通知的管理</strong>：在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li><strong>Host头处</strong>：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li>
<li><strong>长连接</strong>：HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li>
</ol>
<h4 id="HTTP-2-0-和-HTTP-1-1-的区别"><a href="#HTTP-2-0-和-HTTP-1-1-的区别" class="headerlink" title="HTTP 2.0 和 HTTP 1.1 的区别"></a>HTTP 2.0 和 HTTP 1.1 的区别</h4><ol>
<li><strong>新的二进制格式</strong>（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li>
<li><strong>多路复用</strong>（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</li>
<li><strong>header压缩</strong>，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li>
<li><strong>服务端推送</strong>（server push），同SPDY一样，HTTP2.0也具有server push功能。</li>
</ol>
<p><strong>HTTP2.0多路复用有多好？</strong>HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 <strong>TCP 慢启动</strong>。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。</p>
<h4 id="流的概念"><a href="#流的概念" class="headerlink" title="流的概念"></a>流的概念</h4><p>流（Stream），服务器和客户端在HTTP/2连接内用于交换帧数据的独立双向序列，逻辑上可看做一个较为完整的交互处理单元，即表达一次完整的资源请求-响应数据交换流程；一个业务处理单元，在一个流内进行处理完毕，这个流生命周期完结。</p>
<p>特点如下：</p>
<ul>
<li>一个HTTP/2连接可同时保持多个打开的流，任一端点交换帧 </li>
<li>流可被客户端或服务器单独或共享创建和使用 </li>
<li>流可被任一端关闭 </li>
<li>在流内发送和接收数据都要按照顺序 </li>
<li>流的标识符自然数表示，1~2^31-1区间，有创建流的终端分配 </li>
<li>流与流之间逻辑上是并行、独立存在</li>
</ul>
<h4 id="多路复用原理"><a href="#多路复用原理" class="headerlink" title="多路复用原理"></a>多路复用原理</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="http%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt="http多路复用"></h4><p>需要抽象化一些，就好理解了：</p>
<ol>
<li>每一个帧可看做是一个学生，流可以认为是组（流标识符为帧的属性值），一个班级（一个连接）内学生被分为若干个小组，每一个小组分配不同的具体任务。 </li>
<li>HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个小组任务都需要建立一个班级，多个小组任务多个班级，1:1比例 </li>
<li>HTTP/1.1 Pipeling解决方式为，若干个小组任务排队串行化单线程处理，后面小组任务等待前面小组任务完成才能获得执行机会，一旦有任务处理超时等，后续任务只能被阻塞，毫无办法，也就是人们常说的线头阻塞 </li>
<li>HTTP/2多个小组任务可同时并行（严格意义上是并发）在班级内执行。一旦某个小组任务耗时严重，但不会影响到其它小组任务正常执行 </li>
<li>针对一个班级资源维护要比多个班级资源维护经济多了，这也是多路复用出现的原因 </li>
</ol>
<blockquote>
<p>参考：<a href="http://www.blogjava.net/yongboy/archive/2015/03/19/423611.html">HTTP/2笔记之流和多路复用</a></p>
</blockquote>
<h3 id="HTTP常用方法"><a href="#HTTP常用方法" class="headerlink" title="HTTP常用方法"></a>HTTP常用方法</h3><ul>
<li>GET : 获取资源</li>
<li>POST : 传输实体主体</li>
<li>PUT : 传输文件</li>
<li>HEAD : 获得报文首部</li>
<li>DELETE : 删除文件</li>
<li>OPTIONS : 询问支持的方法</li>
</ul>
<h4 id="GET方法和POST方法的区别"><a href="#GET方法和POST方法的区别" class="headerlink" title="GET方法和POST方法的区别"></a>GET方法和POST方法的区别</h4><ol>
<li>GET重点在从服务器上获取资源，POST重点在向服务器发送数据；</li>
<li>GET传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用”?”连接，多个请求数据间用”&amp;”连接，如<a href="http://127.0.0.1/Test/login.action?name=admin&amp;password=admin，这个过程用户是可见的；post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；">http://127.0.0.1/Test/login.action?name=admin&amp;password=admin，这个过程用户是可见的；post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；</a></li>
<li>Get传输的数据量小，因为受URL长度限制，但效率较高；Post可以传输大量数据，所以上传文件时只能用Post方式</li>
<li>get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等；post较get安全性较高 </li>
<li>get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码；post支持标准字符集，可以正确传递中文字符。</li>
</ol>
<h3 id="HTTPS-和-HTTP的区别"><a href="#HTTPS-和-HTTP的区别" class="headerlink" title="HTTPS 和 HTTP的区别"></a>HTTPS 和 HTTP的区别</h3><ol>
<li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li>
<li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</li>
<li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。 </li>
</ol>
<h3 id="一次HTTP请求的完整流程"><a href="#一次HTTP请求的完整流程" class="headerlink" title="一次HTTP请求的完整流程"></a>一次HTTP请求的完整流程</h3><blockquote>
<p>参考：<a href="https://www.linux178.com/web/httprequest.html">一次完整的HTTP事务是怎样一个过程？</a></p>
</blockquote>
<h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><h4 id="发起TCP3次握手"><a href="#发起TCP3次握手" class="headerlink" title="发起TCP3次握手"></a>发起TCP3次握手</h4><h4 id="建立TCP连接后发起HTTP请求"><a href="#建立TCP连接后发起HTTP请求" class="headerlink" title="建立TCP连接后发起HTTP请求"></a>建立TCP连接后发起HTTP请求</h4><h4 id="服务器响应HTTP请求，浏览器得到HTML代码"><a href="#服务器响应HTTP请求，浏览器得到HTML代码" class="headerlink" title="服务器响应HTTP请求，浏览器得到HTML代码"></a>服务器响应HTTP请求，浏览器得到HTML代码</h4><h4 id="浏览器解析HTML代码，并请求HTML代码中的资源"><a href="#浏览器解析HTML代码，并请求HTML代码中的资源" class="headerlink" title="浏览器解析HTML代码，并请求HTML代码中的资源"></a>浏览器解析HTML代码，并请求HTML代码中的资源</h4><h4 id="资源请求完后关闭连接，服务器发起TCP4次挥手"><a href="#资源请求完后关闭连接，服务器发起TCP4次挥手" class="headerlink" title="资源请求完后关闭连接，服务器发起TCP4次挥手"></a>资源请求完后关闭连接，服务器发起TCP4次挥手</h4><h4 id="浏览器对页面进行渲染呈现给用户"><a href="#浏览器对页面进行渲染呈现给用户" class="headerlink" title="浏览器对页面进行渲染呈现给用户"></a>浏览器对页面进行渲染呈现给用户</h4><h3 id="TCP-IP-的分层结构"><a href="#TCP-IP-的分层结构" class="headerlink" title="TCP/IP 的分层结构"></a>TCP/IP 的分层结构</h3><p><strong>应用层</strong>：决定了向用户提供<strong>应用服务</strong>时通信的活动，HTTP（HyperText Transfer Protocol，超文本传输协议）、FTP（File Transfer Protocol，文件传输协议）、DNS（Domain Name System，域名系统）位于本层。</p>
<p><strong>传输层</strong>：传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）。</p>
<p><strong>网络层</strong>：用来处理在网络上流动的数据包，数据包是网络传输的最小数据单位，与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。IP协议。</p>
<p><strong>链路层</strong>：处理连接网络的硬件部分。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>静态链接和动态链接的区别</title>
    <url>/2017/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>本文讲解静态链接和动态链接的区别个各自优缺点。</p>
<a id="more"></a>

<hr>
<p>静态链接：在编译连接时直接将需要的执行代码拷贝到调用处。</p>
<ul>
<li>优点：程序发布时不需要依赖库，可以独立运行。</li>
<li>缺点：程序的体积会相对大一些。</li>
</ul>
<p>动态链接：在编译连接时不直接拷贝代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，程序在运行到指定的代码时，去执行内存中已经加载的动态库可执行代码，最终达到运行时连接的目的。</p>
<ul>
<li>优点：多个程序可以共享同一段代码。</li>
<li>缺点：运行时加载会影响程序执行性能。</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>2017网易 合唱团</title>
    <url>/2017/07/01/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2017%E7%BD%91%E6%98%93-%E5%90%88%E5%94%B1%E5%9B%A2/</url>
    <content><![CDATA[<p>求间隔子数组的最大乘积。相邻元素的最大间隔为d，子数组长度为k。</p>
<p>相关题目：编程之美2.13: 子数组的最大乘积</p>
<a id="more"></a>

<blockquote>
<p>题目：（网易2017年合唱团）有 n 个学生站成一排，每个学生有一个能力值，牛牛想从这 n 个学生中按照顺序选取 k 名学生，要求相邻两个学生的位置编号的差不超过 d，使得这 k 个学生的能力值的乘积最大，你能返回最大的乘积吗？</p>
<p>输入：每个输入包含 1 个测试用例。每个测试数据的第一行包含一个整数 n (1 &lt;= n &lt;= 50)，表示学生的个数，接下来的一行，包含 n 个整数，按顺序表示每个学生的能力值 ai（-50 &lt;= ai &lt;= 50）。接下来的一行包含两个整数，k 和 d (1 &lt;= k &lt;= 10, 1 &lt;= d &lt;= 50)。</p>
<p>输出：输出一行表示最大的乘积</p>
<p>示例：</p>
<p>3</p>
<p>7  4  7</p>
<p>2  50</p>
<p>输出：</p>
<p>49</p>
</blockquote>
<h4 id="算法：2D动态规划"><a href="#算法：2D动态规划" class="headerlink" title="算法：2D动态规划"></a>算法：2D动态规划</h4><p>规划过程 ；</p>
<p><strong>max[k][i] 表示选到第k个数字，并且第k个数字的下标是i，这些数字所能产生的最大累乘积</strong></p>
<p><strong>min[k][i] 表示选到第k个数字，并且第k个数字的下标是i，这些数字所能产生的最小累乘积</strong></p>
<p>则<strong>max[k+1][i+1] = max{ max[k][i] * nums[i+1], min[k][i] * nums[i+1] }</strong></p>
<p>由于选定的两个数的下标之差在(1 ~ d)之间，所以上述的 max[k][i], min[k][i] 中的 i 应为一个变量, 从 max{ (i-d), 0 } 到 (i-1) 进行遍历。之后我们就得到了 k+1 个学生，并且以第 i+1 个学生结尾所能产生的最大乘积，如果 i+1 大于 k+1，我们还要遍历从 k+1 到 i+1 的所有结果中找出最大值。</p>
<p>同理可得:</p>
<p><strong>min[k+1][i+1] = min{ max[k][i] * nums[i+1], min[k][i] * nums[i+1] }</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WY_HeChangTuan</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = Integer.parseInt(line.trim()); <span class="comment">//n表示学生个数</span></span><br><span class="line">            line = bufferedReader.readLine();</span><br><span class="line">            <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            String[] s = line.trim().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                nums[i] = Integer.parseInt(s[i]); <span class="comment">// nums[i]表示对应学生的能力值</span></span><br><span class="line">            &#125;</span><br><span class="line">            line = bufferedReader.readLine();</span><br><span class="line">            String[] s1 = line.trim().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">int</span> k = Integer.parseInt(s1[<span class="number">0</span>]); <span class="comment">//选取k个学生</span></span><br><span class="line">            <span class="keyword">int</span> d = Integer.parseInt(s1[<span class="number">1</span>]); <span class="comment">//编号之差不超过d</span></span><br><span class="line">            <span class="comment">//规划过程开始</span></span><br><span class="line">            <span class="keyword">long</span>[][] max = <span class="keyword">new</span> <span class="keyword">long</span>[k][n];</span><br><span class="line">            <span class="keyword">long</span>[][] min = <span class="keyword">new</span> <span class="keyword">long</span>[k][n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                max[<span class="number">0</span>][i] = nums[i];</span><br><span class="line">                min[<span class="number">0</span>][i] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">                max[i][i] = max[i-<span class="number">1</span>][i-<span class="number">1</span>] * nums[i];</span><br><span class="line">                min[i][i] = max[i][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> m = Math.max(<span class="number">0</span>, (j-d)); m &lt;= (j - <span class="number">1</span>); m++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (m == Math.max(<span class="number">0</span>, (j-d))) &#123;</span><br><span class="line">                            max[i][j] = Math.max(max[i-<span class="number">1</span>][m]*nums[j], min[i-<span class="number">1</span>][m]*nums[j]);</span><br><span class="line">                            min[i][j] = Math.min(max[i-<span class="number">1</span>][m]*nums[j], min[i-<span class="number">1</span>][m]*nums[j]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        max[i][j] = Math.max(Math.max(max[i-<span class="number">1</span>][m]*nums[j], min[i-<span class="number">1</span>][m]*nums[j]), max[i][j]);</span><br><span class="line">                        min[i][j] = Math.min(Math.min(max[i-<span class="number">1</span>][m]*nums[j], min[i-<span class="number">1</span>][m]*nums[j]), min[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> res = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = k-<span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                res = Math.max(max[k-<span class="number">1</span>][i], res);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态规划的递归数组如下所示：</p>
<p><img src="/images/hechangtuan.png" alt="动态规划数组"></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>B-Tree总结</title>
    <url>/2017/08/14/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-B-Tree%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>B-Tree（B树）是一种自平衡查找树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，倒在对数时间内完成，B树概括来说是一个一般化的二分搜索树，可以拥有多余2个子节点。与自平衡二叉查找树不同，B树为系统大块数据的读写操作做了优化。B树减少定位记录时所经历的中间过程，从而加快存取速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被引用在数据库和文件系统上。</p>
<a id="more"></a>

<hr>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>文件系统中的文件是以树的形式存储的，查找文件的效率跟树的高度直接相关，为了加快文件查找速度，我们使用M叉查找树，因为一个完全二叉树的高度大约是$log_2N$，而一个完全M叉树的高度大约是$log_MN$。</p>
<p>建立M叉树的方式跟建立二叉树的方式相同，在二叉树查找树中，需要一个关键字来决定两个分支到底用哪个分支，在M叉查找树中，需要M-1个关键字来决定选取哪个分支。为了保证查找的性能，我们要让这个M叉树保持平衡。实现这种想法使用的数据结构叫B树。</p>
<p>一个M叉B树具有以下特性：</p>
<ul>
<li>数据项存储在树叶上。</li>
<li>非叶节点存储M-1个关键字以指示搜索的方向，关键字i代表子树i+1中的最小的关键字。</li>
<li>树的根或者是一片树叶，或者其儿子数载2～M之间。</li>
<li>除根外，所有非叶节点的儿子数在M/2(向上取整)～M之间。</li>
<li>所有的树叶都在相同的深度上。</li>
</ul>
<p>一个5叉B树如下所示：</p>
<p><img src="B-Tree.png" alt="B-Tree"></p>
<p>在B树中，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好）。当数据被插入或从一个节点中移除，它的子节点数量发生变化。为了维持在预先设定的数量范围内，内部节点可能会被合并或者分离。因为子节点数量有一定的允许范围，所以B树不需要像其他自平衡查找树那样频繁地重新保持平衡，但是由于节点没有被完全填充，可能浪费了一些空间。子节点数量的上界和下界依特定的实现而设置。例如，在一个2-3 B树（通常简称<a href="https://zh.wikipedia.org/wiki/2-3%E6%A0%91">2-3树</a>），每一个内部节点只能有2或3个子节点。</p>
<p>B树中每一个内部节点会包含一定数量的键值。通常，键值的数量被选定在d和2d之间。在实际中，键值占用了节点中大部分的空间。因数2将保证节点可以被拆分或组合。如果一个内部节点有2d个键值，那么添加一个键值给此节点的过程，将会拆分2d键值为2个d键值的节点，并把中间值节点添加给父节点。每一个拆分的节点需要最小数目的键值。相似地，如果一个内部节点和他的邻居两者都有d个键值，那么将通过它与邻居的合并来删除一个键值。删除此键值将导致此节点拥有d−1个键值（与邻居的合并则加上d个键值，再加上从邻居节点的父节点移来的一个键值）结果为完全填充的2d个键值。</p>
<p><strong>一个Ｂ树通过约束所有叶子节点在相同深度来保持平衡</strong>。深度在元素添加至树的过程中缓慢增长，而整体深度极少地增长，并导致所有叶子节点与根节点距离加1。</p>
<p>在存取节点数据所耗时间远超过处理节点数据所耗时间的情况下，Ｂ树在可选的实现中拥有很多优势，因为存取节点的开销被分摊到里层节点的多次操作上。这通常出现在当节点存储在二级存储器如硬盘存储器上。通过最大化内部里层节点的子节点的数量，树的高度减小，存取节点的开销被缩减。另外，重新平衡树的动作也更少出现。子节点的最大数量取决于，每个子节点必需存储的信息量，和完整磁盘块的大小或者二次存储器中类似的容量。虽然2-3 树更易于解释，实际运用中，Ｂ树使用<a href="https://zh.wikipedia.org/w/index.php?title=%E4%BA%8C%E7%BA%A7%E5%AD%98%E5%82%A8%E5%99%A8&action=edit&redlink=1">二级存储器</a>，需要要大量数目的子节点来提升效率。</p>
<p>一个Ｂ树在它内部节点中存储键值，但不需在叶子节点上存储这些键值的记录。大体上的一类包含一些变体，如B+树和Ｂ*树。</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>在Ｂ+树中，这些键值的拷贝被存储在内部节点；键值和记录存储在叶子节点；另外，一个叶子节点可以包含一个指针，指向另一个叶子节点以加速顺序存取。</p>
<p>一个B+树的例子如下图所示：</p>
<p><img src="Bplustree.png" alt="Bplustree"></p>
<p>B+ 树通常用于数据库和操作系统的文件系统中。NTFS, ReiserFS, NSS, XFS, JFS, ReFS 和BFS等文件系统都在使用B+树作为元数据索引。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>Hash算法解决冲突的方法</title>
    <url>/2017/08/14/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Hash%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>本文介绍4中Hash算法中用于解决冲突的方法。</p>
<a id="more"></a>

<hr>
<h2 id="1-开放地址法"><a href="#1-开放地址法" class="headerlink" title="1.开放地址法"></a>1.开放地址法</h2><p>所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fi(key) &#x3D; (f(key) + di) MOD m (di &#x3D; 1,2,3,...,m-1)</span><br></pre></td></tr></table></figure>

<h2 id="2-再哈希法"><a href="#2-再哈希法" class="headerlink" title="2.再哈希法"></a>2.再哈希法</h2><p>再哈希法又叫双哈希法，有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，….，等哈希函数  计算地址，直到无冲突。虽然不易发生聚集，但是增加了计算时间。</p>
<h2 id="3-拉链法"><a href="#3-拉链法" class="headerlink" title="3.拉链法"></a>3.拉链法</h2><p>每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来。</p>
<p><img src="%E6%8B%89%E9%93%BE%E6%B3%95.gif" alt="拉链法"></p>
<h2 id="4-建立公共溢出区"><a href="#4-建立公共溢出区" class="headerlink" title="4.建立公共溢出区"></a>4.建立公共溢出区</h2><p>将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树遍历算法总结</title>
    <url>/2018/03/25/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>二叉树<strong>深度优先遍历</strong>和<strong>宽度优先遍历</strong>算法总结。</p>
<a id="more"></a>

<h3 id="二叉树深度优先遍历算法"><a href="#二叉树深度优先遍历算法" class="headerlink" title="二叉树深度优先遍历算法"></a>二叉树深度优先遍历算法</h3><h4 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历:"></a>二叉树的中序遍历:</h4><h5 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorderWalk</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        inorderWalk(root.left);</span><br><span class="line">        System.out.print(root.val);</span><br><span class="line">        inorderWalk(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iterativeInorderWalk</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    ArrayDeque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    TreeNode p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            p = stack.pop();</span><br><span class="line">            System.out.print(p.val);</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历:"></a>二叉树的前序遍历:</h4><h5 id="递归实现-1"><a href="#递归实现-1" class="headerlink" title="递归实现"></a>递归实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorderWalk</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.print(root.val);</span><br><span class="line">        preorderWalk(root.left);</span><br><span class="line">        preorderWalk(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="迭代实现-1"><a href="#迭代实现-1" class="headerlink" title="迭代实现"></a>迭代实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iterativePreorderWalk</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    ArrayDeque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    TreeNode p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(p.val);</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            p = stack.pop();</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意到前序遍历和中序遍历的迭代算法结构完全相同，只有处理当前节点语句的位置不同。</strong></p>
<h4 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历:"></a>二叉树的后序遍历:</h4><h5 id="递归实现-2"><a href="#递归实现-2" class="headerlink" title="递归实现"></a>递归实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorderWalk</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        postorderWalk(root.left);</span><br><span class="line">        postorderWalk(root.right);</span><br><span class="line">        System.out.print(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="迭代实现-2"><a href="#迭代实现-2" class="headerlink" title="迭代实现"></a>迭代实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iterativePostorderWalk</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    ArrayDeque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    ArrayDeque&lt;TreeNode&gt; resStack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    TreeNode p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resStack.push(p);</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            p = stack.pop().left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!resStack.isEmpty()) &#123;</span><br><span class="line">        System.out.print(resStack.pop().val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉树的宽度优先遍历算法"><a href="#二叉树的宽度优先遍历算法" class="headerlink" title="二叉树的宽度优先遍历算法"></a>二叉树的宽度优先遍历算法</h3><h4 id="层次遍历二叉树"><a href="#层次遍历二叉树" class="headerlink" title="层次遍历二叉树:"></a>层次遍历二叉树:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrderWalk</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    ArrayDeque&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode p = queue.poll();</span><br><span class="line">        System.out.print(p.val);</span><br><span class="line">        <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(p.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(p.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="之字型遍历二叉树"><a href="#之字型遍历二叉树" class="headerlink" title="之字型遍历二叉树:"></a>之字型遍历二叉树:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; rightStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; leftStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    rightStack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!rightStack.isEmpty() || !leftStack.isEmpty()) &#123;</span><br><span class="line">        TreeNode p;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!rightStack.isEmpty()) &#123;</span><br><span class="line">            p = rightStack.pop();</span><br><span class="line">            list.add(p.val);</span><br><span class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) leftStack.push(p.left);</span><br><span class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) leftStack.push(p.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!list.isEmpty()) &#123;</span><br><span class="line">            res.add(list);</span><br><span class="line">            list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!leftStack.isEmpty()) &#123;</span><br><span class="line">            p = leftStack.pop();</span><br><span class="line">            list.add(p.val);</span><br><span class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) rightStack.push(p.right);</span><br><span class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) rightStack.push(p.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!list.isEmpty()) res.add(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="从底向上层次遍历二叉树"><a href="#从底向上层次遍历二叉树" class="headerlink" title="从底向上层次遍历二叉树:"></a>从底向上层次遍历二叉树:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ArrayDeque&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        LinkedList&lt;Integer&gt; level = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode pNode = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (pNode.left != <span class="keyword">null</span>) queue.offer(pNode.left);</span><br><span class="line">            <span class="keyword">if</span> (pNode.right != <span class="keyword">null</span>) queue.offer(pNode.right);</span><br><span class="line">            level.add(pNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(<span class="number">0</span>, level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二维数组中的查找</title>
    <url>/2018/05/09/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>在二维数组中查找。</p>
<p>相关题目：剑指Offer面试题4：二维数组中的查找Leetcode 74. Search a 2D Matrix, Leetcode 240. Search a 2D Matrix II。</p>
<a id="more"></a>

<hr>
<p><strong>问题1: 数组中的元素有什么特征？</strong></p>
<p><strong>问题2: 异常情况怎样处理？如matrix == null，matrix.length == 0, matrix[0].length == 0?</strong></p>
<hr>
<p>一般有两种情况，第一种情况：数组中的元素每行从左到右递增（递减），每列从上到下递增（递减），这时候我们可以用算法1。</p>
<h3 id="算法1-从非最小最大元素开始搜索"><a href="#算法1-从非最小最大元素开始搜索" class="headerlink" title="算法1: 从非最小最大元素开始搜索"></a>算法1: 从非最小最大元素开始搜索</h3><p>第一种矩阵如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1	2	8	9</span><br><span class="line">2	4	9	12</span><br><span class="line">4	7	10	13</span><br><span class="line">6	8	11	15</span><br></pre></td></tr></table></figure>

<p>这种情况下我们需要从右上角或者左下角开始搜索，每一次判断可以排除一行或者一列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> col = (matrix[<span class="number">0</span>].length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (row &lt;= (matrix.length - <span class="number">1</span>) &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[row][col] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &lt; target) row++;</span><br><span class="line">        <span class="keyword">else</span> col--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n), Leetcode 15ms.</p>
<p>空间复杂度：O(1)</p>
<p>Leetcode 240. Search a 2D Matrix II 就可以用该解法。</p>
<hr>
<p>第二种情况是：在第一中情况的条件下，新加一个条件：每行最后一个元素要大于下一行第一个元素。显然这种情况下我们还可以使用O(n)时间的算法1，但是我们可以根据新加的条件使用另一种速度更快的算法。</p>
<h3 id="算法2-二分查找"><a href="#算法2-二分查找" class="headerlink" title="算法2: 二分查找"></a>算法2: 二分查找</h3><p>第二种矩阵如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1	3	5	7</span><br><span class="line">10	11	16	20</span><br><span class="line">23	30	34	50</span><br></pre></td></tr></table></figure>

<p>由于矩阵在内存中是按顺序存储的，所以我们可以把整个矩阵当成一个有序数组，在数组上进行二分查找，这就涉及到一个问题：矩阵下标和数组下标的映射：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int m &#x3D; matrix.length;</span><br><span class="line">int n &#x3D; matrix[0].length;</span><br><span class="line"></span><br><span class="line">matrix[x][y] &#x3D;&gt; array[x * n + y]</span><br><span class="line">array[x]     &#x3D;&gt; matrix[x &#x2F; n][x % n]</span><br></pre></td></tr></table></figure>

<p>有了上面的映射规则，我们可以得到如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = m * n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid, num;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        mid = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        num = matrix[mid/n][mid%n];</span><br><span class="line">        <span class="keyword">if</span> (num == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; target) end = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> start = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Leetcode 74. Search a 2D Matrix 就可以用这种解法。</p>
<p>时间复杂度：O(log(n*m))，Leetcode: 11ms</p>
<p>空间复杂度：O(1)</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列</title>
    <url>/2018/06/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p>求数组或字符串的全排列算法。</p>
<a id="more"></a>

<hr>
<h3 id="不包含重复元素的序列求全排列"><a href="#不包含重复元素的序列求全排列" class="headerlink" title="不包含重复元素的序列求全排列"></a>不包含重复元素的序列求全排列</h3><p>我们将第一个元素看作一部分A，其余元素看作一部分B，让第一个元素和后面的某一个元素交换，然后求B的全排列，递归执行上面语句，知道第二部分的开始指针到达数组末尾，我就得到一个排列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="comment">//得到一个排列</span></span><br><span class="line">            System.out.print(nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">        swap(nums, i, start);</span><br><span class="line">        permutation(nums, start + <span class="number">1</span>);</span><br><span class="line">        swap(nums, i, start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = nums[a];</span><br><span class="line">    nums[a] = nums[b];</span><br><span class="line">    nums[b] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="包含重复元素的序列求全排列"><a href="#包含重复元素的序列求全排列" class="headerlink" title="包含重复元素的序列求全排列"></a>包含重复元素的序列求全排列</h3><p>推荐使用Set这种数据结构存储排列结果，可以完美解决排列重复的问题。</p>
<p>还有一种方案是：添加if语句判断该元素是否重复，如果重复则不交换，这种方法不保证能完全解决重复元素的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//放在Set中的数据类型必须实现Comparable接口的compareTo方法</span></span><br><span class="line">Set&lt;String&gt; res = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">permutation2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            sb.append(i);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">//swap nums[i] nums[start]</span></span><br><span class="line">        swap(nums, i, start);</span><br><span class="line">        permutation2(nums, start + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//swap nums[i] nums[start]</span></span><br><span class="line">        swap(nums, i, start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = nums[a];</span><br><span class="line">    nums[a] = nums[b];</span><br><span class="line">    nums[b] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/2018/04/26/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>各种排序算法的性能比较以及优化。</p>
<a id="more"></a>

<hr>
<h2 id="各排序算法性能表"><a href="#各排序算法性能表" class="headerlink" title="各排序算法性能表"></a>各排序算法性能表</h2><table>
<thead>
<tr>
<th>算法</th>
<th align="center">平均情况</th>
<th align="center">最好情况</th>
<th align="center">最坏情况</th>
<th align="center">辅助空间</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>快速排序</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(log_2n)$</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(n)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(1)$</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td align="center">$&lt;O(n^2)$</td>
<td align="center">$&lt;O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td>冒泡排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>基数排序</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>桶排序</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><blockquote>
<p>时间复杂度的表示方法：</p>
<p>设f和g是定义域为自然数集N上的函数，若存在正数c和$n_0$，使得对所有$n\geq n_0$有</p>
<p>$0\leq f(n) \leq cg(n)$记作：$f(n) = O(g(n))$ 表示g(n)是f(n)的<strong>渐近上界</strong>。</p>
<p>$0\leq cg(n) \leq f(n)$记作：$f(n) = \Omega(g(n))$ 表示g(n)是f(n)的<strong>渐近下界</strong>。</p>
<p>$0\leq f(n) &lt; cg(n)$记作：$f(n) = o(g(n))$ 表示g(n)是f(n)的<strong>高阶</strong>。</p>
<p>$0\leq cg(n) &lt; f(n)$记作：$f(n)=w(g(n))$ 表示g(n)是f(n)的<strong>低阶</strong>。</p>
<p>若$f(n)=O(g(n))$且$f(n)=\Omega(g(n))$记作：$f(n) = \Theta(g(n))$ 表示g(n)与f(n)<strong>同阶</strong>。</p>
</blockquote>
<br />

<blockquote>
<p><strong>定理</strong>：在最坏情况下，任何比较排序算法都需要做$\Omega(n\log_2n)$次比较。(最坏情况下的比较次数 = 决策树的高度h，由Striling公式得 $h\geq \log_2(n!)=\Theta(n\log_2n)$ ，n!表示决策树中叶子节点的个数)</p>
<p><strong>推论</strong>：<strong>堆排序</strong>和<strong>归并排序</strong>都是渐近最优的比较排序算法。</p>
</blockquote>
<br />

<blockquote>
<p><strong>决策树</strong></p>
<p>决策树是一颗完全二叉树，可以表示在给定输入规模下某一特定算法对所有元素的比较操作。</p>
<p>下图为三个元素作为输入序列的决策树，节点里的数值表示元素下表，叶节点表示通过比较后得到的输出序列。</p>
<p><img src="%E5%86%B3%E7%AD%96%E6%A0%91.png" alt="决策树"></p>
<p>对于n个元素一共有n!种排列，都会出现在决策树的叶子节点上。</p>
</blockquote>
<br />

<blockquote>
<p><strong>定理1：N个互异数的数组的平均逆序数是N(N-1)/4。</strong></p>
<p>这个定理意味着插入排序平均时间复杂度是$O(n^2)$，同时也提供了只交换相邻元素的任何算法的一个很强的下界$\Omega(n^2)$。</p>
</blockquote>
<br />

<blockquote>
<p>定理2：通过交换相邻元素进行排序的任何算法平均都需要$\Omega(n^2)$时间。</p>
</blockquote>
<br />

<blockquote>
<p><strong>Java中的Comparable[]数组</strong></p>
<p>在一些排序算法的源码中，我们可能会看到有些函数的传入常数是<code>Comparable[] a;</code>，这样写的意思是，这个参数可以是任何实现了Comparable接口的类，例如Integer[], Double[], String[]这些类，当然我们可以自己写一个实现Comparable接口的类作为传入参数。</p>
<p>这样写可以增强代码的复用性，当我们新写一个类，需要用这个方法排序的时候，只要在新类里实现Comparable里的comparaTo()方法，这个类的对象就可以作为该排序函数的传入参数。</p>
</blockquote>
<br />

<blockquote>
<p>用不同的方法处理小规模问题能改进大多数递归算法的性能，因为递归会使小规模问题中方法的调用过于频繁，所以改进对它们的处理方法就能改进整个算法。</p>
</blockquote>
<hr>
<h2 id="快速排序-Quicksort"><a href="#快速排序-Quicksort" class="headerlink" title="快速排序 Quicksort"></a>快速排序 Quicksort</h2><blockquote>
<p>快速排序使用了<strong>分治法</strong>的思想，排序过程分为三步：</p>
<ol>
<li><p>分解：选定数组中最后一个元素作为划分元素，小于该元素的数放到数组前面，大于该元素的数放到数组后面。</p>
</li>
<li><p>解决：通过递归调用对两个子数组进行排序。</p>
</li>
<li><p>合并：不需要合并，原数组已经有序。</p>
<p><img src="quicksort.gif" alt="quicksort"></p>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quicksort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end &lt;= start) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> q = partition(nums, start, end);</span><br><span class="line">        quicksort(nums, start, q-<span class="number">1</span>);</span><br><span class="line">        quicksort(nums, q+<span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = nums[end];</span><br><span class="line">        <span class="keyword">int</span> i = start-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt;= end-<span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt;= x)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i+<span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>快速排序通常是实际应用中最好的排序算法，因为平均时间复杂度$\Theta(n\log_2n)$中隐含的常数因子非常小，而且空间复杂度为$O(1)$。</p>
<p>时间复杂度：</p>
<ul>
<li>最好情况：partition划分得到的两个子问题的规模都不大于n/2，这时候快速排序的时间性能为$\Theta(n\log_2n)$。</li>
<li>最坏情况：partition划分得到的两个字问题一个包含n-1个元素另一个包含0个元素，这时候快速排序的时间性能为$\Theta(n^2)$。</li>
<li>平均情况：快速排序的平均运行时间更接近最好情况是$O(n\log_2n)$。</li>
</ul>
<p>空间复杂度：</p>
<ul>
<li>最坏情况下：partition划分的子问题规模每次减少1，所以会进行n次递归，递归树的深度是$O(n)$。</li>
<li>除了最坏情况下，任何常数比例的划分都会产生深度为$\Theta(\log_2n)$的递归树。</li>
</ul>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="思路1-快速排序-插入排序"><a href="#思路1-快速排序-插入排序" class="headerlink" title="思路1: 快速排序+插入排序"></a>思路1: 快速排序+插入排序</h4><p>我们知道<strong>对于小数组快速排序比插入排序慢</strong>，因为递归，快速排序quicksort()方法在小数组中也会调用自己，因此在排序小数组时应该切换到插入排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end - start &lt;= M) &#123; <span class="comment">//数组长度小于M时转换为插入排序</span></span><br><span class="line">        Insertionsort.sort(nums, start, end);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> q = partition(nums, start, end);</span><br><span class="line">    quicksort(nums, start, q-<span class="number">1</span>);</span><br><span class="line">    quicksort(nums, q+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换参数M的最佳值和系统相关，但是5～15之间的任意值在大多数情况下都能令人满意。</p>
<h4 id="思路2-随机化版本的快速排序"><a href="#思路2-随机化版本的快速排序" class="headerlink" title="思路2: 随机化版本的快速排序"></a>思路2: 随机化版本的快速排序</h4><p>由于快速排序的运行时间依赖于划分是否平衡，而平衡与否依赖于选择划分元素的算法，所以第一种优化思路，是针对选取划分元素的算法进行优化。</p>
<p>与每次选取数组结尾元素作为拆分元素不同，我们每次从数组中随机选取一个元素与结尾元素交换，通过随机抽样我们保证了拆分元素是随机的从数组中选取的，因为拆分元素是随机选取的，所以在平均情况下对数组的划分是比较均衡的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> q = randomPartition(nums, start, end);</span><br><span class="line">    quicksort(nums, start, q-<span class="number">1</span>);</span><br><span class="line">    quicksort(nums, q+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">randomPartition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span> index = start + r.nextInt(end - start);</span><br><span class="line">    swap(nums, index, end);</span><br><span class="line">    <span class="keyword">return</span> partition(nums, start, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = nums[end];</span><br><span class="line">    <span class="keyword">int</span> i = start-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt;= end-<span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt;= x)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, i+<span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随机化版本的快速排序还可以进一步优化。</p>
<h4 id="思路2进一步优化：三数取中划分"><a href="#思路2进一步优化：三数取中划分" class="headerlink" title="思路2进一步优化：三数取中划分"></a>思路2进一步优化：三数取中划分</h4><p>对随机化版本的快速排序做进一步优化，是要从子数组中更细致地选择拆分元素，而不是简单地随机选择，常用做法是三数取中划分：<strong>从子数组中随机选出三个元素，取其中位数作为拆分元素</strong>，会得到更好的拆分效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> q = randomThreeMedianPartition(nums, start, end);</span><br><span class="line">    quicksort(nums, start, q-<span class="number">1</span>);</span><br><span class="line">    quicksort(nums, q+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">randomThreeMedianPartition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span> index = start + r.nextInt(end - start);</span><br><span class="line">    <span class="keyword">if</span> (end - start &gt; <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = start + r.nextInt(end - start);</span><br><span class="line">        <span class="keyword">int</span> b = start + r.nextInt(end - start);</span><br><span class="line">        <span class="keyword">int</span> c = start + r.nextInt(end - start);</span><br><span class="line">        index = nums[a] &gt; nums[b] ? (nums[a] &lt; nums[c] ? a : (nums[b] &gt; nums[c] ? b : c)) : (nums[b] &lt; nums[c] ? b : c);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, index, end);</span><br><span class="line">    <span class="keyword">return</span> partition(nums, start, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = nums[end];</span><br><span class="line">    <span class="keyword">int</span> i = start-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt;= end-<span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt;= x)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, i+<span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="思路3-三向切分快排-3-Way-Partition-Quicksort"><a href="#思路3-三向切分快排-3-Way-Partition-Quicksort" class="headerlink" title="思路3: 三向切分快排 3-Way Partition Quicksort"></a>思路3: 三向切分快排 3-Way Partition Quicksort</h4><p>在前面的优化过程中，我们都没有考虑过数组中元素的情况，如果数组中存在<strong>很多重复元素</strong>，那么算法还有很大的优化空间。</p>
<p>如果待排序数组中存在<strong>大量重复数字</strong>，那么我们要修改原来的partition()函数，它返回两个数组下标$lt,gt$其中$start \leq lt \leq gt \leq end$ ，并且：</p>
<ul>
<li>A[start～lt-1]中的元素都小于A[start]</li>
<li>A[lt～gt]中的元素都等于A[start]</li>
<li>A[gt+1～end]中的元素都大于A[start]</li>
</ul>
<p>这样分类后，相等的元素就不会被包含到递归排序的子数组中，这种算法就是3-Way Partition Quicksort(三向切分快速排序)。</p>
<p><img src="%E4%B8%89%E5%90%91%E5%88%87%E5%88%86%E6%8E%92%E5%BA%8F-4980246.png" alt="三向切分排序-4980246"></p>
<p>对于存在大量重复元素的数组，这种方法比标准的快速排序的效率高得多，例如，对于只有若干不同值的随机数组，归并排序的时间复杂度是$O(n\log_2n)$，而三向切分快速排序则是$O(n)$。</p>
<blockquote>
<p><strong>对于包含大量重复元素的数组，三向切分快速排序将排序时间从线性对数级降低到了线性级别。</strong>这种对重复元素的适应性使得三向切分的快速排序成为排序库函数的最佳算法选择。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quick3Way</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end &lt;= start) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> x = nums[start]; <span class="comment">//这里可以随机选取或者三数取中选取拆分元素</span></span><br><span class="line">    <span class="keyword">int</span> lt = start, i = start+<span class="number">1</span>, gt = end;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; x) swap(nums, lt++, i++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; x) swap(nums, i, gt--);</span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    quick3Way(nums, start, lt-<span class="number">1</span>);</span><br><span class="line">    quick3Way(nums, gt+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个算法还可以继续优化，在数组中重复元素不多的普通情况下，它比标准的二分法多使用了很多次交换，因为交换都发生在和切分元素不相等的元素上。所以，我们可以只对少数的重复元素进行交换。</p>
<h4 id="Quick-3-Way-Partition-Quicksort-快速三向切分排序"><a href="#Quick-3-Way-Partition-Quicksort-快速三向切分排序" class="headerlink" title="Quick 3-Way Partition Quicksort 快速三向切分排序"></a>Quick 3-Way Partition Quicksort 快速三向切分排序</h4><p>快速三向切分排是将重复元素放置于子数组两端的方式实现一个更快的排序算法。</p>
<p><img src="%E5%BF%AB%E9%80%9F%E4%B8%89%E5%90%91%E5%88%87%E5%88%86%E7%AE%97%E6%B3%95.png" alt="快速三向切分算法"></p>
<hr>
<h2 id="归并排序-Mergesort"><a href="#归并排序-Mergesort" class="headerlink" title="归并排序 Mergesort"></a>归并排序 Mergesort</h2><blockquote>
<p>和快速排序一样，归并排序也是基于<strong>分治法</strong>的思想，排序过程分三步：</p>
<ol>
<li>分解：将n个元素分成两份，每份n/2个元素。</li>
<li>解决：递归排序两个字序列。</li>
<li>合并：合并两个已排序的子序列。</li>
</ol>
<p>算法运行过程如下所示：</p>
<p><img src="Mergesort.gif" alt="Mergesort"></p>
</blockquote>
<p><strong>自顶向下的归并排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mergesort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        mergesort(nums, start, mid); <span class="comment">//递归对前半部分数组排序</span></span><br><span class="line">        mergesort(nums, mid + <span class="number">1</span>, end); <span class="comment">//递归对后半部分数组排序</span></span><br><span class="line">        merge(nums, start, mid, end); <span class="comment">//将排序后的两个字数组合并</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = mid - start + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = end - mid;</span><br><span class="line">        <span class="keyword">int</span>[] L = <span class="keyword">new</span> <span class="keyword">int</span>[len1 + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] R = <span class="keyword">new</span> <span class="keyword">int</span>[len2 + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start, j = <span class="number">0</span> ; i &lt;= mid; i++) &#123;</span><br><span class="line">            L[j++] = nums[i]; <span class="comment">//将nums[]数组的左半部分复制到L[]数组中</span></span><br><span class="line">        &#125;</span><br><span class="line">        L[len1] = Integer.MAX_VALUE; <span class="comment">//哨兵节点，表示数组到达末尾</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            R[j++] = nums[i]; <span class="comment">//将nums[]数组的右半部分复制到R[]数组中</span></span><br><span class="line">        &#125;</span><br><span class="line">        R[len2] = Integer.MAX_VALUE; <span class="comment">//哨兵节点</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = start; k &lt;= end; k++) &#123; <span class="comment">//对比L[]和R[]中的元素，从小到大依次放入nums[]中</span></span><br><span class="line">            <span class="keyword">if</span> (L[i] &lt;= R[j]) &#123;</span><br><span class="line">                nums[k] = L[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k] = R[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自底向上的归并排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux; <span class="comment">//归并排序的辅助数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(Comparable[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要进行logN次两两归并</span></span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    aux = <span class="keyword">new</span> Comparable[len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> size = <span class="number">1</span>; size &lt; len; size &lt;&lt;= <span class="number">1</span>) &#123; <span class="comment">//size表示子数组长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; len - size; start += (size&lt;&lt;<span class="number">1</span>)) &#123;</span><br><span class="line">            merge(nums, start, start + size - <span class="number">1</span>, </span><br><span class="line">                  Math.min(start + size + size - <span class="number">1</span>, len - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将nums[start~mid]和nums[mid+1~hi]归并</span></span><br><span class="line">    <span class="keyword">int</span> i = start, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = start; k &lt;= end; k++) &#123;</span><br><span class="line">        aux[k] = nums[k]; <span class="comment">//将nums[start~end]复制到aux[start~end]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = start; k &lt;= end; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) nums[k] = aux[j++]; <span class="comment">//如果左边到达边界</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; end) nums[k] = aux[i++]; <span class="comment">//如果右边到达边界 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (aux[j].compareTo(aux[i]) &lt; <span class="number">0</span>) nums[k] = aux[j++];</span><br><span class="line">        <span class="keyword">else</span> nums[k] = aux[i++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>归并排序所用的时间和$O(nlog_2n)$成正比，可以用归并排序对大规模的数组进行排序。归并排序的主要缺点是辅助数组所使用的额外空间和n的大小成正比。</p>
<p>时间复杂度：$\Theta(n\log_2n)$</p>
<ul>
<li>由于数组中元素的分布情况不会对归并排序的执行次数产生影响，所以没有最好情况和最坏情况，在所有情况下，归并排序的时间复杂的都是$\Theta(n\log_2n)$。</li>
</ul>
<p>空间复杂度：$O(n)$。</p>
<h3 id="性能优化-1"><a href="#性能优化-1" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="思路1-归并排序-插入排序"><a href="#思路1-归并排序-插入排序" class="headerlink" title="思路1: 归并排序+插入排序"></a>思路1: 归并排序+插入排序</h4><p>跟快速排序算法一样，当数组规模比较小的时候，归并排序还需要调用自身进行递归排序，对于小数组，插入排序要比归并排序更快，所以当数组规模小于一定值的时候切换到插入排序。</p>
<p>使用插入排序处理小规模的子数组，一般可以将归并排序的时间缩短10%～15%。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end - start &lt;= M) &#123; <span class="comment">//数组长度小于M时转换为插入排序</span></span><br><span class="line">        Insertsort.sort(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (end - start) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    mergesort(nums, start, mid);</span><br><span class="line">    mergesort(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">    merge(nums, start, mid, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="思路2-合并子数组之前判断原数组是否有序"><a href="#思路2-合并子数组之前判断原数组是否有序" class="headerlink" title="思路2: 合并子数组之前判断原数组是否有序"></a>思路2: 合并子数组之前判断原数组是否有序</h4><p>在对两个有序的子数组合并之前，可以先判断一下<code>nums[mid]</code>是否小于<code>nums[mid + 1]</code>, 如果<code>nums[mid] &lt; nums[mid + 1]</code>成立，说明原数组已经是有序的了，直接返回就可以。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> voie <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &lt;= nums[mid + <span class="number">1</span>]) <span class="keyword">return</span>;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="思路3：不将元素复制到辅助数组"><a href="#思路3：不将元素复制到辅助数组" class="headerlink" title="思路3：不将元素复制到辅助数组"></a>思路3：不将元素复制到辅助数组</h4><p>传统的归并排序要先将元素复制到两个辅助数组，然后再归并排序到原数组中，我们可以省略掉将元素复制到两个辅助数组的操作，直接将元素排序到一个大的辅助数组中（该辅助数组的长度是L和R长度的和），然后再和原数组的另一个排好序的子数组归并回原数组中，这种操作要求我们在每个层次交换输入数组和辅助数组的角色。</p>
<hr>
<h2 id="堆排序-HeapSort"><a href="#堆排序-HeapSort" class="headerlink" title="堆排序 HeapSort"></a>堆排序 HeapSort</h2><blockquote>
<p><strong>二叉堆</strong>：是一个数组，它可以被看成一个近似的完全二叉树，树上的每一个结点对应数组中的一个元素。除了最底层外，该树时完全充满的，而且是从左向右填充。</p>
<p>表示堆的数组A有两个属性：</p>
<ol>
<li>A.length（通常）给出数组元素的个数。A.heap-size表示有多少个堆元素存储在该数组中。也就是说，虽然A[1..A.length]可能都存有数据，但只有A[1..A.heap-size]中存放的是堆的有效元素，这里 0 &lt;= A.heap-size &lt;= A.length。</li>
<li>树的根结点是A[1](A[0]不使用)，如果给定一个<strong>结点的下标i</strong>，则<strong>父结点坐标为(i/2)(向下取整)，左子结点的坐标为2i，右子结点的坐标为2i+1。</strong></li>
</ol>
<p><img src="%E5%A0%86%E6%8E%92%E5%BA%8F.png" alt="堆排序"></p>
<p>二叉堆分为两种形式：最大堆和最小堆</p>
<p><strong>最大堆</strong>：除了根结点以外的所有结点i都有：<code>A[Parent(i)] &gt;= A[i]</code>。既某个结点最多和父结点一样大，因此堆中最大元素就是根结点。</p>
<p><strong>最小堆</strong>：除了根结点以外的所有结点i都有：<code>A[Parent(i)] &lt;= A[i]</code>。最小堆中的最小元素存放在根结点。</p>
<p>一个包含n个元素的堆可以看作一课完全二叉树，那么堆的高度是O(logn)，在堆结构上的一些基本操作的运行时间至多与树的高度成正比，既时间复杂度为O(logn)。</p>
<p><strong>定理：当用数组表示存储n个元素的堆时，叶结点下标分别是[n/2]+1, [n/2]+2, … , n（[]表示向下取整）。</strong></p>
</blockquote>
<br />

<blockquote>
<p>堆排序的基本步骤：对于一个输入数组A[1 .. n]先用buildMaxHeap方法将其建成一个最大堆，此时数组中的最大元素中在根结点A[1]中，通过把A[1]和A[n]互换，我们可以将该元素放到正确的位置。然后我们从堆去去掉最有一个结点，既让heapSize减1，新的根结点有可能会违背最大堆的性质，为了维护最大堆的性质，我们调用maxHeapify(A, 1)， 在A[1 .. n-1]上构建起一个新的最大堆，将A[1]和A[n-1]互换，既可将该元素放到正确位置。不断重复上述步骤，直到heapSize从n降到2。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heapsort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heapSize;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        heapSize = a.length - <span class="number">1</span>;</span><br><span class="line">        buildMaxHeap(a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = heapSize; i &gt;= <span class="number">2</span>; i--) &#123;</span><br><span class="line">            swap(a, <span class="number">1</span>, i);</span><br><span class="line">            heapSize--;</span><br><span class="line">            maxHeapify(a, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (heapSize&gt;&gt;<span class="number">1</span>); i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            maxHeapify(a, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//maxHeapify的作用是：堆第i个元素维护最大堆的性质</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">2</span> * i; <span class="comment">//左子结点坐标</span></span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">//右子结点坐标</span></span><br><span class="line">        <span class="keyword">int</span> largest = i; <span class="comment">//最大元素坐标初始值为i</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= heapSize &amp;&amp; a[l] &gt; a[i])</span><br><span class="line">            largest = l;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= heapSize &amp;&amp; a[r] &gt; a[largest])</span><br><span class="line">            largest = r;</span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(a, i, largest);</span><br><span class="line">            maxHeapify(a, largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆排序中用到了两个重要函数：maxHeapify(A, i)和buildMaxHeap(A)。</p>
<p>在调用maxHeapify时我们假定第i个结点的左右子树都是最大堆，但A[i]有可能小于其孩子，maxHeapify通过让A[i]的值在最大堆中“逐级下降”，从而使得以下标i为根结点的子树重新遵循最大堆的性质。maxHeapify的时间复杂度为$O(\log_2n)$。</p>
<p>在buildMaxHeap中用自底向上的方法利用maxHeapify把输入数组转还为最大堆。buildMaxHeap的时间复杂度为$O(n)$。</p>
<h3 id="性能分析-2"><a href="#性能分析-2" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(nlog_2n)$。</p>
<p>空间复杂度：$O(1)$。</p>
<h3 id="性能优化-2"><a href="#性能优化-2" class="headerlink" title="性能优化"></a>性能优化</h3><hr>
<h2 id="插入排序-Insertionsort"><a href="#插入排序-Insertionsort" class="headerlink" title="插入排序 Insertionsort"></a>插入排序 Insertionsort</h2><blockquote>
<p>对于数组后面未排序的元素，在前面已排序序列中找到相应位置插入。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertionsort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionsort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> key = nums[i];</span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; key) &#123;</span><br><span class="line">                nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j+<span class="number">1</span>] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="性能分析-3"><a href="#性能分析-3" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：</p>
<ul>
<li>最好情况：数组升序排列，算法只在while循环处做n次比较，while循环内的语句不会执行，所以时间复杂的是$O(n)$。</li>
<li>最坏情况：数组降序排列，算法每次都要进入while循环，进行比较操作和数据移动操作的次数是$1+2+3+…+n = n(n+1)/2$ 所以时间复杂度是$O(n^2)$。</li>
<li>平均情况：由定理1和定理2可得是$O(n^2)$。</li>
</ul>
<p>空间复杂度：$O(1)$。</p>
<h3 id="性能优化-3"><a href="#性能优化-3" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="思路1-使用二分查找确定插入位置"><a href="#思路1-使用二分查找确定插入位置" class="headerlink" title="思路1: 使用二分查找确定插入位置"></a>思路1: 使用二分查找确定插入位置</h4><p><font color=red>在查找元素插入位置时，可以使用二分查找，让查找这部分时间复杂度降到$O(\log_2n)$，算法整体时间复杂度就可以降到$O(n\log_2n)$。</font></p>
<h4 id="思路2-使用递减增量的插入排序：希尔排序。"><a href="#思路2-使用递减增量的插入排序：希尔排序。" class="headerlink" title="思路2: 使用递减增量的插入排序：希尔排序。"></a><strong>思路2:</strong> 使用递减增量的插入排序：希尔排序。</h4><hr>
<h2 id="希尔排序-Shellsort"><a href="#希尔排序-Shellsort" class="headerlink" title="希尔排序 Shellsort"></a>希尔排序 Shellsort</h2><blockquote>
<p>希尔排序也叫递减增量排序算法，是插入排序的一种高效改进版本。它对输入序列的周期子序列使用插入排序，形成了一种更快的排序算法。</p>
<p>希尔排序的执行过程如下图所示：</p>
<p><img src="Shellsort.gif" alt="Shellsort"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shellsort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shellsort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> inc = nums.length &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (inc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = inc; i &lt;= nums.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="keyword">while</span> (j &gt;= inc &amp;&amp; nums[j-inc] &gt; tmp) &#123;</span><br><span class="line">                    nums[j] = nums[j-inc];</span><br><span class="line">                    j -= inc;</span><br><span class="line">                &#125;</span><br><span class="line">                nums[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            inc &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="性能分析-4"><a href="#性能分析-4" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂的：</p>
<ul>
<li>最好情况：数组正序排列，目前最重要的结论是它的运行时间达不到$O(n^2)$。</li>
<li>最坏情况：数组逆序排列，$O(n^2)$。</li>
<li>平均情况：$&lt;O(n^2)$。</li>
</ul>
<h3 id="性能优化-4"><a href="#性能优化-4" class="headerlink" title="性能优化"></a>性能优化</h3><p>使用其他递减增量序列对原数组进行排序。如《算法》第4版中的1，4，13，40，121，364…序列。</p>
<hr>
<h2 id="冒泡排序-Bubblesort"><a href="#冒泡排序-Bubblesort" class="headerlink" title="冒泡排序 Bubblesort"></a>冒泡排序 Bubblesort</h2><blockquote>
<p>循环遍历数组，交换相邻的未按次序排列的元素，每趟遍历可以至少将一个数组放到正确位置，中共进行n-1趟排序就可将数组排好。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubblesort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length-<span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(nums, j, j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="性能分析-5"><a href="#性能分析-5" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：</p>
<ul>
<li>最好情况：数组已排序，交换元素操作没有执行，但是会进行$O(n^2)$次比较操作，所以最好情况时间复杂度还是$O(n^2)$。</li>
<li>最坏情况：数组倒序排列，$O(n^2)$</li>
<li>平均情况：$O(n^2)$</li>
</ul>
<p>空间复杂度：$O(1)$</p>
<h3 id="性能优化-5"><a href="#性能优化-5" class="headerlink" title="性能优化"></a>性能优化</h3><p>记录最后进行元素交换的位置，此位置之后的元素是有序的不用在进行遍历，所以将遍历截止的位置直接设置到最后进行元素交换的位置可以提高程序性能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubblesort1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length-<span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                swap(nums, j, j+<span class="number">1</span>);</span><br><span class="line">                flag = j+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i = flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：</p>
<ul>
<li>最好情况：数组已排序，则内层for循环遍历一遍数组不改变flag变量的初值，i=flag=0，然后跳出外层循环，所以时间复杂度为$O(n)$。</li>
</ul>
<ul>
<li>最坏情况：数组倒序，$O(n^2)$。</li>
<li>平均情况：$O(n^2)$</li>
</ul>
<p>空间复杂度：$O(1)$</p>
<hr>
<h2 id="选择排序-Selectionsort"><a href="#选择排序-Selectionsort" class="headerlink" title="选择排序 Selectionsort"></a>选择排序 Selectionsort</h2><blockquote>
<p>循环遍历数组，第一趟遍历数组是找出数组中最大元素和最后一个元素交换，第二次从剩下的元素开始遍历数组找出最小元素和倒数第二个元素交换，重复上述过程，执行n-1次遍历，每次确定一个元素的位置。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selectionsort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectionsort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length-<span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            max = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[max]) &#123;</span><br><span class="line">                    max = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="性能分析-6"><a href="#性能分析-6" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：</p>
<ul>
<li>最好情况：数组已排序，但是还是需要进行$O(n^2)$次比较。</li>
<li>最坏情况：数组倒序，$O(n^2)$。</li>
<li>平均情况：$O(n^2)$。</li>
</ul>
<p>空间复杂度：$O(1)$</p>
<hr>
<h2 id="排序算法的选择"><a href="#排序算法的选择" class="headerlink" title="排序算法的选择"></a>排序算法的选择</h2>]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中只出现1次的数字</title>
    <url>/2018/06/21/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B01%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>找出数组中只出现1次的数字。</p>
<a id="more"></a>

<hr>
<p><strong>问题1: 数组中其他元素出现几次？</strong></p>
<p><strong>问题2: 数组中的元素是否有序？</strong></p>
<p><strong>问题3: 数组是否可以修改？</strong></p>
<hr>
<p>如果要找出数组中只出现1次的数字，我们必须要知道数组中其他元素出现的次数，根据其他元素出现的次数我们可以使用不同的算法求解。</p>
<h3 id="算法1-使用HashMap记录各元素出现次数"><a href="#算法1-使用HashMap记录各元素出现次数" class="headerlink" title="算法1: 使用HashMap记录各元素出现次数"></a>算法1: 使用HashMap记录各元素出现次数</h3><p>首先介绍一种最简单最通用的算法就是用一个HashMap记录数组中各个元素出现的次数，然后找出出现1次的元素。</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<h3 id="算法2-逐个异或"><a href="#算法2-逐个异或" class="headerlink" title="算法2: 逐个异或"></a>算法2: 逐个异或</h3><p>如果题目中给出，数组中其他元素都出现2次，只有一个元素出现了1次，而且数组中的元素无序。那我们可以使用逐个异或的算法，只需遍历数组一遍，所有元素异或的结果就等于只出现1次的元素的值。</p>
<p>这种方法能够奏效的原理是：两个相同元素异或的结果是0，和0异或的结果还是元素本身，并且异或操作满足交换性，既不管异或的顺序是怎样，最终得到的结果都是一样的。</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<h3 id="算法3-二分查找"><a href="#算法3-二分查找" class="headerlink" title="算法3: 二分查找"></a>算法3: 二分查找</h3><p>如果我们将题设条件再一次加强，既数组中其他元素出现2次，只有一个元素出现1次，并且数组中的元素有序。那我们就可以使用更加高效的算法。</p>
<p><code>mid = (start + end) / 2</code>mid指向的是数组的中间元素，我们要<strong>保证mid前面正好有偶数个元素</strong>，既<code>if(mid % 2 == 1) mid--;</code></p>
<p>1）如果重复1次的数字出现在前半部分或中间，则<code>nums[mid]</code>应该和后面一个数字<strong>不等</strong>，我们就在前半部分（包括总结元素）继续搜索。</p>
<p>2）如果重复1次的数字出现在后半部分，则<code>nums[mid]</code>应该和后面一个数字<strong>相等</strong>，我们就在后半部分继续搜索。</p>
<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(1)</p>
<h3 id="算法4-逐个异或-子数组划分"><a href="#算法4-逐个异或-子数组划分" class="headerlink" title="算法4: 逐个异或+子数组划分"></a>算法4: 逐个异或+子数组划分</h3><p>如果题目要求在一个乱序的数组中，有2个数字出现了1次，其他数字都出现了两次，要我们找到这两个数字。那么我们用算法2逐个异或数组中的元素，得到的就是这两个只出现一次的数字的异或结果。</p>
<p>为了能分别得到这两个数字，我们需要将原数组分组，分组的方法是<strong>使用两个数字异或结果中第一个为1的位对原数组进行分组</strong>（异或结果为1说明这两个数的二进制码在这个位置上是不同的），使这两个只出现1次的数字分别分到两个不同的组里，这样再对这两个组分别使用算法2，就可以得到这两个数字。</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<h3 id="算法5-位操作"><a href="#算法5-位操作" class="headerlink" title="算法5: 位操作"></a>算法5: 位操作</h3><p>如果题目中要求在一个乱序数组中，只有1个数字出现了1次，其他数组出现了3次，要我们找出这个只出现1次的数字target。那么我们除了使用算法1对数组元素出现的次数进行统计外，还可以使用位操作。</p>
<p>由于数组中其他数字都出现了3次，那么我们累加每个元素的第i位（i：0～31），如果累加结果能被3整除，说明target在这一位上是0，如果累加结果不能被3整除，说明target在这一位上是1，对32位进行累加对3取余后，我们就可以得到target。</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中重复的数字</title>
    <url>/2018/05/03/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>找出数组中重复的数字。</p>
<p>相关题目：剑指Offer面试题3: 数组中重复的数字。</p>
<a id="more"></a>

<hr>
<p><font color=red><strong>问题1: 数组中元素的取值范围是多少？数组的长度？</strong><br /></font></p>
<p><font color=red><strong>问题2: 数组是否可以修改？</strong><br/></font></p>
<p><font color=red><strong>问题3: 数组中重复元素有多少？找出多少重复元素？</strong><br /></font></p>
<p><font color=red><strong>问题4: 异常情况怎么处理，如数组为null，数组长度小于2，数组中不包含重复元素，如果数组元素取值范围是0～n-1但是数组中包含大于n-1的元素，这些情况应该怎么处理。</strong><br /></font></p>
<hr>
<h3 id="算法1-排序-遍历"><a href="#算法1-排序-遍历" class="headerlink" title="算法1: 排序+遍历"></a>算法1: 排序+遍历</h3><p>如果数组<strong>可以修改</strong>，并且元素的取值范围比较大，例如：从Integer.MIN_VALUE到Integer.MAX_VALUE。那最简单的算法就是将数组排序，重复的元素就会被放到一起，然后遍历数组找到重复元素。</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(1)</p>
<h3 id="算法2-每次将一个数字交换到相应位置"><a href="#算法2-每次将一个数字交换到相应位置" class="headerlink" title="算法2: 每次将一个数字交换到相应位置"></a>算法2: 每次将一个数字交换到相应位置</h3><p>如果题目中给出附加条件：<font color=red><strong>数组中元素的取值范围是0～n-1</strong></font>。那么我们可以利用这个条件对该算法做进一步优化。</p>
<p>由于数组中元素取值范围是0～n-1，那么将数组排好序以后，每个元素的值应该和其下标相等。利用这个性质，我们在遍历数组的过程中，每次将一个数交换到正确位置，如果在交换过程中发现重复元素，则返回。</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<h3 id="算法3-每次将一个位置标记为负数"><a href="#算法3-每次将一个位置标记为负数" class="headerlink" title="算法3: 每次将一个位置标记为负数"></a>算法3: 每次将一个位置标记为负数</h3><p>在算法2中我们每次将一个元素交换到指定位置，但是当前指针下就右会出现一个新的数字，我们需要继续将这个新的数字交换到指定位置，指针不能向前移动，这种情况下算法2的时间复杂度实际上比O(n)要大，我们可以对算法2做进一步优化，使其最坏情况下的时间复杂度降到O(n)。</p>
<p>对于每一个数字，我们知道它的最终位置在哪，我们并不将这个数字交换到指定的位置，而是在指定位置做一个标记，说明这个数字我们已经访问过了，我们做的标记，就是将指定位置的数字变为负数，下次如果我么右来到这个位置，看到该位置的数字为负数的时候，我们就找到了一个重复数字。这样对于每个元素，仅需要遍历一次我们就可以知道它是不是重复元素，相较于算法2，时间性能又大幅提升了。</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<p>这个算法的例子见：Leetcode442. Find All Duplicates in an Array</p>
<h3 id="算法4-Hash数组统计元素是否出现"><a href="#算法4-Hash数组统计元素是否出现" class="headerlink" title="算法4: Hash数组统计元素是否出现"></a>算法4: Hash数组统计元素是否出现</h3><p>如果数组<strong>不可以修改</strong>，我们可以使用HashMap统计元素是否出现，然后遍历HashMap找出重复数字。</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<p>由于HashMap只是统计元素是否出现，我们完全可以使用一个<strong>boolean数组</strong>代替HashMap来降低一些空间复杂度。我们可以先找出数组中最大数max和最小数min来确定boolean数组的长度<strong>len = max - min + 1</strong>，然后每次从原数组中取出一个元素m，将<strong>boolean[m - min]置为true</strong>，如果发现该位置已经为true，那说明该元素就是重复元素。</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<p>我们继续优化算法来避免O(n)的空间复杂度。</p>
<h3 id="算法5-二分统计"><a href="#算法5-二分统计" class="headerlink" title="算法5: 二分统计"></a>算法5: 二分统计</h3><p>如果数组<strong>不可以修改</strong>，<strong>并且数组中元素的取值范围是0～n-1</strong>。</p>
<p>和算法4类似，该算法也需要统计元素出现的次数，但不同的是，这次我们基于分治法的思想，统计一个区间内元素出现的次数，从而降低时间复杂度。</p>
<p>由于已知数组中元素的取值范围在0～n-1之间，我们可以将这个区间分为0～n/2-1和n/2～n-1两个区间，分别统计数组中在这两个区间内的元素出现的次数，如果一个区间内元素出现的次数超过了区间的长度，那说明该区间内肯定存在重复元素，接下来，我们再将这个区间一分为二，统计元素出现的次数，直到找到重复元素为止。</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(1)</p>
<p>和算法4相比该算法相当于用时间换空间。</p>
<p>需要指出的是：<strong>该算法不一定每次都能找到重复数字！</strong>例如对于数组[2,2,3,4,5,6]，在1～3范围内元素出现的次数是3次，在4～6范围内元素出现的次数也是3次，算法找不到重复数字。</p>
<h3 id="算法6-将数组映射为有环链表"><a href="#算法6-将数组映射为有环链表" class="headerlink" title="算法6: 将数组映射为有环链表"></a>算法6: 将数组映射为有环链表</h3><p><strong>如果数组中的元素取值范围是0～n-1。</strong></p>
<p>那么我们就可以将数组映射为一个有环链表，用链表中判断环入口节点的算法就可以找到重复元素。</p>
<p><strong>映射规则：以元素下标作为node.val，以元素值作为node.next。当两个node.next值相同时链表中就会产生环。</strong></p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<p>这个算法有个很明显的问题：<strong>如果一个元素的值和其下标相同时，映射为节点时相当于节点的next指针指向该节点本身，链表就断了。</strong></p>
<p>如果题目可以去掉数组不可修改(read-only)这个条件，这个问题就很容易解决，我们只需要遍历数组，将元素值和其下标相等的元素和相邻元素对换，直到数组中每个元素的值都不等于其下标为止。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>如果数组中元素的取值范围很大，那么我们只能使用排序+遍历和HashMap统计次数这两种算法。</li>
<li>如果数组中元素的取值范围在数组长度范围内，我们就可以分别对排序+遍历算法和HashMap算法进行优化，优化过后的排序+遍历算法性能最好，达到O(n)的时间复杂度。并且还可以用二分统计和有环链表算法。</li>
<li>如果题目中又给出read-only条件，那么排序+遍历算法就不能用了，可以使用的算法只有二分统计和HashMap统计，由于二分统计存在缺陷，所以最优的算法只有Hash数组统计了。</li>
</ul>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口算法</title>
    <url>/2018/06/12/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>滑动窗口算法可以应用在很多查找字符串子串的算法中。</p>
<p>参考：<a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/discuss/92007/Sliding-Window-algorithm-template-to-solve-all-the-Leetcode-substring-search-problem.">Sliding Window algorithm template to solve all the Leetcode substring search problem.</a></p>
<a id="more"></a>

<hr>
<h4 id="算法1-基本滑动窗口算法"><a href="#算法1-基本滑动窗口算法" class="headerlink" title="算法1: 基本滑动窗口算法"></a>算法1: 基本滑动窗口算法</h4><p>使用HashMap存储target字符串中字符出现的次数，适用范围最广。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">slidingWindowTemplate</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化一个集合用来存储结果</span></span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(t.length()&gt; s.length()) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个HashMap用来存储目标子串中字符的出现次数</span></span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t.toCharArray())&#123;</span><br><span class="line">        map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//维护一个counter检查是否和目标串匹配</span></span><br><span class="line">    <span class="comment">//这里是map.size()而不是t.size()所以下面counter--的时候判断条件是map.get(c)==0</span></span><br><span class="line">    <span class="comment">//如果这里是t.length()由于可能存在重复数字，若以下面counter--的时候判断条件应该是map.get(c)&gt;0 </span></span><br><span class="line">    <span class="keyword">int</span> counter = map.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个指针：begin:滑窗的左指针，end:滑窗的右指针</span></span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(end &lt; s.length())&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(end);</span><br><span class="line">        <span class="keyword">if</span>( map.containsKey(c) )&#123;</span><br><span class="line">            map.put(c, map.get(c)-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(map.get(c) == <span class="number">0</span>) counter--;</span><br><span class="line">        &#125;</span><br><span class="line">        end++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(counter == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">char</span> tempc = s.charAt(begin);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(tempc))&#123;</span><br><span class="line">                map.put(tempc, map.get(tempc) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(map.get(tempc) &gt; <span class="number">0</span>) counter++;</span><br><span class="line">            &#125;</span><br><span class="line">            begin++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一直target中字符的取值范围，如target中只包含大写字母、小写字母或数字，则该算法可以进一步优化，主要的优化点就是将HashMap换成数组，对数组的操作要比对HashMap的entry操作快很多。</p>
<h4 id="算法2-使用数组作为map的滑动窗口算法"><a href="#算法2-使用数组作为map的滑动窗口算法" class="headerlink" title="算法2: 使用数组作为map的滑动窗口算法"></a>算法2: 使用数组作为map的滑动窗口算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : p.toCharArray())</span><br><span class="line">        map[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = p.length();</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> end = <span class="number">0</span>; end &lt; s.length(); end++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[s.charAt(end)]-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//if (end - start + 1 == p.length())</span></span><br><span class="line">                <span class="comment">//res.add(start);</span></span><br><span class="line">            <span class="keyword">if</span> (++map[s.charAt(start)] &gt; <span class="number">0</span>)</span><br><span class="line">                count++;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>连续子数组最大累乘积</title>
    <url>/2017/07/01/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E7%B4%AF%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<p>求连续子数组的最大乘积。相关题目：Leetcode 152. Maximum Product Subarray</p>
<a id="more"></a>

<blockquote>
<p>题目：给定一个double类型的数组arr，其中的元素可正、可负、可0，返回子数组的最大乘积。如 arr=[-2.5, 4, 0, 3, 0.5, 8, -1]，子数组[3, 0.5, 8]累乘积可以获得最大值12.</p>
</blockquote>
<h4 id="算法：动态规划"><a href="#算法：动态规划" class="headerlink" title="算法：动态规划"></a>算法：动态规划</h4><p>设以arr[i-1]结尾的最小累成积min，以a[i-1]结尾的最大累成积为max，那么以arr[i]结尾的最大累乘积只有以下三种可能：</p>
<ol>
<li>max(arr[1]) * arr[2]，如[3, 4, 5]</li>
<li>min(arr[1]) * arr[2]，如[-2, 3, -4]</li>
<li>arr[2]，如[0.1 ,0.1, 100]</li>
</ol>
<p>这三种结果中最大的就作为以arr[i]的最大累乘积，最小的作为arr[i]的最小累乘机，然后再计算arr[i+1]。</p>
<p>结果 = Max{以arr[0]结尾的所有子数组的最大累乘积, 以arr[1]结尾的所有子数组的最大累乘积, …… , 以arr[arr.length - 1]结尾的所有子数组的最大累乘积}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">double</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">double</span> min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">double</span> res = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">double</span> maxEnd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> minEnd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">        maxEnd = max * arr[i];</span><br><span class="line">        minEnd = min * arr[i];</span><br><span class="line">        max = Math.max(Math.max(maxEnd, minEnd), arr[i]);</span><br><span class="line">        min = Math.min(Math.min(maxEnd, minEnd), arr[i]);</span><br><span class="line">        res = Math.max(res, max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>数组</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>重建二叉树算法总结</title>
    <url>/2018/03/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>输入二叉树的前序遍历序列和中序遍历序列，重建二叉树。</p>
<a id="more"></a>

<p>下面代码假设输入序列是：前序遍历序列和中序遍历序列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reBuild(pre, in, <span class="number">0</span>, pre.length-<span class="number">1</span>, <span class="number">0</span>, in.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * reBuid函数参数的定义很重要！！！节点在前序遍历序列和后序遍历序列中的开始和结束位置，一定要分开定义</span></span><br><span class="line"><span class="comment">     * 不然在算法中会产生歧义。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reBuild</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preStart &gt;= preEnd) &#123;</span><br><span class="line">            <span class="keyword">if</span> (preStart == preEnd) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(pre[preStart]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> inRoot = find(inStart, inEnd, pre[preStart], in);</span><br><span class="line">        <span class="keyword">int</span> lengthOfLeft = inRoot - inStart;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[preStart]);</span><br><span class="line">        root.left = reBuild(pre, in, preStart+<span class="number">1</span>, preStart+lengthOfLeft, inRoot-lengthOfLeft, inRoot-<span class="number">1</span>);</span><br><span class="line">        root.right = reBuild(pre, in, preStart+lengthOfLeft+<span class="number">1</span>, preEnd, inRoot+<span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> val, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val == in[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式（Proxy Pattern）</title>
    <url>/2018/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>代理模式是一种结构型设计模式，这种设计模式对外界提供了一种代理对象用来控制对委托对象的访问。 </p>
<a id="more"></a>

<hr>
<p>代理模式就是使用一个类代表另一个类的功能。</p>
<p><img src="%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png" alt="代理模式"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCar</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyCar is running..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCarProxy</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyCar myCar;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCarProxy</span><span class="params">(MyCar myCar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myCar = myCar;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//添加其他功能。。。</span></span><br><span class="line">        myCar.run();</span><br><span class="line">        <span class="comment">//添加其他功能。。。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用代理对象执行MyCar的run()方法，在run()方法执行之前和之后都可以做一些其他工作，比如记录日志，记录时间等。这就是代理模式的基本思想。</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>上面对代理模式的实现就是静态代理，静态代理看上去非常简单直接，但是存在一个问题，如果需要对多个类进行代理，我们需要为每一个类都实现一个代理类，如果这些代理类实现相同的功能，就会出现很多重复代码。如果我们需要为很多类进行代理，而且代理的功能相同，我们就需要用到动态代理。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理可以动态地生成各个委托类的代理对象，只需要为一类代理行为写一个具体的实现类。动态代理类的字节码文件是在程序运行时动态生成的，这是动态代理和静态代理最大的区别。</p>
<h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCar</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyCar is running..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyCar is stop..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDynamicProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car car = <span class="keyword">new</span> MyCar();</span><br><span class="line">        Car proxyInstance = (Car)Proxy.newProxyInstance(car.getClass().getClassLoader(), car.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"do something before..."</span>);</span><br><span class="line">                Object result = method.invoke(car, args);</span><br><span class="line">                System.out.println(<span class="string">"do something after..."</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        proxyInstance.run();</span><br><span class="line">        proxyInstance.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出：</span><br><span class="line">do something before...</span><br><span class="line">MyCar is running...</span><br><span class="line">do something after...</span><br><span class="line">do something before...</span><br><span class="line">MyCar is stop...</span><br><span class="line">do something after...</span><br></pre></td></tr></table></figure>

<p>上面是JDK动态代理，可以看到JDK动态代理是使用<code>Proxy.newProxyInstance(ClassLoader, Interfaces, InvocationHandler)</code>来得到新的代理对象，该静态方法中的三个参数分别是：</p>
<ul>
<li>ClassLoader：委托类的类加载器，可以通过<code>Car.getClass().getClassLoader()</code>得到。</li>
<li>Interfaces：委托类实现的接口，可以通过<code>Car.getClass().getInterfaces()</code>得到。</li>
<li>InvocationHandler：调用委托类方法时的处理器。</li>
</ul>
<p>使用代理对象调用委托对象的方法时，都会进入InvocationHandler的<code>publci Object invoke(Object proxy, Method method, Object[] args)</code>方法中，在这个方法里，可以自定义在执行委托方法前后，要执行的操作，在invoke方法中可以使用<code>method.invoke(委托类对象, args);</code>来执行使用代理对象调用的委托对象方法。invoke函数中的三个参数分别代表：</p>
<ul>
<li>proxy：代理对象。</li>
<li>method：代理对象执行的委托对象中的方法。</li>
<li>args：方法中的传入参数。</li>
</ul>
<p>注意：在使用method.invoke()方法调用委托对象方法的时候第一个参数传入的是原委托对象，而不是代理对象。</p>
<h4 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h4><p>JDK动态代理利用反射机制，基于接口生成代理对象，如果委托对象没有实现接口，我们就需要使用CGLIB动态代理。CGLIB (Code Generation Library)是一个基于<a href="https://www.ibm.com/developerworks/cn/java/j-lo-asm30/index.html">ASM</a>的字节码生成库，CGLIB通过<strong>继承</strong>产生子类覆盖非final方法来进行代理，由于采用继承实现动态代理所以CGLIB不能代理一个final类或者final方法。CGLIB比使用Java反射的JDK动态代理方法更快。</p>
<p>首先定义一个委托类SayHello，这个类里面只有一个sayHello方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SayHello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"SayHello: Hello "</span> + str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过CGLIB的Enhancer对象来指定委托对象和调用委托对象方法时的处理函数，然后通过Enhancer的create方法得到代理对象。对代理对象所有非final方法的调用都会转发给MethodInterceptor.intercept()方法，在intercept()方法中可以加入任意操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCGLIBProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    enhancer.setSuperclass(SayHello<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    enhancer.setCallback(<span class="keyword">new</span> MyMethodInterceptor());</span><br><span class="line">    SayHello sayHello = (SayHello) enhancer.create();</span><br><span class="line">    System.out.println(sayHello.sayHello(<span class="string">"I LOVE YOU"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Enhancer中的回调函数需要我们实现MethodInterceptor接口然后重写里面的intercept方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is MethodIntercetpor-&gt;intercept()"</span>);</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在intercept方法中有4个参数，含义如下：</p>
<ul>
<li>o：代表委托对象。</li>
<li>method：代表代理对象执行的委托对象方法。</li>
<li>objects：代表方法中传入的参数。</li>
<li>methodProxy：代表代理对象。</li>
</ul>
<p>在intercept方法中可以使用<code>methodProxy.invokeSuper(o, objects);</code>来调用委托对象中的原生方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>代理模式就是给外界提供一个代理类，来控制对委托类的访问或者实现其他功能。代理模式有两种实现方法：静态代理和动态代理。静态代理是手动编写或者使用工具生成代理类，特点是在程序运行前代理类的.class文件就已经存在，代理不同的类就需要编写不同的代理类。而动态代理是在程序运行期间动态的生成代理类的.class文件，对于一类代理操作，只需要实现一个代理类即可代理不同的类。实现动态代理有两种方法，一种是使用Java反射机制，通过实现和委托类相同的接口，来生成代理类的字节码文件，这种方式是JDK动态代理。另一种是通过继承产生子类覆盖委托方法的方式实现代理，这种方式是CGLIB动态代理。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>单例模式（Singleton Pattern）</title>
    <url>/2018/03/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>五种方式构建单例模式：懒汉式，饿汉式，双重检测锁（不推荐），静态内部类（推荐），枚举单类（推荐）</p>
<a id="more"></a>

<p><strong>单例模式就是保证一个类只有一个实例（对象），并且提供一个访问该实例的全局访问点。</strong></p>
<p>当一个对象的产生需要比较多资源时，如读取配置、产生其他依赖对象时，则可以在应用启动时直接产生一个单例对象，然后驻留内存的方式来解决。</p>
<p>由于单例模式只生成一个实例，减少了系统开销。单例模式可以设置全局访问点，优化共享资源访问，如可以设计一个单例类，负责所有数据表的映射处理。</p>
<p>常见5种单例模式实现方式：</p>
<h4 id="1-饿汉式（线程安全，调用效率高，不能延时加载）"><a href="#1-饿汉式（线程安全，调用效率高，不能延时加载）" class="headerlink" title="1 饿汉式（线程安全，调用效率高，不能延时加载）"></a>1 饿汉式（线程安全，调用效率高，不能延时加载）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类初始化时立即加载这个对象，没有延时加载的优势，加载类时，是线程安全的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-懒汉式（线程安全，调用效率不高，可以延时加载）"><a href="#2-懒汉式（线程安全，调用效率不高，可以延时加载）" class="headerlink" title="2 懒汉式（线程安全，调用效率不高，可以延时加载）"></a>2 懒汉式（线程安全，调用效率不高，可以延时加载）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> /*<span class="keyword">implements</span> <span class="title">Serializable</span>*/ </span>&#123;</span><br><span class="line">    <span class="comment">//类初始化时，不初始化这个对象，延时加载（懒加载），真正用的时候再创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//防止反射漏洞可以加上一下语句</span></span><br><span class="line">        <span class="comment">/*if (instance != null) &#123;</span></span><br><span class="line"><span class="comment">            throw new RuntimeException(); //如果instance不为空，再创建的时候抛出异常</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法同步调用效率低</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//防止反序列化生成多个对象</span></span><br><span class="line">    <span class="comment">//反序列化时，如果定义了reaResolve()则直接返回此方法指定的对象，而不需要单独创建新对象</span></span><br><span class="line">    <span class="comment">/*private Object readResolve() throws ObjectStreamException &#123;</span></span><br><span class="line"><span class="comment">        return instance;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用反射方式直接调用私有构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;Singleton&gt; class = (Class&lt;Singleton&gt;) class.forName("com.xinxing.Singleton");</span><br><span class="line">Constructor&lt;Singleton&gt; constructor = <span class="class"><span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">null</span>)</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span>.<span class="title">setAccessible</span>(<span class="title">true</span>)</span>; <span class="comment">//关闭权限访问检测，以访问私有成员</span></span><br><span class="line">Singleton s1 = constructor.newInstance();</span><br><span class="line">Singleton s2 = constructor.newInstance(); <span class="comment">//如果上面没有防漏洞代码，这里s1和s2不相等</span></span><br></pre></td></tr></table></figure>

<p>通过反序列化的方式构造多个对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Singleton s1 = Singleton.getInstance();</span><br><span class="line"></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:/a.txt"</span>);</span><br><span class="line">OubjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">oos.writeObject(s1); <span class="comment">//将s1对象写出到文件</span></span><br><span class="line">oos.close();</span><br><span class="line">fos.close();</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"d:/a.txt"</span>));</span><br><span class="line">Singleton s2 = (Singleton) ois.readObject(); <span class="comment">//此时如果没有上面的房序列化代码，这里的s1和s2不同</span></span><br></pre></td></tr></table></figure>



<h4 id="3-静态内部类式（线程安全，调用效率高，可以延时加载）（推荐使用）"><a href="#3-静态内部类式（线程安全，调用效率高，可以延时加载）（推荐使用）" class="headerlink" title="3 静态内部类式（线程安全，调用效率高，可以延时加载）（推荐使用）"></a>3 静态内部类式（线程安全，调用效率高，可以延时加载）（推荐使用）</h4><p>类在被加载时是线程安全的，也是一种懒加载方式，很多框架都用这种框架。</p>
<ul>
<li>外部类没有static属性，则不会像饿汉模式那样立即加载对象。</li>
<li>只有真正调用getInstanc()时，才会加载静态内部类，加载类时是线程安全的，instance是static final类型，保证了内存中只有这样一个实例存在，而且只能被赋值一次。</li>
<li>兼备了线程安全、并发高效、延迟加载的优势</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用静态内部类实现懒加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInnerClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonClass.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-枚举单例（线程安全，调用效率高，不能延时加载）（建议使用）"><a href="#4-枚举单例（线程安全，调用效率高，不能延时加载）（建议使用）" class="headerlink" title="4 枚举单例（线程安全，调用效率高，不能延时加载）（建议使用）"></a>4 枚举单例（线程安全，调用效率高，不能延时加载）（建议使用）</h4><p>优点：有句JVM从根本上提供保障，避免和反射和反序列化调用私有方法的漏洞，简单高效</p>
<p>缺点：没有延时加载的效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    <span class="comment">//定义一个枚举元素，它就代表了Singelton的一个实例</span></span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="comment">//添加自己需要的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singletonOperation</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方法</span></span><br><span class="line">Singleton s = Singleton.INSTANCE; <span class="comment">//获得Singleton对象</span></span><br></pre></td></tr></table></figure>



<h4 id="5-双重检测锁式（不建议使用）"><a href="#5-双重检测锁式（不建议使用）" class="headerlink" title="5 双重检测锁式（不建议使用）"></a>5 双重检测锁式（不建议使用）</h4><p>由于懒汉模式是将方法放到同步块里，执行时整个方法都被锁定效率比较低，该模式将同步内容放到if内部，提高了执行效率，不必每次获取对象时都进行同步，只有第一次才同步创建以后就不会同步了。</p>
<p>问题：由于编译器优化原因和JVM底层内部模型原因，偶尔会出现问题，不建议使用</p>
<h4 id="五种单例模式在多线程环境下的效率"><a href="#五种单例模式在多线程环境下的效率" class="headerlink" title="五种单例模式在多线程环境下的效率"></a>五种单例模式在多线程环境下的效率</h4><table>
<thead>
<tr>
<th>饿汉式</th>
<th>22ms</th>
</tr>
</thead>
<tbody><tr>
<td>懒汉式</td>
<td>636ms</td>
</tr>
<tr>
<td>静态内部类式</td>
<td>28ms</td>
</tr>
<tr>
<td>枚举式</td>
<td>32ms</td>
</tr>
<tr>
<td>双重检查锁式</td>
<td>65ms</td>
</tr>
</tbody></table>
<h4 id="典型的应用场景："><a href="#典型的应用场景：" class="headerlink" title="典型的应用场景："></a>典型的应用场景：</h4><ul>
<li>windows的任务管理器</li>
<li>window的回收站</li>
<li>项目中读取配置文件的类</li>
<li>网站计数器</li>
<li>应用程序的日志应用</li>
<li>数据库连接池</li>
<li>操作系统的文件系统</li>
<li>Application(Servlet Context）</li>
<li>Spring 中每个bean默认就是单例</li>
<li>Servlet编程中，每个Servlet也是单例</li>
<li>SpringMVC/struts中控制对象</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>工厂模式（Factory Pattern）</title>
    <url>/2018/03/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>工厂模式实现了<strong>创建者</strong>和<strong>调用者</strong>的分离，分为<strong>简单工厂模式</strong>、<strong>工厂方法模式</strong>、<strong>抽象工厂模式</strong>。</p>
<p>实例化对象，用工厂方法代替new操作</p>
<p>将选择实现类、创建对象统一管理控制，将调用者跟实现类解耦。</p>
<a id="more"></a>


<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>因为工厂类的一般是使用静态方法，所以简单工厂模式也叫静态工厂模式，通过接收的参数的不同来返回不同的对象实例。用来生产同一等级结构中的任意产品。增加新的产品，需要修改以有的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audi</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Audi is running"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Benz</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Benz is running"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单工厂实现方式1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createCar</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"Audi"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Audi();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"Benz"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Benz();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ...;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单工厂实现方式2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createAudi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Audi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createBenz</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Benz();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car c1 = CarFactory01.createCar(<span class="string">"Audi"</span>);</span><br><span class="line">        Car c2 = CarFactory02.createCar(<span class="string">"Benz"</span>);</span><br><span class="line">        c1.run(); <span class="comment">//Audi is running</span></span><br><span class="line">        c2.run(); <span class="comment">//Benz is running</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>简单工厂模式的UML图如下所示：</p>
<p><img src="%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FUML.png" alt="简单工厂模式UML"></p>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>为了避免简单工厂模式的缺点（不满足开闭原则，即要进行扩展必须修改代码），出现了工厂方法模式。工厂方面模式和简单工厂模式最大的不同在于，简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。</p>
<p>用来生产同一等级结构中的固定产品。支持增加任意产品</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Audi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BenzFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Benz();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car c1 = AudiFactory.createCar();</span><br><span class="line">        Car c2 = BenzFactory.createCar();</span><br><span class="line">        c1.run(); <span class="comment">//Audi is running</span></span><br><span class="line">        c2.run(); <span class="comment">//Benz is running</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在如果想要在增加一个BMW工厂，只需要在新建一个BMWFactory类实现Car接口就可以，现有的类和接口都不需要修改。</p>
<p>工厂方法模式UML图如下：</p>
<p><img src="%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8FUML.png" alt="工厂方法模式UML"></p>
<p>根据设计理论，工厂方法模式更优，但是由于工厂方法模式的结构、代码、编程难道和管理上都比简单工厂模式要复杂，所以实际上一般都使用简单工厂模式。</p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>用来生产不同<strong>产品族</strong>的全部产品。对于增加新的产品，无能为力；支持增加产品族。</p>
<p>在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。</p>
<p>抽象工厂模式UML图如下所示：<br><img src="%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FUML.png" alt="抽象工厂模式UML"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>简单工厂模式（静态工厂模式）</strong></p>
<ul>
<li>虽然某种程度不符合设计原则，但实际使用最多</li>
</ul>
<p><strong>工厂方法模式</strong></p>
<ul>
<li>不修改以有类的前提下，通过增加新的工厂类实现扩展</li>
</ul>
<p><strong>抽象工厂模式</strong></p>
<ul>
<li>不可以增加产品，可以增加产品族</li>
</ul>
<h4 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h4><ul>
<li>JDK中Calendar的getInstance方法</li>
<li>JDBC中Connection对象的获取</li>
<li>Hibernate中SessionFactory创建Session</li>
<li>Spring中IOC容器创建管理管理bean对象</li>
<li>XML解析时的DocumentBuilderFactory创建解析器对象</li>
<li>反射中Class对象的newInstance()</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>建造者模式（Builder Pattern）</title>
    <url>/2018/03/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>当我们要构造的对象非常复杂，即对象中的组件需要有顺序的被构建时，就应该使用建造者模式。</p>
<a id="more"></a>

<p>实际开发中，建造者模式通常用来构造复杂对象。建造者模式分离了对象子组件的构造（Build）和装配（Direct），构造由Builder负责，装配有Director负责。每个组件由Builder单独构建，然后再交给Director组装，从而可以构造出非常复杂的对象。</p>
<p>由于实现了构造和装配的解耦，不同的Builder，相同的Director，也可以造出不同对象。相同的Builder，不同的Director也可以做出不同的对象。也就是实现了构造算法、装配算法的解耦，实现了更好的复用。</p>
<p>建造者模式UML如下图所示：</p>
<p><img src="%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8FUML.png" alt="建造者模式UML"></p>
<p>组件类定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrbitalModule</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OrbitalModule</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Engine</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EscapeTower</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">EscapeTower</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>飞船类定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirShip</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> OrbitalModule orbitalModule;  <span class="comment">//轨道舱</span></span><br><span class="line">	<span class="keyword">private</span> Engine engine; <span class="comment">//发动机</span></span><br><span class="line">	<span class="keyword">private</span> EscapeTower escapeTower;  <span class="comment">//逃逸塔</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//这里可以自定义方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lunch</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> OrbitalModule <span class="title">getOrbitalModule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> orbitalModule;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrbitalModule</span><span class="params">(OrbitalModule orbitalModule)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.orbitalModule = orbitalModule;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Engine <span class="title">getEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> engine;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEngine</span><span class="params">(Engine engine)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.engine = engine;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> EscapeTower <span class="title">getEscapeTower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> escapeTower;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEscapeTower</span><span class="params">(EscapeTower escapeTower)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.escapeTower = escapeTower;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Builder接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AirShipBuilder</span> </span>&#123;</span><br><span class="line">	<span class="function">Engine <span class="title">builderEngine</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">OrbitalModule <span class="title">builderOrbitalModule</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">EscapeTower  <span class="title">builderEscapeTower</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Builder实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAirShipBuilder</span> <span class="keyword">implements</span> <span class="title">AirShipBuilder</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Engine <span class="title">builderEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Engine(<span class="string">"MyEngine"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> EscapeTower <span class="title">builderEscapeTower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> EscapeTower(<span class="string">"MyEscapeTower"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> OrbitalModule <span class="title">builderOrbitalModule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> OrbitalModule(<span class="string">"MyOrbitalModule"</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Director接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AirShipDirector</span> </span>&#123;</span><br><span class="line">	<span class="function">AirShip   <span class="title">directAirShip</span><span class="params">()</span></span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Director实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAirshipDirector</span> <span class="keyword">implements</span> <span class="title">AirShipDirector</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> AirShipBuilder builder;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyAirshipDirector</span><span class="params">(AirShipBuilder builder)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.builder = builder;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> AirShip <span class="title">directAirShip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Engine e = builder.builderEngine();</span><br><span class="line">		OrbitalModule o = builder.builderOrbitalModule();</span><br><span class="line">		EscapeTower et = builder.builderEscapeTower();</span><br><span class="line">		AirShip ship = <span class="keyword">new</span> AirShip();</span><br><span class="line">		ship.setEngine(e);</span><br><span class="line">		ship.setEscapeTower(et);</span><br><span class="line">		ship.setOrbitalModule(o);</span><br><span class="line">		<span class="keyword">return</span> ship;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		AirShipDirector director = <span class="keyword">new</span> SxtAirshipDirector(<span class="keyword">new</span> SxtAirShipBuilder());</span><br><span class="line">		AirShip ship = director.directAirShip(); <span class="comment">//到这里就构建好了一个Airship</span></span><br><span class="line">		</span><br><span class="line">        ship.launch(); <span class="comment">//调用自定义方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>典型应用场景：</strong></p>
<ul>
<li>StringBuilder类的append方法</li>
<li>SQL中的PreparedStatement</li>
<li>JDOM中的DomBuilder, SAXBuilder</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计原则及设计模式分类</title>
    <url>/2018/01/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>本文是对所有设计模式的分类以及说明。</p>
<a id="more"></a>

<hr>
<h3 id="面向对象程序设计的五大基本原则SOLID"><a href="#面向对象程序设计的五大基本原则SOLID" class="headerlink" title="面向对象程序设计的五大基本原则SOLID"></a>面向对象程序设计的五大基本原则SOLID</h3><h4 id="S-单一功能原则（Single-Responsibility-Principle）"><a href="#S-单一功能原则（Single-Responsibility-Principle）" class="headerlink" title="S 单一功能原则（Single Responsibility Principle）"></a>S 单一功能原则（Single Responsibility Principle）</h4><p><strong>单一功能原则</strong>规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。</p>
<h4 id="O-开闭原则（Open-Closed-Principle）"><a href="#O-开闭原则（Open-Closed-Principle）" class="headerlink" title="O 开闭原则（Open-Closed Principle）"></a>O 开闭原则（Open-Closed Principle）</h4><p><strong>开闭原则</strong>规定“<em>软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的</em>”<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99#cite_note-1">[1]</a>，这意味着一个实体是允许在不改变它的源代码的前提下变更它的行为。</p>
<h4 id="L-里氏替换原则（Liskov-Substitution-Principle）"><a href="#L-里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="L 里氏替换原则（Liskov Substitution Principle）"></a>L 里氏替换原则（Liskov Substitution Principle）</h4><p><strong>里氏替换原则</strong>是对子类型的特别定义，它规定派生类（子类）对象能够替换其基类（超类）对象被使用。</p>
<h4 id="I-接口隔离原则（Interface-Segregation-Principle"><a href="#I-接口隔离原则（Interface-Segregation-Principle" class="headerlink" title="I 接口隔离原则（Interface-Segregation Principle)"></a>I 接口隔离原则（Interface-Segregation Principle)</h4><p><strong>接口隔离原则</strong>指明客户（client）应该不依赖于它不使用的方法。接口隔离原则(ISP)拆分非常庞大臃肿的接口成为更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。这种缩小的接口也被称为<strong>角色接口</strong>（role interfaces）。接口隔离原则(ISP)的目的是系统解开耦合，从而容易重构，更改和重新部署。</p>
<h4 id="D-依赖反转原则（Dependency-Inversion-Principle）"><a href="#D-依赖反转原则（Dependency-Inversion-Principle）" class="headerlink" title="D 依赖反转原则（Dependency Inversion Principle）"></a>D 依赖反转原则（Dependency Inversion Principle）</h4><p><strong>依赖反转原则</strong>规定：</p>
<ol>
<li>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于<strong>抽象接口</strong>。</li>
<li>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于<strong>抽象接口</strong>。</li>
</ol>
<h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><h4 id="1-开闭原则（Open-Closed-Principle）"><a href="#1-开闭原则（Open-Closed-Principle）" class="headerlink" title="1. 开闭原则（Open-Closed Principle）"></a>1. 开闭原则（Open-Closed Principle）</h4><h4 id="2-里氏替换原则（Liskov-Substitution-Principle）"><a href="#2-里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="2. 里氏替换原则（Liskov Substitution Principle）"></a>2. 里氏替换原则（Liskov Substitution Principle）</h4><h4 id="3-依赖反转原则（Dependency-Inversion-Principle）"><a href="#3-依赖反转原则（Dependency-Inversion-Principle）" class="headerlink" title="3. 依赖反转原则（Dependency Inversion Principle）"></a>3. 依赖反转原则（Dependency Inversion Principle）</h4><h4 id="4-接口隔离原则（Interface-Segregation-Principle"><a href="#4-接口隔离原则（Interface-Segregation-Principle" class="headerlink" title="4. 接口隔离原则（Interface-Segregation Principle)"></a>4. 接口隔离原则（Interface-Segregation Principle)</h4><h4 id="5-迪米特法则，又称最少知道原则-（Demeter-Principle）"><a href="#5-迪米特法则，又称最少知道原则-（Demeter-Principle）" class="headerlink" title="5. 迪米特法则，又称最少知道原则 （Demeter Principle）"></a>5. 迪米特法则，又称最少知道原则 （Demeter Principle）</h4><p>迪米特法则（最少知道原则）：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<h4 id="6-合成复用原则（Composite-Reuse-Principle）"><a href="#6-合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6. 合成复用原则（Composite Reuse Principle）"></a>6. 合成复用原则（Composite Reuse Principle）</h4><p>合成复用原则：尽量使用合成/聚合的方式，而不是使用继承。</p>
<h4 id="一句话总结："><a href="#一句话总结：" class="headerlink" title="一句话总结："></a>一句话总结：</h4><p>开闭原则：实现热插拔，提高扩展性。</p>
<p>里氏代换原则：实现抽象的规范，实现子父类互相替换；</p>
<p>依赖倒转原则：针对接口编程，实现开闭原则的基础；</p>
<p>接口隔离原则：降低耦合度，接口单独设计，互相隔离；</p>
<p>迪米特法则：功能模块尽量独立；</p>
<p>合成复用原则：尽量使用聚合，组合，而不是继承；</p>
<h3 id="设计模式的类型："><a href="#设计模式的类型：" class="headerlink" title="设计模式的类型："></a>设计模式的类型：</h3><h4 id="一-创建型模式"><a href="#一-创建型模式" class="headerlink" title="一. 创建型模式"></a>一. 创建型模式</h4><p>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p>
<ol>
<li>单例模式（Singleton Pattern）</li>
<li>工场模式（Factory Pattern）<ul>
<li>简单工厂模式（Simple Factory Pattern）</li>
<li>工厂方法模式（Factory Method Pattern）</li>
<li>抽象工厂模式（Abstract Factory Pattern）</li>
</ul>
</li>
<li>创建者模式（Builder Pattern）</li>
<li>原型模式（Prototype Pattern）</li>
</ol>
<h4 id="二-结构型模式"><a href="#二-结构型模式" class="headerlink" title="二. 结构型模式"></a>二. 结构型模式</h4><p>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p>
<ol>
<li>适配器模式（Adapter Pattern）</li>
<li>桥接模式（Bridge Pattern）</li>
<li>过滤器模式（Filter、Criteria Pattern）</li>
<li>组合模式（Composite Pattern）</li>
<li>装饰器模式（Decorator Pattern）</li>
<li>外观模式（Facade Pattern）</li>
<li>享元模式（Flyweight Pattern）</li>
<li>代理模式（Proxy Pattern）</li>
</ol>
<h4 id="三-行为型模式"><a href="#三-行为型模式" class="headerlink" title="三. 行为型模式"></a>三. 行为型模式</h4><p>这些设计模式特别关注对象之间的通信。</p>
<ol>
<li>责任链模式（Chain of Responsibility Pattern）</li>
<li>命令模式（Command Pattern）</li>
<li>解释器模式（Interpreter Pattern）</li>
<li>迭代模式（Iterator Pattern）</li>
<li>中介者模式（Mediator Pattern）</li>
<li>备忘录模式（Memento Pattern）</li>
<li>观察者模式（Observer Pattern）</li>
<li>状态模式（State Pattern）</li>
<li>空对象模式（Null Object Pattern）</li>
<li>策略模式（Strategy Pattern）</li>
<li>模版模式（Template Pattern）</li>
<li>访问中模式（Visitor Pattern）</li>
</ol>
<h4 id="四-J2EE模式"><a href="#四-J2EE模式" class="headerlink" title="四. J2EE模式"></a>四. J2EE模式</h4><p>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 </p>
<ol>
<li>MVC 模式（MVC Pattern）</li>
<li>业务代表模式（Business Delegate Pattern）</li>
<li>组合实体模式（Composite Entity Pattern）</li>
<li>数据访问对象模式（Data Access Object Pattern）</li>
<li>前端控制器模式（Front Controller Pattern）</li>
<li>拦截过滤器模式（Intercepting Filter Pattern）</li>
<li>服务定位器模式（Service Locator Pattern）</li>
<li>传输对象模式（Transfer Object Pattern）</li>
</ol>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB" alt="设计模式之间的关系"></p>
<p>本文参考：</p>
<p><a href="http://www.runoob.com/design-pattern/design-pattern-tutorial.html">设计模式| 菜鸟教程</a></p>
<p><a href="https://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1)">SOLID (面向对象设计)</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>迭代器模式（Iterator Pattern）</title>
    <url>/2018/04/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>迭代器模式（Iterator Pattern）是Java中非常常用的模式，这种模式用于顺序访问集合对象的元素。属于行为型模式。</p>
<a id="more"></a>

<p><strong>迭代器模式（Iterator Pattern）提供一种顺访问聚合对象中各元素的方法。</strong></p>
<p>优点：</p>
<ol>
<li>它支持不同的方式遍历一个聚合对象。</li>
<li>迭代器简化了聚合类，在同一个聚合类上可以有多个迭代器。</li>
<li>在迭代器模式中，增加新的聚合类和新的迭代器类都很方便，无序修改原有代码。</li>
</ol>
<p>缺点：</p>
<ol>
<li>由于迭代器模式将存储数据和遍历数据的职责分离，所以增加新的聚合类需要增加新的迭代器类，类的个数成对增加，如Java所有容器中都有相应的迭代器类，增加了系统的复杂性。</li>
</ol>
<p>ArrayList容器里面的迭代器模式UML图如下所示：</p>
<p><img src="%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%BC%8FUML.png" alt="迭代模式UML"></p>
<p>迭代器类一般是一个容器类的内部类，由于内部类可以很方便的操作容器类的内部属性。</p>
<p>Collection接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Iterator接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ArrayList类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> <span class="keyword">implements</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">//the number of elements it contains</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// prevent creating a synthetic constructor</span></span><br><span class="line">        Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;Integer&gt; c = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        c.add(<span class="number">1</span>);</span><br><span class="line">        c.add(<span class="number">2</span>);</span><br><span class="line">        c.add(<span class="number">3</span>);</span><br><span class="line">        Iterator&lt;Integer&gt; it = c.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">            System.out.print(it.next() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java每个容器里都会提供迭代器。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>MyBatis框架学习笔记</title>
    <url>/2018/07/28/Java-MyBatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><a href="https://github.com/mybatis/mybatis-3">MyBatis</a>前身是Apache的一个开源项目iBatis。MyBatis是一个持久层框架，它对JDBC操作数据库的过程进行封装，开发者只需要关注SQL本身，不需要花费精力去处理注册驱动、创建连接、创建Statement、设置参数、检索结果等操作。</p>
<p>MyBatis通过XML或者注解的方式将要执行的各种Statement配置起来，通过Java对象和Statement中的SQL进行映射生成最终执行的SQL语句，将查询结果映射成Java对象并返回。</p>
<a id="more"></a>

<hr>
<h2 id="回顾：JDBC操作数据库流程"><a href="#回顾：JDBC操作数据库流程" class="headerlink" title="回顾：JDBC操作数据库流程"></a>回顾：JDBC操作数据库流程</h2><ol>
<li>加载mysql驱动</li>
<li>创建连接Connection</li>
<li>定义sql语句</li>
<li>获取预处理语句prepareStatement</li>
<li>设置sql语句参数</li>
<li>向数据库发出sql，执行查询得到结果集</li>
<li>遍历结果集</li>
<li>释放资源</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jdbc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ResultSet resultSet = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement preparedStatement = <span class="keyword">null</span>;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加载mysql数据库驱动</span></span><br><span class="line">            Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">            <span class="comment">// 创建连接</span></span><br><span class="line">            connection = DriverManager.getConnection(<span class="string">"jdbc:mysql://192.168.3.86/mybatis?characterEncoding=utf-8&amp;useSSL=true"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>);</span><br><span class="line">            <span class="comment">// 定义sql语句 ？表示占位符</span></span><br><span class="line">            String sql = <span class="string">"select * from user where username=?"</span>;</span><br><span class="line">            <span class="comment">// 获取预处理statement</span></span><br><span class="line">            preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">            <span class="comment">// 设置参数</span></span><br><span class="line">            preparedStatement.setString(<span class="number">1</span>, <span class="string">"王五"</span>);</span><br><span class="line">            <span class="comment">// 向数据库发出sql执行查询，得到结果集</span></span><br><span class="line">            resultSet = preparedStatement.executeQuery();</span><br><span class="line">            <span class="comment">// 遍历结果集</span></span><br><span class="line">            <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">                System.out.println(resultSet.getString(<span class="string">"id"</span>) + <span class="string">" : "</span> + resultSet.getString(<span class="string">"address"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放资源 从后到前的顺序</span></span><br><span class="line">            <span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    resultSet.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (preparedStatement != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    preparedStatement.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDBC操作数据库存在的问题："><a href="#JDBC操作数据库存在的问题：" class="headerlink" title="JDBC操作数据库存在的问题："></a>JDBC操作数据库存在的问题：</h3><ol>
<li>频繁的创建连接会消耗数据库资源，解决办法是用连接池。</li>
<li>SQL语句是硬编码，查询条件一换要改代码。</li>
<li>SQL参数设置硬编码，不利于维护。</li>
<li>ResultSet遍历起来比较复杂，数据库一改需要改代码。期望查询后能返回一个POJO对象。</li>
</ol>
<h3 id="MyBatis对以上问题的解决："><a href="#MyBatis对以上问题的解决：" class="headerlink" title="MyBatis对以上问题的解决："></a>MyBatis对以上问题的解决：</h3><ol>
<li>在SqlMapConfig.xml中配置数据库连接池，使用连接池管理数据库连接。</li>
<li>将SQL语句配置在mapper.xml文件中与java代码分离。</li>
<li>mybatis自动将java对象映射至SQL语句，通过statement中的parameterType定义输入参数的类型。</li>
<li>MyBatis自动将SQL执行结果映射至java对象，通过statement中的resultType定义输出结果的类型。</li>
</ol>
<h3 id="MyBatis与Hibernate不同"><a href="#MyBatis与Hibernate不同" class="headerlink" title="MyBatis与Hibernate不同"></a>MyBatis与Hibernate不同</h3><p><strong>Hibernate</strong>是一个标准的orm框架，比较重量级，学习成本高。</p>
<p>优点：高度封装，使用起来不用写sql，开发的时候会减低开发周期。</p>
<p>缺点：sql语句无法优化。</p>
<p>应用场景：oa(办公自动化系统)，erp(企业的流程系统)等。还有一些政府项目，总的来说,在用于量不大,并发量小的时候使用.</p>
<p><strong>MyBatis</strong>不是一个orm框架，它是对jdbc的轻量级封装，学习成本低，比较简单</p>
<p>优点：学习成本低，sql语句可以优化，执行效率高，速度快。</p>
<p>缺点：编码量较大，会拖慢开发周期。<br>应用场景：互联网项目，比如电商，P2p等。总的来说是用户量较大，并发高的项目。</p>
<hr>
<h2 id="MyBatis架构"><a href="#MyBatis架构" class="headerlink" title="MyBatis架构"></a>MyBatis架构</h2><p><img src="MyBatis01.png" alt="MyBatis01"></p>
<ol>
<li><strong>SqlMapConfig.xml</strong>：MyBatis全局配置文件，配置了MyBatis运行环境，如数据源、缓存开关、延迟加载开关等。在全局配置文件里面也要加载映射文件Mapper.xml。</li>
<li><strong>Mapper.xml</strong>里面配置SQL语句，以及返回结果集。</li>
<li><strong>SqlSessionFactory</strong>：SQL会话工厂，加载全局配置文件，通过全局配置文件创建SQL会话SqlSession。</li>
<li><strong>SqlSession</strong>：里面包含了操作数据库的方法，SqlSession中的方法可以调用Mapper.xml中的SQL语句操作数据库。</li>
<li><strong>Executor</strong>：执行器，分为基本执行器和缓存执行器，MyBatis内部使用Executor执行SQL语句。</li>
<li><strong>MappedStatement</strong>：内部封装对象，将映射文件中的SQL语句，输入参数类型，返回结果集类型，封装成对象。</li>
<li><strong>输入映射</strong>：DAO层方法输入参数的类型，在mapper.xml文件里由sql标签的<strong>parameterType</strong>定义，可以是Map，String+Integer+基本数据类型，Pojo。</li>
<li><strong>输出映射</strong>：返回结果集类型，在mapper.xml文件里由sql标签的<strong>resultType</strong>定义，可以是Map，String+Integer+基本数据类型，Pojo，List。</li>
</ol>
<h3 id="SqlMapConfig-xml核心配置文件说明"><a href="#SqlMapConfig-xml核心配置文件说明" class="headerlink" title="SqlMapConfig.xml核心配置文件说明"></a>SqlMapConfig.xml核心配置文件说明</h3><h4 id="properties（属性）"><a href="#properties（属性）" class="headerlink" title="properties（属性）"></a>properties（属性）</h4><p>加载属性文件，配置属性变量。</p>
<p>SqlMapConfig.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置属性变量 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"db.properties"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>db.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">db.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">db.url</span>=<span class="string">jdbc:mysql://[host]:[port]/mybatis?characterEncoding=utf8&amp;useSSL=true</span></span><br><span class="line"><span class="meta">db.username</span>=<span class="string"></span></span><br><span class="line"><span class="meta">db.password</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>

<p><strong>注意：db.properties中配置的数据库属性的key值不要直接用driver、url、username、password这些简单的单词，使用这些简单的单词系统不会报错，但是在后期动态代理mapper的时候会出现异常。</strong></p>
<p>比如mapper中用到拼接符${username}拼接的是User对象的属性值username，但是由于数据库中也有一个username属性，mybatis会优先将数据库的username拼接到字符串中去，出现的效果就是：不管User对象中设置什么username，程序输出的sql语句总是root（数据库的username）。</p>
<h4 id="typeAliases（别名）"><a href="#typeAliases（别名）" class="headerlink" title="typeAliases（别名）"></a>typeAliases（别名）</h4><p>类型别名，配置文件中可以将类型名称替换成对应的别名，MyBatis中默认支持的别名如下所示：</p>
<table>
<thead>
<tr>
<th>别名</th>
<th>映射的Java类型名</th>
</tr>
</thead>
<tbody><tr>
<td>_byte</td>
<td>byte</td>
</tr>
<tr>
<td>_long</td>
<td>long</td>
</tr>
<tr>
<td>_short</td>
<td>short</td>
</tr>
<tr>
<td>_int</td>
<td>int</td>
</tr>
<tr>
<td>_integer</td>
<td>int</td>
</tr>
<tr>
<td>_double</td>
<td>double</td>
</tr>
<tr>
<td>_float</td>
<td>float</td>
</tr>
<tr>
<td>_boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>string</td>
<td>String</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>integer</td>
<td>Integer</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>date</td>
<td>Date</td>
</tr>
<tr>
<td>decimal</td>
<td>BigDecimal</td>
</tr>
<tr>
<td>bigdecimal</td>
<td>BigDecimal</td>
</tr>
<tr>
<td>map</td>
<td>Map</td>
</tr>
</tbody></table>
<p>自定义别名，typeAliases标签定义在SqlMapConfig.xml文件中，并且typeAliases标签应该在enviroments标签的上面。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	定义单个pojo类别名</span></span><br><span class="line"><span class="comment">	type：类的全路径名称</span></span><br><span class="line"><span class="comment">	alias：别名</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">"com.xinxing.mybatis.pojo.User"</span> <span class="attr">alias</span>=<span class="string">"User"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	使用包扫描的方式批量定义别名</span></span><br><span class="line"><span class="comment">	定义后别名等于类名，不区分大小写，但是建议按照java命名规则来写。</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.xinxing.mybatis.pojo"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="mappers（映射器）"><a href="#mappers（映射器）" class="headerlink" title="mappers（映射器）"></a>mappers（映射器）</h4><h5 id="使用包扫描的方式批量引入mapper接口"><a href="#使用包扫描的方式批量引入mapper接口" class="headerlink" title="使用包扫描的方式批量引入mapper接口"></a>使用包扫描的方式批量引入mapper接口</h5><p>使用mapper接口代理的方式让MyBatis自动创建接口的实现类时，需要遵守以下两条引入规则：</p>
<ul>
<li>接口名和xml映射文件名应该完全相同。</li>
<li>接口和xml映射文件应该在同一目录下。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--使用包扫描的方式批量引入mapper接口--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.xinxing.mybatis.mapper"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="单个引入mapper文件"><a href="#单个引入mapper文件" class="headerlink" title="单个引入mapper文件"></a>单个引入mapper文件</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"User.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"com.xinxing.mybatis.mapper.UserMapper"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="MyBatis入门项目"><a href="#MyBatis入门项目" class="headerlink" title="MyBatis入门项目"></a>MyBatis入门项目</h2><h3 id="需求列表"><a href="#需求列表" class="headerlink" title="需求列表"></a>需求列表</h3><ol>
<li>根据用户ID查询用户信息</li>
<li>根据用户名查找用户列表</li>
<li>添加用户</li>
<li>删除用户</li>
<li>修改用户</li>
</ol>
<h3 id="工程搭建"><a href="#工程搭建" class="headerlink" title="工程搭建"></a>工程搭建</h3><h4 id="1）引入6个依赖包"><a href="#1）引入6个依赖包" class="headerlink" title="1）引入6个依赖包"></a>1）引入6个依赖包</h4><p>引入1个数据库驱动包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.46<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>引入1个mybatis包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>引入commons-logging和log4j包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>引入slf4j-api和slf4j-log4j12包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.0-beta2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.0-beta2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2）配置SqlMapConfig-xml和log4j-properties"><a href="#2）配置SqlMapConfig-xml和log4j-properties" class="headerlink" title="2）配置SqlMapConfig.xml和log4j.properties"></a>2）配置SqlMapConfig.xml和log4j.properties</h4><p>SqlMapConfig.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置属性变量 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"db.properties"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- MyBatis和Spring整合后environments配置将废除 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 使用JDBC事务管理 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们可以配置两个环境，通过更改environments default的值更改默认环境。MyBatis约束文件采用.dtd格式，dtd格式要求标签的出现顺序要严格按照约束文件中指定的顺序出现。</p>
<p>在db.properties文件中定义数据库属性：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://[host]:[port]/mybatis?characterEncoding=utf8&amp;useSSL=true</span></span><br><span class="line"><span class="attr">username</span>=<span class="string"></span></span><br><span class="line"><span class="attr">password</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>

<p>log4j.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Global logging configuration</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">DEBUG, stdout</span></span><br><span class="line"><span class="comment"># Console output...</span></span><br><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%5p [%t] - %m%n</span></span><br></pre></td></tr></table></figure>

<h4 id="3）创建POJO类"><a href="#3）创建POJO类" class="headerlink" title="3）创建POJO类"></a>3）创建POJO类</h4><ul>
<li>User</li>
<li>Order</li>
</ul>
<h4 id="4）创建SQL映射文件"><a href="#4）创建SQL映射文件" class="headerlink" title="4）创建SQL映射文件"></a>4）创建SQL映射文件</h4><p>User.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--namespace用于隔离SQL语句--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在SqlMapConfig.xml中配置User.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--加载映射文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"classpath:User.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>项目环境搭建完成。</p>
<h3 id="MyBatis访问数据库的标准流程"><a href="#MyBatis访问数据库的标准流程" class="headerlink" title="MyBatis访问数据库的标准流程"></a>MyBatis访问数据库的标准流程</h3><ol>
<li>创建SqlSessionFactoryBuilder对象。</li>
<li>利用mybatis提供的Resource对象创建SqlMapConfig.xml配置文件的输入流。</li>
<li>利用SqlSessionFactoryBuilder和配置文件输入流创建SqlSessionFactory对象。</li>
<li>从SqlSessionFactory对象中得到SqlSession对象。</li>
<li>利用SqlSession对象我们可以实现对数据库的各种操作。</li>
<li>操作完成后关闭SqlSession。</li>
</ol>
<h3 id="需求1-根据用户ID查询用户"><a href="#需求1-根据用户ID查询用户" class="headerlink" title="需求1: 根据用户ID查询用户"></a>需求1: 根据用户ID查询用户</h3><p>编写SQL语句，然后放入User.xml中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    id：SQL语句唯一标示</span></span><br><span class="line"><span class="comment">    parameterType：指定传入参数类型，下面指的的传入id的类型，是User.java里面id属性的类型</span></span><br><span class="line"><span class="comment">    resultType：返回结果集类型</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"com.xinxng.mybatis.pojo.User"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- select * from user where id = ? --&gt;</span></span><br><span class="line">        SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>parameterType：指定传入参数类型，上面指的的传入id的类型，是User.java里面id属性的类型，由于User.java里面id是int类型，所以可以写成<code>parameterType=&quot;java.lang.Integer&quot;</code>或者<code>parameterType=&quot;int&quot;</code></li>
<li>resultType：返回结果集的类型，由于查询user表，user表对应的pojo类是User.java类，所以应该是<code>com.xinxing.mybatis.pojo.User</code>类型。</li>
<li>mybatis里面sql语句里<code>#{}</code>就相当于jdbc里面的占位符<code>?</code>，如果传入类型是：String，或者java基本数据类型，<code>#{}</code>中的变量名可以随意写。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetUserById</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建SqlSessionFactoryBuilder</span></span><br><span class="line">        SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        <span class="comment">// 创建配置文件的输入流</span></span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        <span class="comment">// 通过输入流创建sqlSessionFactory对象</span></span><br><span class="line">        SqlSessionFactory sqlSessionFactory = builder.build(inputStream);</span><br><span class="line">        <span class="comment">// 通过sqlSessionFactory创建sqlSession对象</span></span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">// 执行查询 第一个参数=namespace+sql的id 第二个参数是传入的参数值</span></span><br><span class="line">        User user = sqlSession.selectOne(<span class="string">"user.getUserById"</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="需求2-根据用户名查询用户"><a href="#需求2-根据用户名查询用户" class="headerlink" title="需求2: 根据用户名查询用户"></a>需求2: 根据用户名查询用户</h3><p>编写SQL语句，然后放入User.xml中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--如果返回结果为集合，可以调用selectList方法，这个方法返回的结果就是一个List，所以映射文件中只resultType应该配置成集合范型的类型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserByUserName"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.String"</span> <span class="attr">resultType</span>=<span class="string">"com.xinxing.mybatis.pojo.User"</span>&gt;</span></span><br><span class="line">	select * from user where username like #&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetUserByUserName</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>));</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    List&lt;User&gt; list = sqlSession.selectList(<span class="string">"user.getUserByUserName"</span>, <span class="string">"%王%"</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select * from user where username like ? </span><br><span class="line">DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: %王%(String)</span><br></pre></td></tr></table></figure>

<p>传入参数重的%不应该出现在传入参数中，我们可以使用mybatis中的<strong>字符串拼接符<code>${}</code></strong>将%写在SQL语句中。</p>
<p>如果<code>${}</code>中的传入的参数是String或者基本类型，那么<code>${}</code>中的变量名称必须是<strong>value</strong>。</p>
<p>User.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--$&#123;&#125;字符串拼接符：字符串原样拼接。如果传入的参数是String和基本类型，那么$&#123;&#125;中的变量名称必须是value--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserByUserName"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.String"</span> <span class="attr">resultType</span>=<span class="string">"com.xinxing.mybatis.pojo.User"</span>&gt;</span></span><br><span class="line">    select * from user where username like '%$&#123;value&#125;%'</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; list = sqlSession.selectList(<span class="string">"user.getUserByUserName"</span>, <span class="string">"王"</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select * from user where username like &#39;%王%&#39; </span><br><span class="line">DEBUG [main] - &#x3D;&#x3D;&gt; Parameters:</span><br></pre></td></tr></table></figure>

<p>注意：<code>${}</code>拼接符有SQL注入的风险，所以慎重使用。</p>
<p>总结：等号后面一般都用占位符，like后面一般都是拼接符，其他的能用占位符就用占位符。</p>
<h3 id="需求3-添加用户"><a href="#需求3-添加用户" class="headerlink" title="需求3: 添加用户"></a>需求3: 添加用户</h3><p>编写SQL语句，然后放入User.xml中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--#&#123;&#125;:如果传入的是pojo类型，那么#&#123;&#125;中的变量名称必须是pojo中对应的属性名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.xinxing.mybatis.pojo.User"</span>&gt;</span></span><br><span class="line">    insert into user (username,birthday,sex,address) value(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：如果传入的是pojo类型，那么<code>#{}</code>中的变量名称必须是pojo中对应的属性名。</p>
<p>编写测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsertUsr</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>));</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setUsername(<span class="string">"xinxing"</span>);</span><br><span class="line">    user.setBirthday(<span class="keyword">new</span> Date(<span class="number">1992</span>));</span><br><span class="line">    user.setSex(<span class="string">"男"</span>);</span><br><span class="line">    user.setAddress(<span class="string">"北京"</span>);</span><br><span class="line">    sqlSession.insert(<span class="string">"user.insertUser"</span>, user);</span><br><span class="line">    <span class="comment">// 提交事务，不提交也能成功，但是数据插不到数据库中</span></span><br><span class="line">    sqlSession.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mybatis里面会自动开启事务，但是提交事务要手动提交。</p>
<h4 id="插入数据后返回自增主键"><a href="#插入数据后返回自增主键" class="headerlink" title="插入数据后返回自增主键"></a>插入数据后返回自增主键</h4><p>上面的代码没有返回值，但是有的时候需要返回值，比如增加订单需要返回订单号，想要返回自增主键，需要使用到SQL中的一个函数<code>select LAST_INSERT_ID()</code>，将这条语句添加到映射文件里，就可以返回数据库自增主键。</p>
<p>修改User.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--#&#123;&#125;:如果传入的是pojo类型，那么#&#123;&#125;中的变量名称必须是pojo中对应的属性名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.xinxing.mybatis.pojo.User"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        执行select LAST_INSERT_ID()数据库函数返回指针的主键，keyProperty</span></span><br><span class="line"><span class="comment">        keyProperty：将返回的主键放入传入参数的id中保存</span></span><br><span class="line"><span class="comment">        order：当前函数相对于insert语句的执行顺序,在insert前执行是BEFORE，在insert后执行是AFTER</span></span><br><span class="line"><span class="comment">        resultType：id的类型，也就是keyProperty中属性的类型</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">order</span>=<span class="string">"AFTER"</span> <span class="attr">resultType</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></span><br><span class="line">        select LAST_INSERT_ID()</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    insert into user (username,birthday,sex,address) value(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>mybatis会将返回值直接设置到user对象里，通过selectKey标签可以添加查询id的语句</p>
<ul>
<li>keyProperty指定返回值设置到user对象的哪个属性中，如果返回的是id，一般是user的id属性。</li>
<li>order指定selectKey标签内部的语句在插入语句之前还是之后执行。</li>
<li>resultType指定返回数据的类型，也就是keyProperty指定user中某个属性的类型。</li>
</ul>
<p>在测试方法中打印返回的id值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(user.getId());</span><br></pre></td></tr></table></figure>

<h4 id="插入数据后返回UUID"><a href="#插入数据后返回UUID" class="headerlink" title="插入数据后返回UUID"></a>插入数据后返回UUID</h4><blockquote>
<p>UUID(Universally Unique Identifier)通用唯一识别码，是一种软件建构的标准，亦为开放软件基金会组织在分布式计算环境领域的一部分。其目的是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。如此一来，每个人都可以创建不与其他人冲突的UUID，这样就不需要考虑数据库建库时名称重复的问题。目前最广泛应用的 UUID，即是微软的 Microsoft’s Globally Unique Identifiers (GUIDs)，而其他重要的应用，则有 Linux ext2/ext3 档案系统、LUKS 加密分割区、GNOME、KDE、Mac OS X 等等。</p>
</blockquote>
<blockquote>
<p>Java生成UUID的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.UUID;</span><br><span class="line"></span><br><span class="line">public class Uuid &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UUID uuid &#x3D; UUID.randomUUID();</span><br><span class="line">        System.out.println(uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a0427e7c-8796-4616-a9d0-1bb4aa8282de</span><br></pre></td></tr></table></figure>
</blockquote>
<p>mysql数据库中如果使用uuid作为主键，需要通过函数<code>select uuid()</code>生成uuid的值。</p>
<p>修改User.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.xinxing.mybatis.pojo.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">order</span>=<span class="string">"BEFORE"</span> <span class="attr">resultType</span>=<span class="string">"java.lang.String"</span>&gt;</span></span><br><span class="line">        select uuid()</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    insert into user (username,birthday,sex,address) value(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：<code>select uuid()</code>要在insert语句之前执行，因为数据库要先生成一个uuid，然后把它放到设置到user对象的id属性里，然后再将user插入到数据库。</p>
<h3 id="需求4-删除用户"><a href="#需求4-删除用户" class="headerlink" title="需求4: 删除用户"></a>需求4: 删除用户</h3><p>编写SQL语句，然后放入User.xml中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"delUserById"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></span><br><span class="line">    delete from user where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelUserById</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>));</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    sqlSession.delete(<span class="string">"user.delUserById"</span>, <span class="number">29</span>);</span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    sqlSession.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: delete from user where id&#x3D;? </span><br><span class="line">DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: 29(Integer)</span><br></pre></td></tr></table></figure>

<h3 id="需求5-修改用户"><a href="#需求5-修改用户" class="headerlink" title="需求5: 修改用户"></a>需求5: 修改用户</h3><p>编写SQL语句，然后放入User.xml中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUserById"</span> <span class="attr">parameterType</span>=<span class="string">"com.xinxing.mybatis.pojo.User"</span>&gt;</span></span><br><span class="line">    update user set username=#&#123;username&#125; where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于parameterType出入参数的类型是User，所以<code>#{}</code>中应该填User中对应的属性名。</p>
<p>编写测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdateUserById</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>));</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setUsername(<span class="string">"XX"</span>);</span><br><span class="line">    user.setId(<span class="number">28</span>);</span><br><span class="line">    sqlSession.update(<span class="string">"user.updateUserById"</span>, user);</span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    sqlSession.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: update user set username&#x3D;? where id&#x3D;? </span><br><span class="line">DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: XX(String), 28(Integer)</span><br><span class="line">DEBUG [main] - &lt;&#x3D;&#x3D;    Updates: 1</span><br></pre></td></tr></table></figure>

<h3 id="总结：-占位符和-字符串拼接符的用法"><a href="#总结：-占位符和-字符串拼接符的用法" class="headerlink" title="总结：#{}占位符和${}字符串拼接符的用法"></a>总结：<code>#{}</code>占位符和<code>${}</code>字符串拼接符的用法</h3><ol>
<li>如果传入参数是String或基本类型，那么<code>#{}</code>中的变量名可以随意，<strong><code>${}</code>中的变量名必须是<code>value</code></strong>。</li>
<li>如果传入参数是pojo类型，那么<code>#{}</code>和<code>${}</code>中的变量名必须是pojo中对应的属性.属性.属性…。例如<code>#{user.sex}</code>, <code>&#39;%${user.username}%&#39;</code>, <code>#{user.child.username}</code></li>
<li>使用<code>${}</code>字符串拼接符有可能造成SQL注入，解决方法是在页面输入时候进行校验，不能输入SQL关键字，不能输入空格。</li>
</ol>
<hr>
<h2 id="DAO的两种开发方式"><a href="#DAO的两种开发方式" class="headerlink" title="DAO的两种开发方式"></a>DAO的两种开发方式</h2><h3 id="原生DAO的开发方式"><a href="#原生DAO的开发方式" class="headerlink" title="原生DAO的开发方式"></a>原生DAO的开发方式</h3><p>原生DAO的开发方式就是<strong>面向接口和实现类</strong>的开发方式。</p>
<h4 id="1）编写UserDao接口"><a href="#1）编写UserDao接口" class="headerlink" title="1）编写UserDao接口"></a>1）编写UserDao接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.xinxing.mybatis.pojo.User;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">findUserByUserId</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUserByUserName</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserDao实现两个功能：</p>
<ul>
<li>按照用户id查询用户。</li>
<li>按照用户名模糊查询用户。</li>
</ul>
<h4 id="2）编写UserDaoImpl实现类"><a href="#2）编写UserDaoImpl实现类" class="headerlink" title="2）编写UserDaoImpl实现类"></a>2）编写UserDaoImpl实现类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.xinxing.mybatis.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用构造方法注入sqlsessionFactory</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDaoImpl</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserByUserId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// sqlSession是线程不安全的，所以它的最佳使用范围在方法体内</span></span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        User user = sqlSession.selectOne(<span class="string">"user.getUserById"</span>, <span class="number">28</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserByUserName</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        List&lt;User&gt; users = sqlSession.selectList(<span class="string">"user.getUserByUserName"</span>);</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用构造方法将sqlSessionFactory属性注入进来，然后开始编写两个业务方法。</p>
<p><strong>注意：SqlSession是线程不安全的，所以它的最佳使用范围在方法体内。</strong></p>
<p>我们直接调用User.xml中定义的两个SQL映射执行用户查询。</p>
<h4 id="3）编写测试方法"><a href="#3）编写测试方法" class="headerlink" title="3）编写测试方法"></a>3）编写测试方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.xinxing.mybatis.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.xinxing.mybatis.dao.UserDaoImpl;</span><br><span class="line"><span class="keyword">import</span> com.xinxing.mybatis.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Before的作用：在测试方法前执行这个方法。</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindUserById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserDao userDao = <span class="keyword">new</span> UserDaoImpl(sqlSessionFactory);</span><br><span class="line">        User user = userDao.findUserByUserId(<span class="number">1</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindUserByUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserDao userDao = <span class="keyword">new</span> UserDaoImpl(sqlSessionFactory);</span><br><span class="line">        List&lt;User&gt; users = userDao.findUserByUserName(<span class="string">"x"</span>);</span><br><span class="line">        System.out.println(users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@Before的作用</strong>：在测试方法前执行这个方法。</p>
<h3 id="Mapper接口动态代理的开发方式"><a href="#Mapper接口动态代理的开发方式" class="headerlink" title="Mapper接口动态代理的开发方式"></a>Mapper接口动态代理的开发方式</h3><p>是MyBatis特有的方法，<strong>只写接口和配置文件</strong>MyBatis自动创建实现类，是使用最多的一种方式。</p>
<h4 id="1）新建接口和接口映射文件"><a href="#1）新建接口和接口映射文件" class="headerlink" title="1）新建接口和接口映射文件"></a>1）新建接口和接口映射文件</h4><p>新建一个包<code>com.xinxing.mybatis.mapper</code>在包中新建两个文件：</p>
<ul>
<li>UserMapper.java : UserMapper接口。</li>
<li>UserMapper.xml : UserMapper接口的映射文件。</li>
</ul>
<p>接口和XML配置文件必须<strong>同名</strong>而且<strong>在同一个包下</strong>。</p>
<h4 id="2）在UserMapper-java接口中定义要实现的业务方法"><a href="#2）在UserMapper-java接口中定义要实现的业务方法" class="headerlink" title="2）在UserMapper.java接口中定义要实现的业务方法"></a>2）在UserMapper.java接口中定义要实现的业务方法</h4><p>动态代理形式中如果返回结果集为List，那么MyBatis会在生成实现类的时候会自动调用selectList方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">findUserById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUserByUserName</span><span class="params">(String username)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUserByVo</span><span class="params">(QueryVo queryVo)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findUserCount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3）在UserMapper-xml映射文件中配置SQL语句"><a href="#3）在UserMapper-xml映射文件中配置SQL语句" class="headerlink" title="3）在UserMapper.xml映射文件中配置SQL语句"></a>3）在UserMapper.xml映射文件中配置SQL语句</h4><p>映射文件要遵循以下编写规则：</p>
<ol>
<li><strong>映射文件中namespace要等于接口的全路径名称。</strong></li>
<li><strong>映射文件中sql语句id要等于接口的方法名称。</strong></li>
<li><strong>映射文件中传入参数类型要等于接口方法的传入参数类型。</strong></li>
<li><strong>映射文件中返回结果集类型要等于接口方法的返回值类型。</strong></li>
</ol>
<p>根据以上规则可以写出UserMapper.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.xinxing.mybatis.mapper.UserMapper"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserById"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.Integer"</span> <span class="attr">resultType</span>=<span class="string">"com.xinxing.mybatis.pojo.User"</span>&gt;</span></span><br><span class="line">        select * from user where id=#&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByUserName"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.String"</span> <span class="attr">resultType</span>=<span class="string">"com.xinxing.mybatis.pojo.User"</span>&gt;</span></span><br><span class="line">        select * from user where username like '%$&#123;value&#125;%';</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.xinxing.mybatis.pojo.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">order</span>=<span class="string">"AFTER"</span> <span class="attr">resultType</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></span><br><span class="line">            select LAST_INSERT_ID()</span><br><span class="line">        <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">        insert into user (username,birthday,sex,address) value(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByVo"</span> <span class="attr">parameterType</span>=<span class="string">"com.xinxing.mybatis.pojo.QueryVo"</span> <span class="attr">resultType</span>=<span class="string">"com.xinxing.mybatis.pojo.User"</span>&gt;</span></span><br><span class="line">        select * from user where username like '%$&#123;user.username&#125;%' and sex=#&#123;user.sex&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--只有返回结果为一行一列的时候，返回值类型才可以指定成基本类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserCount"</span> <span class="attr">resultType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">        select count(*) from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4）在全局配置文件SqlMapConfig-xml文件中配置mapper"><a href="#4）在全局配置文件SqlMapConfig-xml文件中配置mapper" class="headerlink" title="4）在全局配置文件SqlMapConfig.xml文件中配置mapper"></a>4）在全局配置文件SqlMapConfig.xml文件中配置mapper</h4><p>使用mapper标签的class属性配置mapper，class必须是接口的全限定名。</p>
<p>SqlMapConfig.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"com.xinxing.mybatis.mapper.UserMapper"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5）如果使用Maven构建项目，需要将xml文件也放到输出目录下"><a href="#5）如果使用Maven构建项目，需要将xml文件也放到输出目录下" class="headerlink" title="5）如果使用Maven构建项目，需要将xml文件也放到输出目录下"></a>5）如果使用Maven构建项目，需要将xml文件也放到输出目录下</h4><p>默认情况下maven在编译时会忽略xml文件，在classes目录下的com.xinxing.mybatis.mapper包中只有UserMapper.class文件没有UserMapper.xml文件，我们需要将xml文件也放到输出路径下，需要在pom.xml文件中配置资源文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>指定将src/main/java目下的所有xml文件放到输出目录下。</p>
<h4 id="6）编写测试方法"><a href="#6）编写测试方法" class="headerlink" title="6）编写测试方法"></a>6）编写测试方法</h4><p>使用sqlSession.getMapper(UserMapper.class)方法得到MyBatis自动生成的UserMapper接口的实现类，然后测试这个实现类中的方法。</p>
<p>注意：<strong>在对数据库进行增删改的时候一定要提交事务</strong>，MyBatis会自动开启事务但是需要我们在合适的位置提交事务，如果不提交事务，对数据库的更改无法生效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindUserById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">// 通过getMapper方法来实例化MyBatis中对UserMapper接口的实现类</span></span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        User user = mapper.findUserById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindUserByUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        List&lt;User&gt; users = mapper.findUserByUserName(<span class="string">"王"</span>);</span><br><span class="line">        System.out.println(users);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsertUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">"xxx"</span>);</span><br><span class="line">        user.setBirthday(<span class="keyword">new</span> Date(<span class="number">1992</span>));</span><br><span class="line">        user.setSex(<span class="string">"男"</span>);</span><br><span class="line">        user.setAddress(<span class="string">"北京"</span>);</span><br><span class="line">        mapper.insertUser(user);</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        System.out.println(user.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindUserByVo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">"x"</span>);</span><br><span class="line">        user.setSex(<span class="string">"男"</span>);</span><br><span class="line">        QueryVo queryVo = <span class="keyword">new</span> QueryVo();</span><br><span class="line">        queryVo.setUser(user);</span><br><span class="line">        List&lt;User&gt; userByVo = mapper.findUserByVo(queryVo);</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        System.out.println(userByVo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testfindUserCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">int</span> count = mapper.findUserCount();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><p>动态SQL就是利用MyBatis提供的各种标签方法，根据条件动态的拼接生成SQL语句。</p>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>需求：我们要在数据库中查找用户，现在给出两个条件id和username，用户可以任意填写这两个条件（可以只填一个，也可以填两个），我们要按照用户填写的条件查询数据库中的用户。</p>
<p>分析：如果两个条件都有的话，可以使用下面这条SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span>=? <span class="keyword">and</span> username <span class="keyword">like</span> ?</span><br></pre></td></tr></table></figure>

<p>但是，id和username的条件是不一定都存在的，这时候我们就可以使用MyBatis提供的<strong>if</strong>标签来判断，动态的生成SQL语句。</p>
<p>注意：下面的1=1是让查询语句总是可以执行的，后面使用了where标签就可以省略1=1。</p>
<p>1）在UserMapper.xml中编写SQL语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserList"</span> <span class="attr">parameterType</span>=<span class="string">"user"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">    select * from user where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"id != null"</span>&gt;</span></span><br><span class="line">        and id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username != null and username != ''"</span>&gt;</span></span><br><span class="line">        and username like '%$&#123;username&#125;%'</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2）在UserMapper.java接口中添加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">findUserList</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure>

<p>3）编写测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setUsername(<span class="string">"x"</span>);</span><br><span class="line">    user.setId(<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; userList = mapper.findUserList(user);</span><br><span class="line"></span><br><span class="line">    System.out.println(userList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select * from user WHERE id&#x3D;? and username like &#39;%x%&#39; </span><br><span class="line">DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: 32(Integer)</span><br></pre></td></tr></table></figure>

<h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>where标签有两个作用：</p>
<ol>
<li>自动向sql语句中添加where关键字。</li>
<li>去掉第一个条件的and关键字。</li>
</ol>
<p>修改UserMapper.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserList"</span> <span class="attr">parameterType</span>=<span class="string">"User"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"id != null"</span>&gt;</span></span><br><span class="line">            and id=#&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username != null and username != ''"</span>&gt;</span></span><br><span class="line">            and username like '%$&#123;username&#125;%'</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h3><p>为了提高代码的复用性，我们可以将这部分sql语句封装起来，其他sql语句直接调用这部分语句就可以。</p>
<p>修改UserMapper.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--封装sql条件，封装后可以重用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"user_Where"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"id != null"</span>&gt;</span></span><br><span class="line">            and id=#&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username != null and username != ''"</span>&gt;</span></span><br><span class="line">            and username like '%$&#123;username&#125;%'</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserList"</span> <span class="attr">parameterType</span>=<span class="string">"User"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    <span class="comment">&lt;!--调用sql条件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"user_Where"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>有的时候mapper中的SQL语句的传入参数是集合类型，foreach语句能够遍历集合中的元素，将集合中的元素都拼接到SQL语句中。</p>
<p>我们要完成的SQL查询是如下的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">10</span>,<span class="number">16</span>,<span class="number">27</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意：在SQL语句中尽量不要使用or，使用or会使SQL语句的性能成指数下降。</strong></p>
<p>QueryVo.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryVo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; ids;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getIds</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ids; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIds</span><span class="params">(List&lt;Integer&gt; ids)</span> </span>&#123; <span class="keyword">this</span>.ids = ids; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> user; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123; <span class="keyword">this</span>.user = user; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1）在UserMapper.xml文件中新建SQL映射</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByIds"</span> <span class="attr">parameterType</span>=<span class="string">"QueryVo"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"ids != null"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"ids"</span> <span class="attr">item</span>=<span class="string">"id"</span> <span class="attr">open</span>=<span class="string">"id in ("</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">                #&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>foreach标签中各个属性的含义：</p>
<ul>
<li>collection：传入集合属性的名称。</li>
<li>item：循环变量名，每次循环出的数据放在这个变量中。</li>
<li>open：循环开始前拼接的字符串。</li>
<li>close：循环结束后拼接的字符串。</li>
<li>separator：循环中拼接的分隔符。  </li>
</ul>
<p>2）在UserMapper.java接口中添加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">findUserByIds</span><span class="params">(QueryVo queryVo)</span></span>;</span><br></pre></td></tr></table></figure>

<p>3）编写测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindUserByIds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    QueryVo queryVo = <span class="keyword">new</span> QueryVo();</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">10</span>);</span><br><span class="line">    list.add(<span class="number">16</span>);</span><br><span class="line">    list.add(<span class="number">27</span>);</span><br><span class="line">    queryVo.setIds(list);</span><br><span class="line">    List&lt;User&gt; userByIds = mapper.findUserByIds(queryVo);</span><br><span class="line">    System.out.println(userByIds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select * from user WHERE id in ( ? , ? , ? , ? ) </span><br><span class="line">DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: 1(Integer), 10(Integer), 16(Integer), 27(Integer)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h2><p>数据库表结构如下图所示：</p>
<p><img src="orders-user.png" alt="orders-user"></p>
<p>一个user对应多个order，一个order对应一个user。</p>
<h3 id="单个对象映射关系"><a href="#单个对象映射关系" class="headerlink" title="单个对象映射关系"></a>单个对象映射关系</h3><p>由于一个订单对应一个用户，所以从订单来看这是一对一关系，用Order类来接收查询结果，每个Order里买只有一个User对象，这就是单个对象映射关系。</p>
<p><strong>需求：查询所有order.user_id = user.id的数据</strong></p>
<p>可以使用下面这条语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">order</span>, <span class="keyword">user</span> <span class="keyword">where</span> order.user_id = user.id;</span><br></pre></td></tr></table></figure>

<p>输出结果后发现order中的id和user中的id重名，所以我们将user中的id重命名为uid，使用如下语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.*, b.id uid, username, birthday, sex, address</span><br><span class="line"><span class="keyword">from</span> <span class="string">`order`</span> a, <span class="string">`user`</span> b</span><br><span class="line"><span class="keyword">where</span> a.user_id = b.id;</span><br></pre></td></tr></table></figure>

<p>有两种方法实现这个查询：一对一自动映射和一对一手动映射。</p>
<h4 id="一对一自动映射"><a href="#一对一自动映射" class="headerlink" title="一对一自动映射"></a>一对一自动映射</h4><p>1）在UserMapper.xml中编写SQL语句映射：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 一对一：自动映射 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findOrdersAndUser1"</span> <span class="attr">resultType</span>=<span class="string">"CustomOrder"</span>&gt;</span></span><br><span class="line">    select a.*, b.id uid, username, birthday, sex, address</span><br><span class="line">    from `order` a, `user` b </span><br><span class="line">    where a.user_id = b.id;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2）在UserMapper接口中添加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;CustomOrder&gt; <span class="title">findOrdersAndUser1</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>3）新建CustomOrder pojo类接收查询结果</p>
<p>CustomOrder.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomOrder</span> <span class="keyword">extends</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer uid;</span><br><span class="line">    <span class="keyword">private</span> String username;  <span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> Date birthday;    <span class="comment">//生日</span></span><br><span class="line">    <span class="keyword">private</span> String sex;       <span class="comment">//性别</span></span><br><span class="line">    <span class="keyword">private</span> String address;   <span class="comment">//地址</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getUid</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> uid;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUid</span><span class="params">(Integer uid)</span> </span>&#123;<span class="keyword">this</span>.uid = uid;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> username;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;<span class="keyword">this</span>.username = username;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> birthday;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123;<span class="keyword">this</span>.birthday = birthday;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> sex;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;<span class="keyword">this</span>.sex = sex;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> address;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;<span class="keyword">this</span>.address = address;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）编写测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testfindOrdersAndUser1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserMapper mapper = sqlSessionFactory.openSession().getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    List&lt;CustomOrder&gt; list = mapper.findOrdersAndUser1();</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select a.*, b.id uid, username, birthday, sex, address from &#96;order&#96; a, &#96;user&#96; b where a.user_id &#x3D; b.id; </span><br><span class="line">DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: </span><br><span class="line">DEBUG [main] - &lt;&#x3D;&#x3D;      Total: 3</span><br><span class="line">[CustomOrder&#123;uid&#x3D;1, username&#x3D;&#39;王五&#39;, birthday&#x3D;null, sex&#x3D;&#39;2&#39;, address&#x3D;&#39;null&#39;&#125;, CustomOrder&#123;uid&#x3D;1, username&#x3D;&#39;王五&#39;, birthday&#x3D;null, sex&#x3D;&#39;2&#39;, address&#x3D;&#39;null&#39;&#125;, CustomOrder&#123;uid&#x3D;10, username&#x3D;&#39;张三&#39;, birthday&#x3D;2014-07-10, sex&#x3D;&#39;1&#39;, address&#x3D;&#39;北京市&#39;&#125;]</span><br></pre></td></tr></table></figure>

<h4 id="一对一手动映射"><a href="#一对一手动映射" class="headerlink" title="一对一手动映射"></a>一对一手动映射</h4><p>手动映射需要手动指定查询结果中的列和pojo对象中属性的对应关系。</p>
<p>1）在UserMapper.xml中做如下配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 一对一：手动映射 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    id: resultMap的唯一标示</span></span><br><span class="line"><span class="comment">    type: 将查询出的数据放入指定类型的对象中</span></span><br><span class="line"><span class="comment">    注意：手动映射需要指定数据库中表的字段名与java中pojo类的属性名称的对应关系</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"orderAndUserResultMap"</span> <span class="attr">type</span>=<span class="string">"order"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        id标签指定主键字段对应关系</span></span><br><span class="line"><span class="comment">        column：数据库中的字段名称</span></span><br><span class="line"><span class="comment">        property：java pojo中的属性名称</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- result标签指定非主键列的对应关系 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"user_id"</span> <span class="attr">property</span>=<span class="string">"userid"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"number"</span> <span class="attr">property</span>=<span class="string">"number"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"createtime"</span> <span class="attr">property</span>=<span class="string">"createtime"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"note"</span> <span class="attr">property</span>=<span class="string">"note"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        association标签指定单个对象的映射关系</span></span><br><span class="line"><span class="comment">        property: 指定将数据放入Order中的非基本类型的属性中，如user对象</span></span><br><span class="line"><span class="comment">        javaType: user属性的类型</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"user"</span> <span class="attr">javaType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"uid"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">property</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"birthday"</span> <span class="attr">property</span>=<span class="string">"birthday"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"sex"</span> <span class="attr">property</span>=<span class="string">"sex"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"address"</span> <span class="attr">property</span>=<span class="string">"address"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findOrdersAndUser2"</span> <span class="attr">resultMap</span>=<span class="string">"orderAndUserResultMap"</span>&gt;</span></span><br><span class="line">        select a.*, b.id uid, username, birthday, sex, address</span><br><span class="line">        from `order` a, `user` b</span><br><span class="line">        where a.user_id = b.id;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用resultMap使用来指定返回结果集中结果列和pojo对象属性的对应关系，使用Order类做为接收结果集的主类，为了接受user表中的字段，在Order类中添加<code>private User user</code>属性。</p>
<p>我们在指定自定义类型的映射关系时使用<code>association</code>标签进行包裹，定义属性名称和类型，在其内部指定对应关系，其中<code>id</code>标签指定数据库表的主键的映射关系，<code>result</code>标签指定表的其他字段的映射关系。</p>
<p>使用手动映射的方法，我们就可以实现只在Order类中添加一个User属性来接收user表中的数据，而不用重新定义CustomOrder类。</p>
<p>2）在UserMapper.java接口中定义方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Order&gt; <span class="title">findOrdersAndUser2</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>3）编写测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testfindOrdersAndUser2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserMapper mapper = sqlSessionFactory.openSession().getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    List&lt;Order&gt; list = mapper.findOrdersAndUser2();</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select a.*, b.id uid, username, birthday, sex, address from &#96;order&#96; a, &#96;user&#96; b where a.user_id &#x3D; b.id; </span><br><span class="line">DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: </span><br><span class="line">DEBUG [main] - &lt;&#x3D;&#x3D;      Total: 3</span><br><span class="line">[Order&#123;id&#x3D;3, userid&#x3D;1, number&#x3D;&#39;1000010&#39;, createtime&#x3D;2015-02-04, note&#x3D;&#39;null&#39;, user&#x3D;User&#123;id&#x3D;1, username&#x3D;&#39;王五&#39;, birthday&#x3D;null, sex&#x3D;&#39;2&#39;, address&#x3D;&#39;null&#39;&#125;&#125;, Order&#123;id&#x3D;4, userid&#x3D;1, number&#x3D;&#39;1000011&#39;, createtime&#x3D;2015-02-03, note&#x3D;&#39;null&#39;, user&#x3D;User&#123;id&#x3D;1, username&#x3D;&#39;王五&#39;, birthday&#x3D;null, sex&#x3D;&#39;2&#39;, address&#x3D;&#39;null&#39;&#125;&#125;, Order&#123;id&#x3D;5, userid&#x3D;10, number&#x3D;&#39;1000012&#39;, createtime&#x3D;2015-02-12, note&#x3D;&#39;null&#39;, user&#x3D;User&#123;id&#x3D;10, username&#x3D;&#39;张三&#39;, birthday&#x3D;2014-07-10, sex&#x3D;&#39;1&#39;, address&#x3D;&#39;北京市&#39;&#125;&#125;]</span><br></pre></td></tr></table></figure>

<p><strong>第二种手动映射的方法才是MyBatis提供的标准方法。推荐使用第二种方法。</strong></p>
<h3 id="集合对象映射关系"><a href="#集合对象映射关系" class="headerlink" title="集合对象映射关系"></a>集合对象映射关系</h3><p>由于一个用户可以对应多个订单，如果用User对象来接收查询结果，每个User里买应该包含多个Order对象，既User里买应该包含一个<code>List&lt;Order&gt;</code>类型的属性，这就是集合对象映射关系。</p>
<p><strong>需求：查询所有user.id = order.user_id的数据</strong></p>
<p>1）在User类中添加<code>List&lt;Order&gt;</code>类型的属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Order&gt; orderList;</span><br></pre></td></tr></table></figure>

<p>2）在UserMapper.xml中编写SQL映射</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userAndOrdersResultMap"</span> <span class="attr">type</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">property</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"birthday"</span> <span class="attr">property</span>=<span class="string">"birthday"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"sex"</span> <span class="attr">property</span>=<span class="string">"sex"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"address"</span> <span class="attr">property</span>=<span class="string">"address"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        collection: 指定对应的集合关系映射</span></span><br><span class="line"><span class="comment">        property: 将数据放入User中的一个集合属性中</span></span><br><span class="line"><span class="comment">        ofType: 集合中元素的类型</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"orderList"</span> <span class="attr">ofType</span>=<span class="string">"order"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"oid"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"user_id"</span> <span class="attr">property</span>=<span class="string">"userid"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"number"</span> <span class="attr">property</span>=<span class="string">"number"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"createtime"</span> <span class="attr">property</span>=<span class="string">"createtime"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"note"</span> <span class="attr">property</span>=<span class="string">"note"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserAndOrders"</span> <span class="attr">resultMap</span>=<span class="string">"userAndOrdersResultMap"</span>&gt;</span></span><br><span class="line">    select a.*, b.id oid, user_id, number, createtime, note</span><br><span class="line">    from `user` a, `order` b</span><br><span class="line">    where a.id = b.user_id;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>要映射User中的集合属性<code>List&lt;Order&gt; orderList</code>，需要使用<code>collection</code>标签。</p>
<p>3）在UserMapper接口中添加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">findUserAndOrders</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>4）编写测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testfindUserAndOrders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserMapper mapper = sqlSessionFactory.openSession().getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    List&lt;User&gt; list = mapper.findUserAndOrders();</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select a.*, b.id oid, user_id, number, createtime, note from &#96;user&#96; a, &#96;order&#96; b where a.id &#x3D; b.user_id; </span><br><span class="line">DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: </span><br><span class="line">DEBUG [main] - &lt;&#x3D;&#x3D;      Total: 3</span><br><span class="line">[User&#123;id&#x3D;1, username&#x3D;&#39;王五&#39;, birthday&#x3D;null, sex&#x3D;&#39;2&#39;, address&#x3D;&#39;null&#39;, orderList&#x3D;[Order&#123;id&#x3D;3, userid&#x3D;1, number&#x3D;&#39;1000010&#39;, createtime&#x3D;2015-02-04, note&#x3D;&#39;null&#39;, user&#x3D;null&#125;, Order&#123;id&#x3D;4, userid&#x3D;1, number&#x3D;&#39;1000011&#39;, createtime&#x3D;2015-02-03, note&#x3D;&#39;null&#39;, user&#x3D;null&#125;]&#125;, User&#123;id&#x3D;10, username&#x3D;&#39;张三&#39;, birthday&#x3D;2014-07-10, sex&#x3D;&#39;1&#39;, address&#x3D;&#39;北京市&#39;, orderList&#x3D;[Order&#123;id&#x3D;5, userid&#x3D;10, number&#x3D;&#39;1000012&#39;, createtime&#x3D;2015-02-12, note&#x3D;&#39;null&#39;, user&#x3D;null&#125;]&#125;]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="MyBatis整合Spring"><a href="#MyBatis整合Spring" class="headerlink" title="MyBatis整合Spring"></a>MyBatis整合Spring</h2><h3 id="整合思路"><a href="#整合思路" class="headerlink" title="整合思路"></a>整合思路</h3><ul>
<li>SqlSessionFactory对象交给Spring管理，在Spring容器中做为单例对象存在。</li>
<li>传统DAO开发方式中，从Spring容器中获得SqlSession对象。</li>
<li>Mapper代理开发方式中，从Spring容器中获得Mapper的代理对象。</li>
<li>数据库连接池事务管理都交给Spring容器管理。</li>
</ul>
<h3 id="整合步骤"><a href="#整合步骤" class="headerlink" title="整合步骤"></a>整合步骤</h3><h4 id="1）新建项目引入依赖"><a href="#1）新建项目引入依赖" class="headerlink" title="1）新建项目引入依赖"></a>1）新建项目引入依赖</h4><ul>
<li>添加Spring依赖。</li>
<li>添加MyBatis依赖。</li>
<li>添加MyBatis-Spring整合包。</li>
<li>添加MySQL数据库驱动。</li>
</ul>
<p>如果使用Maven构建项目，这pom.xml文件如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xinxing<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Spring-Mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.8.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志处理--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.0-beta2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--junit--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mysql数据库驱动--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql <span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.46<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--druid数据库连接池--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis-spring整合包--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--spring--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2）创建Spring核心配置文件ApplicationContext-xml"><a href="#2）创建Spring核心配置文件ApplicationContext-xml" class="headerlink" title="2）创建Spring核心配置文件ApplicationContext.xml"></a>2）创建Spring核心配置文件ApplicationContext.xml</h4><p>将数据库连接池交由Spring管理。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/tx/spring-tx.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 加载java的配置文件 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"db.properties"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--druid数据库连接池--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.driver&#125;"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.url&#125;"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.username&#125;"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.password&#125;"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3）创建MyBatis核心配置文件SqlMapConfig-xml"><a href="#3）创建MyBatis核心配置文件SqlMapConfig-xml" class="headerlink" title="3）创建MyBatis核心配置文件SqlMapConfig.xml"></a>3）创建MyBatis核心配置文件SqlMapConfig.xml</h4><p>删除环境配置和数据库连接池配置，添加POJO类别名配置和Mappers配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--批量定义别名（推荐）--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--package：指定包名称来为该包下的pojo类声明别名，默认的别名就是类名（首字母大写小写都可以--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.xinxing.pojo"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.xinxing.mappers"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4）将MyBatis的SqlSessionFactory交给Spring管理"><a href="#4）将MyBatis的SqlSessionFactory交给Spring管理" class="headerlink" title="4）将MyBatis的SqlSessionFactory交给Spring管理"></a>4）将MyBatis的SqlSessionFactory交给Spring管理</h4><p>ApplicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--整合后会话工厂由Spring管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定MyBatis的核心配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis/SqlMapConfig.xml"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定会话工厂使用的数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>SqlSessionFactoryBean类中有两个属性：</p>
<ol>
<li>configLocation：指定MyBatis的核心配置文件。</li>
<li>dataSource：指定数据库连接池。</li>
</ol>
<p>注意：在Spring的配置文件里引入资源文件时，路径前需要加classpath（指定文件路径在输出文件的classes文件下）。MyBatis配置文件中则不需要加classpath。</p>
<h3 id="原生DAO开发"><a href="#原生DAO开发" class="headerlink" title="原生DAO开发"></a>原生DAO开发</h3><h4 id="1）编写接口和实现类"><a href="#1）编写接口和实现类" class="headerlink" title="1）编写接口和实现类"></a>1）编写接口和实现类</h4><p>UserDao.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">findUserByUserId</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUserByUserName</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserDaoImpl.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserByUserId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserByUserName</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2）在Spring配置文件中配置原生DAO的实现类"><a href="#2）在Spring配置文件中配置原生DAO的实现类" class="headerlink" title="2）在Spring配置文件中配置原生DAO的实现类"></a>2）在Spring配置文件中配置原生DAO的实现类</h4><p>ApplicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置原生DAO实现--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--class必须指定Dao实现类的全路径名称--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"com.xinxing.dao.UserDaoImpl"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：配置原生DAO的时候，class属性必须指定接口的<strong>实现类</strong>，不能指定接口，因为接口的实现类可能有很多。</p>
<h4 id="3）让DAO的实现类继承SqlSessionDaoSupport"><a href="#3）让DAO的实现类继承SqlSessionDaoSupport" class="headerlink" title="3）让DAO的实现类继承SqlSessionDaoSupport"></a>3）让DAO的实现类继承SqlSessionDaoSupport</h4><p>由于现在MyBatis的SqlSessionFactory归Spring管理，我们要想得到SqlSession就需要拿到SqlSessionFactory，SqlSessionDaoSupport类中已经帮我们定义好了SqlSessionFactory，SqlSessionTemplate的property，我们只需要用自己的类继承SqlSessionDaoSupport就可以得到这两个property，就可以用Spring的容器往我们自己的类中直接注入SqlSessionFacotry或者SqlSessionTemplate属性了，这样简化了我们的开发，这里是<a href="https://github.com/mybatis/spring/blob/master/src/main/java/org/mybatis/spring/support/SqlSessionDaoSupport.java">SqlSessionDaoSupport的源码</a>。</p>
<p>注入SqlSessionFactory属性</p>
<p>ApplicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置原生DAO实现--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--class必须指定Dao实现类的全路径名称--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"com.xinxing.dao.UserDaoImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>让原生DAO实现类继承SqlSessionDaoSupport</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserByUserId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里就可以用getSqlSession()方法直接获得SqlSession了</span></span><br><span class="line">        SqlSession sqlSession = getSqlSession();</span><br><span class="line">        User user = sqlSession.selectOne(<span class="string">"user.getUserById"</span>, id);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserByUserName</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        SqlSession sqlSession = getSqlSession();</span><br><span class="line">        List&lt;User&gt; users = sqlSession.selectList(<span class="string">"user.getUserByUserName"</span>, username);</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4）编写测试方法"><a href="#4）编写测试方法" class="headerlink" title="4）编写测试方法"></a>4）编写测试方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.xinxing.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">@ContextConfiguration("classpath:spring/ApplicationContext.xml")</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUserDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(userDao.findUserByUserId(<span class="number">1</span>));</span><br><span class="line">        System.out.println(userDao.findUserByUserName(<span class="string">"x"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：整合后SqlSession由Spring管理，用完后不用手动关闭。事务也由Spring管理，不要自己提交事务。</p>
<h3 id="Mapper接口代理方式开发"><a href="#Mapper接口代理方式开发" class="headerlink" title="Mapper接口代理方式开发"></a>Mapper接口代理方式开发</h3><h4 id="1）创建UserMapper接口"><a href="#1）创建UserMapper接口" class="headerlink" title="1）创建UserMapper接口"></a>1）创建UserMapper接口</h4><p>UserMapper.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">findUserById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUserByUserName</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUserByVo</span><span class="params">(QueryVo queryVo)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findUserCount</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUserList</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUserByIds</span><span class="params">(QueryVo queryVo)</span></span>;</span><br><span class="line">    <span class="function">List&lt;CustomOrder&gt; <span class="title">findOrdersAndUser1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">List&lt;Order&gt; <span class="title">findOrdersAndUser2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUserAndOrders</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2）创建UserMapper-xml映射文件"><a href="#2）创建UserMapper-xml映射文件" class="headerlink" title="2）创建UserMapper.xml映射文件"></a>2）创建UserMapper.xml映射文件</h4><p>在UserMapper.xml映射文件中编写SQL语句，这里直接使用之前编写好的Mapper文件。</p>
<p>UserMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">mapper接口代理实现编写规则：</span></span><br><span class="line"><span class="comment">1.映射文件中namespace要等于接口的全路径名称。</span></span><br><span class="line"><span class="comment">2.映射文件中sql语句id要等于接口的方法名称。</span></span><br><span class="line"><span class="comment">3.映射文件中传入参数类型要等于接口方法的传入参数类型。</span></span><br><span class="line"><span class="comment">4.映射文件中返回结果集类型要等于接口方法的返回值类型。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.xinxing.mappers.UserMapper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--封装sql条件，封装后可以重用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"user_Where"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"id != null"</span>&gt;</span></span><br><span class="line">                and id=#&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username != null and username != ''"</span>&gt;</span></span><br><span class="line">                and username like '%$&#123;username&#125;%'</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">        select * from user where id=#&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByUserName"</span> <span class="attr">parameterType</span>=<span class="string">"user"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        select * from user where username like '%$&#123;username&#125;%';</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span> <span class="attr">parameterType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">order</span>=<span class="string">"AFTER"</span> <span class="attr">resultType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">            select LAST_INSERT_ID()</span><br><span class="line">        <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">        insert into user (username,birthday,sex,address) value(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByVo"</span> <span class="attr">parameterType</span>=<span class="string">"QueryVo"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">        select * from user where username like '%$&#123;user.username&#125;%' and sex=#&#123;user.sex&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--只有返回结果为一行一列的时候，返回值类型才可以指定成基本类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserCount"</span> <span class="attr">resultType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">        select count(*) from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserList"</span> <span class="attr">parameterType</span>=<span class="string">"User"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">        <span class="comment">&lt;!--调用sql条件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"user_Where"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByIds"</span> <span class="attr">parameterType</span>=<span class="string">"QueryVo"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"ids != null"</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                foreach：遍历集合</span></span><br><span class="line"><span class="comment">                collection：传入集合变量名称</span></span><br><span class="line"><span class="comment">                item：每次循环出的数据放入变量中</span></span><br><span class="line"><span class="comment">                open：循环开始拼接的字符串</span></span><br><span class="line"><span class="comment">                close：循环结束拼接的字符串</span></span><br><span class="line"><span class="comment">                separator：循环中拼接的分隔符</span></span><br><span class="line"><span class="comment">                --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"ids"</span> <span class="attr">item</span>=<span class="string">"id"</span> <span class="attr">open</span>=<span class="string">"id in ("</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">                    #&#123;id&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 一对一：自动映射 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findOrdersAndUser1"</span> <span class="attr">resultType</span>=<span class="string">"CustomOrder"</span>&gt;</span></span><br><span class="line">        select a.*, b.id uid, username, birthday, sex, address</span><br><span class="line">        from `order` a, `user` b</span><br><span class="line">        where a.user_id = b.id;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 一对一：手动映射 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    id: resultMap的唯一标示</span></span><br><span class="line"><span class="comment">    type: 将查询出的数据放入指定类型的对象中</span></span><br><span class="line"><span class="comment">    注意：手动映射需要指定数据库中表的字段名与java中pojo类的属性名称的对应关系</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"orderAndUserResultMap"</span> <span class="attr">type</span>=<span class="string">"order"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        id标签指定主键字段对应关系</span></span><br><span class="line"><span class="comment">        column：数据库中的字段名称</span></span><br><span class="line"><span class="comment">        property：java pojo中的属性名称</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- result标签指定非主键列的对应关系 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"user_id"</span> <span class="attr">property</span>=<span class="string">"userid"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"number"</span> <span class="attr">property</span>=<span class="string">"number"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"createtime"</span> <span class="attr">property</span>=<span class="string">"createtime"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"note"</span> <span class="attr">property</span>=<span class="string">"note"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        association标签指定单个对象的对应关系</span></span><br><span class="line"><span class="comment">        property: 指定将数据放入Order中的非基本类型的属性中，如user对象</span></span><br><span class="line"><span class="comment">        javaType: user属性的类型</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"user"</span> <span class="attr">javaType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"uid"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">property</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"birthday"</span> <span class="attr">property</span>=<span class="string">"birthday"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"sex"</span> <span class="attr">property</span>=<span class="string">"sex"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"address"</span> <span class="attr">property</span>=<span class="string">"address"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findOrdersAndUser2"</span> <span class="attr">resultMap</span>=<span class="string">"orderAndUserResultMap"</span>&gt;</span></span><br><span class="line">        select a.*, b.id uid, username, birthday, sex, address</span><br><span class="line">        from `order` a, `user` b</span><br><span class="line">        where a.user_id = b.id;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userAndOrdersResultMap"</span> <span class="attr">type</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">property</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"birthday"</span> <span class="attr">property</span>=<span class="string">"birthday"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"sex"</span> <span class="attr">property</span>=<span class="string">"sex"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"address"</span> <span class="attr">property</span>=<span class="string">"address"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        collection: 指定对应的集合关系映射</span></span><br><span class="line"><span class="comment">        property: 将数据放入User中的一个集合属性中</span></span><br><span class="line"><span class="comment">        ofType: 集合中元素的类型</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"orderList"</span> <span class="attr">ofType</span>=<span class="string">"order"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"oid"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"user_id"</span> <span class="attr">property</span>=<span class="string">"userid"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"number"</span> <span class="attr">property</span>=<span class="string">"number"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"createtime"</span> <span class="attr">property</span>=<span class="string">"createtime"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"note"</span> <span class="attr">property</span>=<span class="string">"note"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserAndOrders"</span> <span class="attr">resultMap</span>=<span class="string">"userAndOrdersResultMap"</span>&gt;</span></span><br><span class="line">        select a.*, b.id oid, user_id, number, createtime, note</span><br><span class="line">        from `user` a, `order` b</span><br><span class="line">        where a.id = b.user_id;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3）在Spring核心配置文件中配置Mapper的Bean"><a href="#3）在Spring核心配置文件中配置Mapper的Bean" class="headerlink" title="3）在Spring核心配置文件中配置Mapper的Bean"></a>3）在Spring核心配置文件中配置Mapper的Bean</h4><p>MyBatis和Spring整合后，使用Mapper接口代理的方式开发，相当于将MyBatis自动生成的Mapper接口的实现类交由Spring管理，所以要在ApplicationContext中配置对应Mapper接口的Bean。</p>
<p>ApplicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mapper接口代理方式实现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userMapper"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mapperInterface配置Mapper接口的全路径名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperInterface"</span> <span class="attr">value</span>=<span class="string">"com.xinxing.mappers.UserMapper"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--sqlSessionFactory配置mybatis会话工厂--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建bean的类型要选择MyBatis-Spring整合包中提供的类型<strong>MapperFactoryBean</strong>，必须设置属性：</p>
<ol>
<li>mapperInterface 配置mapper接口。</li>
<li>sqlSessionFactory 配置sql会话。</li>
</ol>
<h4 id="4）编写测试方法-1"><a href="#4）编写测试方法-1" class="headerlink" title="4）编写测试方法"></a>4）编写测试方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.xinxing.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.xinxing.mappers.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">@ContextConfiguration("classpath:spring/ApplicationContext.xml")</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUserDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(userMapper.findUserById(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用@Autowired注解将UserMapper对象注入进来。</p>
<h4 id="5）使用包扫描的方式批量引入Mapper"><a href="#5）使用包扫描的方式批量引入Mapper" class="headerlink" title="5）使用包扫描的方式批量引入Mapper"></a>5）使用包扫描的方式批量引入Mapper</h4><p>在企业中存在大量的Mapper，可以使用包扫描器的方式批量引入Mapper。</p>
<p>在AppliecationContext.xml中配置包扫描器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    使用包扫描器的方式批量引入mapper</span></span><br><span class="line"><span class="comment">    扫描后引用的时候可以使用类名首字母小写</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定要扫描的包的全路径名称，如果有多个包，用逗号分隔--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.xinxing.mappers"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>批量引入Mapper的时候bean的类型是：<strong>org.mybatis.spring.mapper.MapperScannerConfigurer</strong>。</p>
<h2 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h2><p>企业中数据库的表非常多，所以MyBatis官方提供了一个逆行工程，可以自动生成单个表的POJO类、Mapper接口和映射文件。</p>
<h3 id="使用Maven插件的方式"><a href="#使用Maven插件的方式" class="headerlink" title="使用Maven插件的方式"></a>使用Maven插件的方式</h3><h4 id="1）创建maven工程配置插件，导入依赖"><a href="#1）创建maven工程配置插件，导入依赖" class="headerlink" title="1）创建maven工程配置插件，导入依赖"></a>1）创建maven工程配置插件，导入依赖</h4><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xinxing<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>MybatisGenerator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2）在resource文件夹新建generator-properties和generator-xml文件"><a href="#2）在resource文件夹新建generator-properties和generator-xml文件" class="headerlink" title="2）在resource文件夹新建generator.properties和generator.xml文件"></a>2）在resource文件夹新建generator.properties和generator.xml文件</h4><p>generator.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.driverLocation</span>=<span class="string">/Users/xinxing/myProjects/libs/mysql-connector-java-5.1.46.jar</span></span><br><span class="line"><span class="meta">jdbc.driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.connectionURL</span>=<span class="string">jdbc:mysql://[host]:[port]/vmalldb?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span></span><br><span class="line"><span class="meta">jdbc.userId</span>=<span class="string"></span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>

<p>generator.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">		<span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span></span><br><span class="line"><span class="meta">		<span class="meta-string">"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--导入属性配置--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"generator.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--指定特定数据库的jdbc驱动jar包的位置(绝对路径)--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">classPathEntry</span> <span class="attr">location</span>=<span class="string">"$&#123;jdbc.driverLocation&#125;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"default"</span> <span class="attr">targetRuntime</span>=<span class="string">"MyBatis3"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- optional，旨在创建class时，对注释进行控制 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!--是否去掉自动生成的注释 true:是--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suppressDate"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suppressAllComments"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!--jdbc的数据库连接：驱动类、链接地址、用户名、密码--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">jdbcConnection</span></span></span><br><span class="line"><span class="tag">				<span class="attr">driverClass</span>=<span class="string">"$&#123;jdbc.driverClass&#125;"</span></span></span><br><span class="line"><span class="tag">				<span class="attr">connectionURL</span>=<span class="string">"$&#123;jdbc.connectionURL&#125;"</span></span></span><br><span class="line"><span class="tag">				<span class="attr">userId</span>=<span class="string">"$&#123;jdbc.userId&#125;"</span></span></span><br><span class="line"><span class="tag">				<span class="attr">password</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- 非必需，类型处理器，在数据库类型和java类型之间的转换控制--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"forceBigDecimals"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- Model模型生成器,用来生成含有主键key的类，记录类 以及查询Example类</span></span><br><span class="line"><span class="comment">            targetPackage     指定生成的model生成所在的包名</span></span><br><span class="line"><span class="comment">            targetProject     指定在该项目下所在的路径</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.xinxing.pojo"</span></span></span><br><span class="line"><span class="tag">							<span class="attr">targetProject</span>=<span class="string">"src/main/java"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">&lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 是否对model添加 构造函数 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"constructorBased"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"trimStrings"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 建立的Model对象是否 不可改变  即生成的Model对象不会有 setter方法，只有构造方法 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"immutable"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!--Mapper映射文件生成所在的目录 为每一个数据库的表生成对应的SqlMap文件 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.xinxing.mapper"</span></span></span><br><span class="line"><span class="tag">						 <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件 的代码</span></span><br><span class="line"><span class="comment">                type="ANNOTATEDMAPPER",生成Java Model 和基于注解的Mapper对象</span></span><br><span class="line"><span class="comment">                type="MIXEDMAPPER",生成基于注解的Java Model 和相应的Mapper对象</span></span><br><span class="line"><span class="comment">                type="XMLMAPPER",生成SQLMap XML文件和独立的Mapper接口</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.xinxing.mapper"</span></span></span><br><span class="line"><span class="tag">							 <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span> <span class="attr">type</span>=<span class="string">"XMLMAPPER"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- 数据表进行生成操作 tableName:表名; domainObjectName:对应的DO --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"tb_address"</span> <span class="attr">domainObjectName</span>=<span class="string">"Tb_address"</span></span></span><br><span class="line"><span class="tag">			   <span class="attr">enableCountByExample</span>=<span class="string">"false"</span> <span class="attr">enableUpdateByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">			   <span class="attr">enableDeleteByExample</span>=<span class="string">"false"</span> <span class="attr">enableSelectByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">			   <span class="attr">selectByExampleQueryId</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"tb_areas"</span> <span class="attr">domainObjectName</span>=<span class="string">"Tb_areas"</span></span></span><br><span class="line"><span class="tag">			   <span class="attr">enableCountByExample</span>=<span class="string">"false"</span> <span class="attr">enableUpdateByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">			   <span class="attr">enableDeleteByExample</span>=<span class="string">"false"</span> <span class="attr">enableSelectByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">			   <span class="attr">selectByExampleQueryId</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"tb_brand"</span> <span class="attr">domainObjectName</span>=<span class="string">"Tb_brand"</span></span></span><br><span class="line"><span class="tag">			   <span class="attr">enableCountByExample</span>=<span class="string">"false"</span> <span class="attr">enableUpdateByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">			   <span class="attr">enableDeleteByExample</span>=<span class="string">"false"</span> <span class="attr">enableSelectByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">			   <span class="attr">selectByExampleQueryId</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"tb_cities"</span> <span class="attr">domainObjectName</span>=<span class="string">"Tb_cities"</span></span></span><br><span class="line"><span class="tag">			   <span class="attr">enableCountByExample</span>=<span class="string">"false"</span> <span class="attr">enableUpdateByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">			   <span class="attr">enableDeleteByExample</span>=<span class="string">"false"</span> <span class="attr">enableSelectByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">			   <span class="attr">selectByExampleQueryId</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面3出配置输出文件的包名，根据项目配置即可。在table标签出配置数据库表和对应的pojo对象名。</p>
<h4 id="3）配置项目Maven插件"><a href="#3）配置项目Maven插件" class="headerlink" title="3）配置项目Maven插件"></a>3）配置项目Maven插件</h4><p><img src="generatro01.png" alt="generatro01"></p>
<p><img src="generator02.png" alt="generator02"></p>
<ul>
<li>Working directory写项目目录</li>
<li>Command line：mybatis-generator:generate -e</li>
</ul>
<p>然后点运行就可以。</p>
<p>参考<a href="http://www.mybatis.org/generator/index.html#">MyBatis Generator官网</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
</search>
