---
title: Leetcode112/113/437. Path Sum I II III
tags:
  - 二叉树
comments: true
date: 2018-03-30 13:09:16
categories: Leetcode题解
---
有关**二叉树路径**的问题，求解时要使用**递归**。如果使用迭代，由于一个节点可能被多次访问，所以迭代求解时很难判断一个节点是否需要从路径上删除，而如果使用递归，由于递归本质上就是栈操作，所以判断路径上的节点相当容易(根本不需要判断，函数返回时从路径上删除该节点即可，相当容易)。

<!-- more -->

### 112. Path Sum I

Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.

For example:
Given the below binary tree and `sum = 22`,

```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
```

return true, as there exist a root-to-leaf path `5->4->11->2` which sum is 22.

算法，利用二叉树的前序遍历算法，遍历二叉树的每一条路径：

```java
public boolean ans = false;
public boolean hasPathSum(TreeNode root, int sum) {
    preorderWalk(root, 0, sum);
    return ans;
}
public void preorderWalk(TreeNode root, int pathSum, int sum) {
    if (root == null || ans == true) return;
    pathSum += root.val;
    if (root.left == null && root.right == null && pathSum == sum) ans = true;
    preorderWalk(root.left, pathSum, sum);
    preorderWalk(root.right, pathSum, sum);
}
```



### 113. Path Sum II

Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.

For example:

Given the below binary tree and `sum = 22`

```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
```

return

```
[
   [5,4,11,2],
   [5,8,4,5]
]
```



找到和为sum的二叉树中的所有路径。用**递归**方法求解！

算法：利用前序遍历算法求解：

```java
List<List<Integer>> ans = new ArrayList<>();
public List<List<Integer>> pathSum(TreeNode root, int sum) {
    if (root == null) return new ArrayList<>();
    preorderWalk(root, 0, sum, new ArrayList<>());
    return ans;
}
public void preorderWalk(TreeNode root, int pathSum, int sum, ArrayList<Integer> list) {
    if (root == null) return;
    pathSum += root.val;
    list.add(root.val);
    if (root.left == null && root.right == null && pathSum == sum) ans.add(new ArrayList<>(list));
    preorderWalk(root.left, pathSum, sum, list);
    preorderWalk(root.right, pathSum, sum, list);
    list.remove(list.size() - 1);
}
```



### 437. Path Sum III

You are given a binary tree in which each node contains an integer value.

Find the number of paths that sum to a given value.

The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).

The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.

**Example:**

```
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

Return 3. The paths that sum to 8 are:

1.  5 -> 3
2.  5 -> 2 -> 1
3. -3 -> 11
```



```java
public int pathSum(TreeNode root, int sum) {
    if (root == null) return 0;
    return pathSumFrom(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
}

private int pathSumFrom(TreeNode node, int sum) {
    if (node == null) return 0;
    return (node.val == sum ? 1 : 0) 
        + pathSumFrom(node.left, sum - node.val) + pathSumFrom(node.right, sum - node.val);
}
```

