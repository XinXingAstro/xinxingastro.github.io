---
title: Leetcode5/214/336/516/647. (Longest/Shortest) Palindromic Substring/Subsequence/Pairs
tags:
  - 动态规划
  - String
comments: true
date: 2018-04-04 14:23:55
categories: Leetcode题解
mathjax: true
typora-copy-images-to: ../../images
typora-root-url: ../../../source
---
Palinadromic回文字，就是从前向后读从后向前读都一样的字符串。"aba"就是一个回文字，"abc"不是回文字

<!-- more -->

---

### 5. Longest Palindromic Substring

Given a string **s**, find the longest palindromic substring in **s**. You may assume that the maximum length of **s** is 1000.

**Example 1:**

```
Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.
```

**Example 2:**

```
Input: "cbbd"
Output: "bb"
```

---

#### 算法1: 最长公共子串

用原字符串和翻转字符串的最长公共子串来找回文字。

##### 方法1:

> 将字符串S翻转，得到S‘，S和S‘的最长公共子串肯定就是S中的最长回文字。

这个算法里面有一个误区：

反例：S = “abcfgcba”，那么S' = "abcgfcba"，S和S'的最长公共子串是“abc”，但显然“abc”不是回文字。

为了避免这个错误，我们拿到最长公共子串s后，需要检查s在原字符串中的位置，是否和s‘(将s翻转)在原字符串中的位置相同，如果相同，我们才更新最长回文字，如果不同，则说明不是回文字。

##### 方法2:

利用回文字自身对称的特性，我们可以直接判断S的子串在翻转以后是否和自身相等：

`S.substr(j, n-i) == S'.substr(i, n-j) i:0~n, j:0~n-i`

时间复杂度：$O(n^2)$

空间复杂度：$O(n^2)$(可以降到$O(n)$)

#### 算法2: 暴力枚举

对于所有可能的子串的起点和终点，判断该子串是否是回文字。

时间复杂度：O(n^3): 假设原字符串的长度为n，则从n个字符中选择两个点（起点和终点）一共有n(n - 1)/2中选择，对于每个子串，我们要进行一次遍历来判断该子串是否是回文字，需要O(n)时间，所以一共需要O(n^3)时间。

空间复杂度：O(1)

#### 算法3: 动态规划

为了避免暴力枚举算法中的重复计算，我们考虑如果我们已经知道"bab"是回文字，那么显然"ababa"肯定也是回文字，因为它左右两边的字符相等。我们定义$P(i, j)$如下所示：

&emsp;&emsp;$P(i,j) = true$   如果子串$S_i…S_j$是回文字
&emsp;&emsp;$P(i,j) = false$  否则

因此我们可以得到**递推公式**：

&emsp;&emsp;$P(i,j) = (P(i + 1, j - 1)\space and\space S_i == S_j)$

**边界条件**：

&emsp;&emsp;$P(i,i) = true$

&emsp;&emsp;$P(i, i+1) = (S_i == S_j)$

时间复杂度：$O(n^2)$

空间复杂度：$O(n^2)$ 由于是2D动态规划，可以降到一维动态规划$O(n)$.

#### 算法4: 中心扩散法

由于一个回文字是对称的，所以我们可以从一个中心往外扩散，来检测一个字符串是不是回文字。一个字符串的中心共有2n-1个，因为可以以一个字符为中心，又可以以两个字符之间的空隙为中心。对于每一个中心，采用两边扩散法找出最长回文子串。

```java
private int start;
private int end;
private int maxLen;
public String longestPalindrome(String s) {
    if (s == null) return null;
    for (int i = 0; i < s.length(); i++) {
        getLength(s, i, i);
        getLength(s, i, i+1);
    }
    return s.substring(start, end + 1);
}
public void getLength(String s, int left, int right) {
    while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
        left--;
        right++;
    }
    int len = right - left - 1;
    if (len > maxLen) {
        maxLen = len;
        start = left + 1;
        end = right - 1;
    }
}
```

时间复杂度：$O(n^2)$: 一共有2n-1个中心，每个中序需要$O(n)$的时间检查

空间复杂度：O(1)

#### 算法5: Manacher's算法

该算法可以在$O(n)$时间内完成。[详细解释看这里。](https://articles.leetcode.com/longest-palindromic-substring-part-ii/)

```java
int len = 0, maxLength = 0, init = 0;
public String longestPalindrome(String s) {
    char[] chars = s.toCharArray();
    len = s.length();
    if (len <= 1) return s;
    for (int i = 0; i < len; i++) {
        i = manacher(chars, i);
    }
    return s.substring(init, init + maxLength);
}
public int manacher(char[] chars, int k) {
    int i = k - 1, j = k;
    while (j < len - 1 && chars[j] == chars[j + 1]) j++;
    int nextCenter = j++;
    while (i >= 0 && j < len && chars[i] == chars[j]) {
        i--;
        j++;
    }
    if (j - i - 1 > maxLength) {
        maxLength = j - i - 1;
        init = i + 1;
    }
    return nextCenter;
}
```

---

### 214. Shortest Palindrome

Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.

For example: 

Given `"aacecaaa"`, return `"aaacecaaa"`.

Given `"abcd"`, return `"dcbabcd"`.

**Credits:**
Special thanks to [@ifanchu](https://leetcode.com/discuss/user/ifanchu) for adding this problem and creating all test cases. Thanks to [@Freezen](https://leetcode.com/discuss/user/Freezen) for additional test cases.

---

#### 算法1: 暴力枚举[Time Limit Exceeded]

**直觉**：根据问题，我们只允许在字符串的开头插入字符。因此我们可以从字符串开头开始，找到最长的回文字子串，然后我们可以将剩下的部分翻转后放在字符串的开头，这样整个字符串就成了回文字，如果只能在开头插入字符，用这种方法找到的回文字肯定就是最短的回文字。

例：给出字符串"abcbabcab"。该字符串的最长回文字子串是"abcba"，剩下的部分是"bcab"。因此题目要求的字符串就是"bcab"的翻转"bacb" + 原字符串"abcbabcab" = "bacbabcbabcab"。

算法(Leetcode5中的算法1的方法2)：

- 创建原字符串s的翻转记为`rev`。这个字符串是为了计算最长回文子串。
- 遍历s中的字符串i从0到size(s)-1:
  - 如果`s[0~n-i] == rev[i~end]`，我们就找到了一个从0到n-i的回文字。
  - 我们找到从s[0]开始的回文字后就可以将s剩下部分翻转，加到s开头，或将rev前半部分加到s开头，就得到了解。

```java
public String shortestPalindrome(String s) {
    if (s == null) return "";
    int len = s.length();
    StringBuilder sb = new StringBuilder(s);
    StringBuilder rev = sb.reverse();
    for (int i = 0; i < len; i++) {
        if (s.substring(0, len-i).equals(rev.substring(i))) {
            return rev.substring(0, i) + s;
        }
    }
    return "";
}
```

#### 算法2: 两指针+递归

算法1中我们判断一个子串是否是回文字，需要0(n)的时间，我们可以针对这部分算法进行优化。

给定一个字符串"abcbabcaba"，定义两个指针i，j，初始化i = 0, j从n-1遍历到0，每当`s[i] == s[j]`的时候`i++`. 现在我们只需要在[0, i)范围内搜索。通过这种方法，我们减少了搜索最长回文子串的长度。**字符串的最长回文子串一定就在[0, i)范围内**。

正确性证明：如果这个字符串本身就是一个回文字，i就是加n次，如果字符串末尾还有其他字符，i增加的次数也只会是回文字的长度。因此即使[0, i)这个范围不是总等于回文字的长度，它有可能比回文字要长，但是可以保证它总是包含从字符串开头开始的最长回文字。

最好的例子是整个字符串都是回文字，最坏的例子是回文字在字符串的末尾，例如"aababababababa", 在这个字符串里i会移动12下（从a移动到倒数第2个b），然后我们需要在[0, 12)这个范围内继续检查，对应字符串"aabababababa", 这次检查的时候我们得到i=10，对应子串"aababababa"。按照这种方法字符串每次只减少两个字符，所以我们需要进行(n/2)次检查。

算法：

函数`shortestPalindrome()`是一个递归函数，以s最为参数

- 初始化i = 0
- 迭代j从n-1到0:
  - if s[i] == s[j]. i++
- if i == s.length(), 整个字符串就是一个回文字，因此返回整个字符串
- else :
  - 将i以后的部分翻转+递归计算s的[0, i-1)部分+i后面的部分。

```java
public String shortestPalindrome(String s) {
    if (s == null) return "";
    int len = s.length();
    int i = 0;
    for (int j = (len-1); j >= 0; j--) {
        if (s.charAt(i) == s.charAt(j)) i++;
    }
    if (i == len) return s;
    StringBuilder sb = new StringBuilder(s.substring(i, len));
    return sb.reverse() + shortestPalindrome(s.substring(0, i)) + s.substring(i);
}
```

时间复杂的：$O(n^2)$；我们最多需要进行n/2次递归，每次递归都要遍历对比字符串的每个字符，所以时间复杂度是$O(n^2)$

空间复杂度：$O(n)$；对于翻转字符串我们需要O(n)的空间储存。

Leecode: 5ms

#### 算法3: KMP算法

**直觉**：之前算法的时间主要浪费在每次从字符串开头查找回文字上，我们可以用KMP算法来完成这部分任务。

**KMP算法简介**：

KMP是一个字符串查找算法，时间复杂度$O(n+m)$，n是text的长度，m是pattern的长度。KMP算法的核心部件是查找表。构建查找表的目的是为了存储一个字符串的前缀和后缀相互匹配的长度，即形如这样的一个字符串"abc…abc"，它的前缀有三个字符"abc"和后缀一样，所以这个字符串在查找表中的数值就是3。这个表至关重要，因为如果我们要从一个字符串$b_0b_1…b_n$中查找子串，前s个字符都已经匹配了，但是第s+1个字符没有匹配，我们查找条中第s个元素的值，假设是3，说明前s个字符中$b_0b_1b_2$和$b_{s-2}b_{s-1}b_s$是相同的，那么我们就可以直接将第四位字符$b_4$对准当前字符进行比较就可以。

生成查找表的算法如下所示：

**设f(i)表示以第i个元素结尾的子串中前缀后缀相同的字符个数。**

- 初始化f[0] = 0，目前没有相同的前后缀
- 我们遍历数组，i从1到n-1
  - t = f[i-1]
  - 当 t>0 并且 $b_i \neq b_t$时，t = f[t-1]
  - 如果$b_i == b_t$ t++
  - f(i) = t

```java
f[0] = 0
for (i = 1; i < n; i++) {
    t = f[i-1]
    while (t > 0 && b[i] != b[t]) {
        t = f[t-1]
    }
    if (b[i] == b[t]) t++
    f(i) = t
}
```

查找表的生成过程如下所示：

![KMP](https://leetcode.com/problems/shortest-palindrome/Figures/214/shortest_palindrome.png)

在算法1中我么将原字符串翻转存放咋rev中，遍历s检查 `s[0:n-i] == rev[i:end]`。**现在我们只要将rev接在s的后面用KMP中简历查找表的算法，检查字符串中最长的和后缀相等的前缀，就是原字符串中从头开始的最长回文字。**

```java
public String shortestPalindrome_KMP(String s) {
    if (s == null) return "";
    int len = s.length();
    StringBuilder rev = new StringBuilder(s);
    rev = rev.reverse();
    String new_s = s + "#" + rev.toString();
    int newLen = new_s.length();
    int[] f = new int[newLen];
    for (int i = 1; i < newLen; i++) {
        int t = f[i - 1];
        while (t > 0 && new_s.charAt(i) != new_s.charAt(t)) 
            t = f[t - 1];
        if (new_s.charAt(i) == new_s.charAt(t)) 
            t++;
        f[i] = t;
    }
    return rev.substring(0, len - f[newLen-1]) + s;
}
```

时间复杂度：$O(n)$

空间复杂度：$O(n)$

Leetcode: 17ms

---

### 336. Palindrome Pairs

Given a list of **unique** words, find all pairs of **distinct** indices `(i, j)` in the given list, so that the concatenation of the two words, i.e. `words[i] + words[j]` is a palindrome.

**Example 1:**
Given `words` = `["bat", "tab", "cat"]`
Return `[[0, 1], [1, 0]]`
The palindromes are `["battab", "tabbat"]`

**Example 2:**
Given `words` = `["abcd", "dcba", "lls", "s", "sssll"]`
Return `[[0, 1], [1, 0], [3, 2], [2, 4]]`
The palindromes are `["dcbaabcd", "abcddcba", "slls", "llssssll"]`

**Credits:**
Special thanks to [@dietpepsi](https://leetcode.com/discuss/user/dietpepsi) for adding this problem and creating all test cases.

---

### 516. Longest Palindromic Subsequence

Given a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000.

**Example 1:**
Input: 

```
"bbbab"
```

Output: 

```
4
```

One possible longest palindromic subsequence is "bbbb".

**Example 2:**
Input:

```
"cbbd"
```

Output:

```
2
```

One possible longest palindromic subsequence is "bb".

---

### 647. Palindromic Substrings

Given a string, your task is to count how many palindromic substrings in this string.

The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters. 

**Example 1:**

```
Input: "abc"
Output: 3
Explanation: Three palindromic strings: "a", "b", "c".
```

**Example 2:**

```
Input: "aaa"
Output: 6
Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".
```

**Note:**

1. The input string length won't exceed 1000.

---

#### 算法1: 中心扩散法

**直觉**：如果字符串的长度为n，那么可以作为中心的位置就有2n-1个。对于每个中心，我们统计所有的回文字。

**注意**：左右边界的计算方法，这样就不用像上面算法那样进行两次函数调用了。

```java
public int countSubstrings(String S) {
    int N = S.length(), ans = 0;
    for (int center = 0; center <= 2*N-1; center++) {
        int left = center >> 1;
        int right = left + (center & 1);
        while (left >= 0 && right < N && S.charAt(left) == S.charAt(right)) {
            ans++;
            left--;
            right++;
        }
    }
    return ans;
}
```

