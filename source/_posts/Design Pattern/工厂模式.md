---
title: 工厂模式（Factory Pattern）
tags:
comments: true
date: 2018-03-17 16:10:10
updated:
categories: Design Pattern
---
工厂模式实现了**创建者**和**调用者**的分离，分为**简单工厂模式**、**工厂方法模式**、**抽象工厂模式**。

实例化对象，用工厂方法代替new操作

将选择实现类、创建对象统一管理控制，将调用者跟实现类解耦。

<!-- more -->


### 简单工厂模式

因为工厂类的一般是使用静态方法，所以简单工厂模式也叫静态工厂模式，通过接收的参数的不同来返回不同的对象实例。用来生产同一等级结构中的任意产品。增加新的产品，需要修改以有的代码。

```java
public interface Car {
    public void run();
}
```

```java
public class Audi implements Car {
    @Override
    public void run() {
        System.out.println("Audi is running");
    }
}
```

```java
public class Benz implements Car {
    @Override
    public void run() {
        System.out.println("Benz is running");
    }
}
```

```java
//简单工厂实现方式1
public class CarFactory01 {
    public static Car createCar(String type) {
        if (type == null) {
            return null;
        } else if (type.equals("Audi")) {
            return new Audi();
        } else if (type.equals("Benz")) {
            return new Benz();
        } else {
            return ...;
        }
    }
}
```

```java
//简单工厂实现方式2
public class CarFactory02 {
    public static Car createAudi() {
        return new Audi;
    }
    public static Car createBenz() {
        return new Benz();
    }
}
```

```java
public class Client01 {
    public static void main(String[] args) {
        Car c1 = CarFactory01.createCar("Audi");
        Car c2 = CarFactory02.createCar("Benz");
        c1.run(); //Audi is running
        c2.run(); //Benz is running
    }
}
```



简单工厂模式的UML图如下所示：

![简单工厂模式UML](简单工厂模式UML.png)



### 工厂方法模式

为了避免简单工厂模式的缺点（不满足开闭原则，即要进行扩展必须修改代码），出现了工厂方法模式。工厂方面模式和简单工厂模式最大的不同在于，简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。

用来生产同一等级结构中的固定产品。支持增加任意产品

```java
public interface CarFactory {
    public Car createCar();
}
```

```java
public class AudiFactory implements CarFactory {
    @Override
    public Car createCar() {
        return new Audi();
    }
}
```

```java
public class BenzFactory implements CarFactory {
    @Override
    public Car createCar() {
        return new Benz();
    }
}
```

```java
public class Client02 {
    public static void main(String[] args) {
        Car c1 = AudiFactory.createCar();
        Car c2 = BenzFactory.createCar();
        c1.run(); //Audi is running
        c2.run(); //Benz is running
    }
}
```

现在如果想要在增加一个BMW工厂，只需要在新建一个BMWFactory类实现Car接口就可以，现有的类和接口都不需要修改。

工厂方法模式UML图如下：

![工厂方法模式UML](工厂方法模式UML.png)



根据设计理论，工厂方法模式更优，但是由于工厂方法模式的结构、代码、编程难道和管理上都比简单工厂模式要复杂，所以实际上一般都使用简单工厂模式。

### 抽象工厂模式

用来生产不同**产品族**的全部产品。对于增加新的产品，无能为力；支持增加产品族。

在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。

抽象工厂模式UML图如下所示：
![抽象工厂模式UML](抽象工厂模式UML.png)



### 总结

**简单工厂模式（静态工厂模式）**

- 虽然某种程度不符合设计原则，但实际使用最多

**工厂方法模式**

- 不修改以有类的前提下，通过增加新的工厂类实现扩展

**抽象工厂模式**

- 不可以增加产品，可以增加产品族

#### 典型应用场景

- JDK中Calendar的getInstance方法
- JDBC中Connection对象的获取
- Hibernate中SessionFactory创建Session
- Spring中IOC容器创建管理管理bean对象
- XML解析时的DocumentBuilderFactory创建解析器对象
- 反射中Class对象的newInstance()